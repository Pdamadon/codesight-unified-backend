{"version":3,"file":"background.js","mappings":"AA46BA","sources":["webpack://unified-codesight-tracker/./background.js"],"sourcesContent":["// Unified CodeSight Background Service Worker v2.0\n// Advanced screenshot capture and data management\n\nclass UnifiedBackgroundService {\n  constructor() {\n    this.activeSessions = new Map();\n    this.screenshotQueue = [];\n    this.dataQueue = [];\n    this.isProcessingQueue = false;\n    this.websocketConnection = null;\n    this.reconnectAttempts = 0;\n    this.config = {\n      backendUrl: process.env.BACKEND_URL || 'wss://gentle-vision-production.up.railway.app/ws',\n      apiKey: process.env.API_KEY || 'production-key-placeholder',\n      maxScreenshotSize: 2 * 1024 * 1024, // 2MB\n      compressionQuality: 0.8,\n      burstModeDelay: 300,\n      maxQueueSize: 100\n    };\n    \n    this.initializeService();\n  }\n\n  initializeService() {\n    // Listen for messages from content scripts\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      this.handleMessage(message, sender, sendResponse);\n      return true; // Keep message channel open for async responses\n    });\n\n    // Listen for tab updates (navigation detection)\n    chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n      this.handleTabUpdate(tabId, changeInfo, tab);\n    });\n\n    // Listen for tab activation\n    chrome.tabs.onActivated.addListener((activeInfo) => {\n      this.handleTabActivation(activeInfo);\n    });\n    \n    // Listen for tab removal to cleanup sessions\n    chrome.tabs.onRemoved.addListener((tabId) => {\n      this.handleTabRemoved(tabId);\n    });\n\n    // Cleanup on extension startup\n    this.cleanupOldData();\n    \n    // Start periodic cleanup\n    this.startPeriodicCleanup();\n    \n    // Load settings and auto-connect to WebSocket on startup\n    this.loadSettingsAndConnect();\n    \n    // Clear storage to fix quota issues\n    this.clearStorageQuota();\n    \n    console.log('Unified Background Service initialized v2.0');\n  }\n\n  async handleMessage(message, sender, sendResponse) {\n    try {\n      switch (message.action) {\n        case 'CAPTURE_SCREENSHOT':\n          const screenshot = await this.captureScreenshot(sender.tab.id, message.data);\n          sendResponse({ success: true, screenshotId: screenshot?.id });\n          break;\n\n        case 'START_SESSION':\n          await this.startSession(sender.tab.id, message.sessionId, message.config);\n          sendResponse({ success: true });\n          break;\n\n        case 'STOP_SESSION':\n          const sessionData = await this.stopSession(sender.tab.id);\n          sendResponse({ success: true, data: sessionData });\n          break;\n\n        case 'CONNECT_WEBSOCKET':\n          await this.connectWebSocket(message.url);\n          sendResponse({ success: true, connected: !!this.websocketConnection });\n          break;\n\n        case 'SEND_DATA':\n          await this.sendDataToBackend(message.data);\n          sendResponse({ success: true });\n          break;\n\n        case 'BURST_CAPTURE':\n          await this.startBurstCapture(sender.tab.id, message.trigger, message.count);\n          sendResponse({ success: true });\n          break;\n\n        case 'GET_SESSION_STATUS':\n          const status = this.getSessionStatus(sender.tab.id);\n          sendResponse({ success: true, status });\n          break;\n\n        case 'START_BACKEND_SESSION':\n          await this.startBackendSession(message.sessionId, message.config, message.generatedTask);\n          sendResponse({ success: true });\n          break;\n\n        case 'STOP_BACKEND_SESSION':\n          await this.stopBackendSession(message.sessionId);\n          sendResponse({ success: true });\n          break;\n\n        case 'FETCH_TASK':\n          console.log('Background: FETCH_TASK message received'); // Debug log\n          const task = await this.fetchTaskFromAPI(message.sessionId, message.difficulty);\n          sendResponse(task);\n          break;\n\n        case 'ping':\n          sendResponse({ success: true, message: 'Background script is working', connected: !!this.websocketConnection });\n          break;\n\n        default:\n          sendResponse({ success: false, error: 'Unknown action' });\n      }\n    } catch (error) {\n      console.error('Background: Message handling error:', error);\n      sendResponse({ success: false, error: error.message });\n    }\n  }\n\n  // Advanced screenshot capture with WebP compression\n  async captureScreenshot(tabId, data = {}) {\n    try {\n      // Capture the visible tab\n      const dataUrl = await chrome.tabs.captureVisibleTab(null, {\n        format: 'png',\n        quality: 100\n      });\n\n      if (!dataUrl) {\n        throw new Error('Failed to capture screenshot');\n      }\n\n      // Convert to WebP for better compression\n      const webpDataUrl = await this.convertToWebP(dataUrl, this.config.compressionQuality);\n      \n      // Generate screenshot metadata\n      const screenshot = {\n        id: this.generateId(),\n        tabId,\n        timestamp: Date.now(),\n        trigger: data.trigger || 'manual',\n        url: data.url,\n        viewport: data.viewport,\n        dataUrl: webpDataUrl,\n        originalSize: dataUrl.length,\n        compressedSize: webpDataUrl.length,\n        compressionRatio: (1 - webpDataUrl.length / dataUrl.length) * 100\n      };\n\n      // Add to queue for processing\n      this.addToScreenshotQueue(screenshot);\n\n      // Store temporarily in chrome.storage\n      await this.storeScreenshot(screenshot);\n\n      console.log('Background: Screenshot captured', {\n        id: screenshot.id,\n        trigger: screenshot.trigger,\n        compressionRatio: `${screenshot.compressionRatio.toFixed(1)}%`\n      });\n\n      return screenshot;\n\n    } catch (error) {\n      console.error('Background: Screenshot capture failed:', error);\n      return null;\n    }\n  }\n\n  // Convert PNG to WebP for better compression\n  async convertToWebP(pngDataUrl, quality = 0.8) {\n    try {\n      // For service workers, we'll skip WebP conversion and return original\n      // as Image and OffscreenCanvas are not available in service worker context\n      console.log('Background: WebP conversion skipped in service worker, using original PNG');\n      return pngDataUrl;\n    } catch (error) {\n      console.log('Background: WebP conversion failed, using original PNG');\n      return pngDataUrl;\n    }\n  }\n\n  // Burst mode screenshot capture\n  async startBurstCapture(tabId, trigger, count = 5) {\n    const burstId = this.generateId();\n    console.log('Background: Starting burst capture', { burstId, trigger, count });\n\n    for (let i = 0; i < count; i++) {\n      setTimeout(async () => {\n        try {\n          await this.captureScreenshot(tabId, {\n            trigger: `burst_${trigger}_${i + 1}`,\n            burstId,\n            burstIndex: i + 1,\n            burstTotal: count\n          });\n        } catch (error) {\n          console.error(`Background: Burst capture ${i + 1} failed:`, error);\n        }\n      }, i * this.config.burstModeDelay);\n    }\n  }\n\n  // Modal and overlay detection\n  async detectAndCaptureModals(tabId) {\n    try {\n      // Inject script to detect modals\n      const results = await chrome.scripting.executeScript({\n        target: { tabId },\n        func: () => {\n          const modals = [];\n          \n          // Common modal selectors\n          const modalSelectors = [\n            '[role=\"dialog\"]',\n            '[role=\"alertdialog\"]',\n            '.modal',\n            '.popup',\n            '.overlay',\n            '[data-modal]',\n            '[aria-modal=\"true\"]'\n          ];\n\n          modalSelectors.forEach(selector => {\n            const elements = document.querySelectorAll(selector);\n            elements.forEach(element => {\n              const rect = element.getBoundingClientRect();\n              if (rect.width > 0 && rect.height > 0) {\n                const computedStyle = window.getComputedStyle(element);\n                if (computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden') {\n                  modals.push({\n                    selector,\n                    rect: {\n                      x: rect.x,\n                      y: rect.y,\n                      width: rect.width,\n                      height: rect.height\n                    },\n                    zIndex: computedStyle.zIndex,\n                    isVisible: true\n                  });\n                }\n              }\n            });\n          });\n\n          return modals;\n        }\n      });\n\n      const modals = results[0]?.result || [];\n      \n      if (modals.length > 0) {\n        console.log('Background: Detected modals:', modals.length);\n        \n        // Capture screenshot with modal context\n        await this.captureScreenshot(tabId, {\n          trigger: 'modal_detected',\n          modalCount: modals.length,\n          modals: modals\n        });\n      }\n\n      return modals;\n\n    } catch (error) {\n      console.error('Background: Modal detection failed:', error);\n      return [];\n    }\n  }\n\n  // Screenshot queue management\n  addToScreenshotQueue(screenshot) {\n    if (this.screenshotQueue.length >= this.config.maxQueueSize) {\n      console.warn('Background: Screenshot queue full, removing oldest');\n      this.screenshotQueue.shift();\n    }\n\n    this.screenshotQueue.push(screenshot);\n    \n    // Additional cleanup if queue is getting too large\n    if (this.screenshotQueue.length > this.config.maxQueueSize / 2) {\n      this.cleanupOldScreenshotsFromQueue();\n    }\n    \n    this.processScreenshotQueue();\n  }\n  \n  cleanupOldScreenshotsFromQueue() {\n    const now = Date.now();\n    const maxAge = 5 * 60 * 1000; // 5 minutes\n    \n    this.screenshotQueue = this.screenshotQueue.filter(screenshot => {\n      return (now - screenshot.timestamp) < maxAge;\n    });\n  }\n\n  async processScreenshotQueue() {\n    if (this.isProcessingQueue || this.screenshotQueue.length === 0) {\n      return;\n    }\n\n    this.isProcessingQueue = true;\n\n    try {\n      while (this.screenshotQueue.length > 0) {\n        const screenshot = this.screenshotQueue.shift();\n        await this.processScreenshot(screenshot);\n      }\n    } catch (error) {\n      console.error('Background: Queue processing error:', error);\n    } finally {\n      this.isProcessingQueue = false;\n    }\n  }\n\n  async processScreenshot(screenshot) {\n    try {\n      // Send to backend if connected\n      if (this.websocketConnection && this.websocketConnection.readyState === WebSocket.OPEN) {\n        await this.sendScreenshotToBackend(screenshot);\n      }\n\n      // Clean up old screenshots from storage\n      await this.cleanupOldScreenshots();\n\n    } catch (error) {\n      console.error('Background: Screenshot processing failed:', error);\n    }\n  }\n\n  // WebSocket connection management\n  async connectWebSocket(url = this.config.backendUrl) {\n    try {\n      if (this.websocketConnection) {\n        this.websocketConnection.close();\n      }\n\n      this.websocketConnection = new WebSocket(url);\n\n      this.websocketConnection.onopen = () => {\n        console.log('Background: WebSocket connected');\n        this.reconnectAttempts = 0; // Reset reconnection counter\n        \n        // Wait for connection to be fully ready before authenticating\n        setTimeout(() => {\n          if (this.websocketConnection && this.websocketConnection.readyState === WebSocket.OPEN) {\n            this.authenticateConnection();\n          }\n        }, 100);\n      };\n\n      this.websocketConnection.onmessage = (event) => {\n        this.handleWebSocketMessage(event);\n      };\n\n      this.websocketConnection.onclose = (event) => {\n        console.log('Background: WebSocket disconnected', event.code, event.reason);\n        this.websocketConnection = null;\n        \n        // Attempt reconnection after delay (exponential backoff)\n        const delay = Math.min(5000 * Math.pow(2, this.reconnectAttempts || 0), 30000);\n        this.reconnectAttempts = (this.reconnectAttempts || 0) + 1;\n        \n        console.log(`Background: Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);\n        \n        setTimeout(() => {\n          this.connectWebSocket(url);\n        }, delay);\n      };\n\n      this.websocketConnection.onerror = (error) => {\n        console.error('Background: WebSocket error:', error);\n      };\n\n    } catch (error) {\n      console.error('Background: WebSocket connection failed:', error);\n    }\n  }\n\n  async authenticateConnection() {\n    if (!this.websocketConnection) {\n      console.log('Background: No WebSocket connection available for authentication');\n      return;\n    }\n\n    if (this.websocketConnection.readyState !== WebSocket.OPEN) {\n      console.log('Background: WebSocket not ready for authentication, state:', this.websocketConnection.readyState);\n      return;\n    }\n\n    try {\n      const authMessage = {\n        type: 'authenticate',\n        data: {\n          apiKey: this.config.apiKey,\n          clientType: 'extension',\n          extensionVersion: '2.0.0',\n          browser: this.getBrowserInfo()\n        },\n        timestamp: Date.now()\n      };\n\n      console.log('Background: Sending authentication message');\n      this.websocketConnection.send(JSON.stringify(authMessage));\n    } catch (error) {\n      console.error('Background: Failed to send authentication message:', error);\n    }\n  }\n\n  // Removed sendConnectionInfo - authentication provides this info\n\n  async sendScreenshotToBackend(screenshot) {\n    if (!this.websocketConnection || this.websocketConnection.readyState !== WebSocket.OPEN) {\n      return;\n    }\n\n    try {\n      // Send screenshot data directly (backend expects 'screenshot_data' type)\n\n      // Send screenshot data with proper backend format\n      if (screenshot.compressedSize < this.config.maxScreenshotSize) {\n        const imageData = {\n          type: 'screenshot_data',\n          sessionId: this.currentSessionId || 'unknown',\n          data: {\n            id: screenshot.id,\n            dataUrl: screenshot.dataUrl,\n            timestamp: screenshot.timestamp,\n            metadata: {\n              ...screenshot,\n              dataUrl: null // Metadata without image data\n            }\n          },\n          timestamp: Date.now()\n        };\n\n        this.websocketConnection.send(JSON.stringify(imageData));\n      }\n\n    } catch (error) {\n      console.error('Background: Failed to send screenshot to backend:', error);\n    }\n  }\n\n  handleWebSocketMessage(event) {\n    try {\n      const message = JSON.parse(event.data);\n      \n      switch (message.type) {\n        case 'authentication_success':\n          console.log('Background: Authentication successful');\n          this.processQueuedData(); // Send any queued data\n          break;\n\n        case 'authentication_failed':\n          console.error('Background: Authentication failed:', message.data);\n          break;\n\n        case 'capture_request':\n          this.handleCaptureRequest(message);\n          break;\n          \n        case 'burst_request':\n          this.handleBurstRequest(message);\n          break;\n          \n        case 'config_update':\n          this.updateConfig(message.config);\n          break;\n          \n        default:\n          console.log('Background: Unknown WebSocket message:', message.type);\n      }\n    } catch (error) {\n      console.error('Background: WebSocket message handling error:', error);\n    }\n  }\n\n  async handleCaptureRequest(message) {\n    const { tabId, trigger } = message;\n    \n    if (tabId) {\n      await this.captureScreenshot(tabId, { trigger });\n    } else {\n      // Capture all active tabs\n      const tabs = await chrome.tabs.query({ active: true });\n      for (const tab of tabs) {\n        await this.captureScreenshot(tab.id, { trigger });\n      }\n    }\n  }\n\n  async handleBurstRequest(message) {\n    const { tabId, trigger, count } = message;\n    await this.startBurstCapture(tabId, trigger, count);\n  }\n\n  // Session management\n  async startSession(tabId, sessionId, config = {}) {\n    const session = {\n      id: sessionId,\n      tabId,\n      startTime: Date.now(),\n      config: { ...this.config, ...config },\n      screenshots: [],\n      events: []\n    };\n\n    this.activeSessions.set(tabId, session);\n    \n    // Notify backend\n    if (this.websocketConnection) {\n      this.websocketConnection.send(JSON.stringify({\n        type: 'session_start',\n        sessionId,\n        data: {\n          tabId,\n          url: session.url,\n          title: session.title\n        },\n        timestamp: Date.now()\n      }));\n    }\n\n    console.log('Background: Session started', { sessionId, tabId });\n  }\n\n  async stopSession(tabId) {\n    const session = this.activeSessions.get(tabId);\n    if (!session) {\n      return null;\n    }\n\n    session.endTime = Date.now();\n    session.duration = session.endTime - session.startTime;\n\n    // Collect all session data\n    const sessionData = {\n      ...session,\n      screenshots: await this.getSessionScreenshots(session.id),\n      finalScreenshot: await this.captureScreenshot(tabId, { trigger: 'session_end' })\n    };\n\n    // Notify backend\n    if (this.websocketConnection) {\n      this.websocketConnection.send(JSON.stringify({\n        type: 'session_stop',\n        sessionId: session.id,\n        data: {\n          tabId,\n          duration: session.duration,\n          eventCount: session.eventCount || 0\n        },\n        timestamp: Date.now()\n      }));\n    }\n\n    this.activeSessions.delete(tabId);\n    \n    console.log('Background: Session stopped', { \n      sessionId: session.id, \n      duration: `${Math.round(session.duration / 1000)}s` \n    });\n\n    return sessionData;\n  }\n\n  getSessionStatus(tabId) {\n    const session = this.activeSessions.get(tabId);\n    if (!session) {\n      return { active: false };\n    }\n\n    return {\n      active: true,\n      sessionId: session.id,\n      duration: Date.now() - session.startTime,\n      screenshotCount: session.screenshots.length,\n      eventCount: session.events.length\n    };\n  }\n\n  // Tab event handling\n  async handleTabUpdate(tabId, changeInfo, tab) {\n    const session = this.activeSessions.get(tabId);\n    if (!session) return;\n\n    // Capture screenshot on navigation\n    if (changeInfo.status === 'complete' && changeInfo.url) {\n      await this.startBurstCapture(tabId, 'navigation', 3);\n      \n      // Detect modals after page load\n      setTimeout(() => {\n        this.detectAndCaptureModals(tabId);\n      }, 1000);\n    }\n  }\n\n  async handleTabActivation(activeInfo) {\n    const session = this.activeSessions.get(activeInfo.tabId);\n    if (!session) return;\n\n    // Capture screenshot when tab becomes active\n    await this.captureScreenshot(activeInfo.tabId, { trigger: 'tab_activated' });\n  }\n  \n  handleTabRemoved(tabId) {\n    // Clean up session when tab is closed\n    const session = this.activeSessions.get(tabId);\n    if (session) {\n      console.log('Background: Tab closed, cleaning up session', { tabId, sessionId: session.id });\n      this.activeSessions.delete(tabId);\n      \n      // Skip automatic backend notification for tab closure to prevent race conditions\n      // Manual session management is preferred for proper database synchronization\n      console.log('Background: Session cleaned up locally (no backend notification for tab closure)');\n    }\n  }\n  \n  startPeriodicCleanup() {\n    // Run cleanup every 30 minutes\n    setInterval(() => {\n      this.performPeriodicCleanup();\n    }, 30 * 60 * 1000);\n  }\n  \n  async performPeriodicCleanup() {\n    const now = Date.now();\n    const maxSessionAge = 2 * 60 * 60 * 1000; // 2 hours\n    \n    // Clean up old sessions\n    for (const [tabId, session] of this.activeSessions) {\n      if (now - session.startTime > maxSessionAge) {\n        console.log('Background: Cleaning up old session', { tabId, sessionId: session.id });\n        this.activeSessions.delete(tabId);\n      }\n    }\n    \n    // Clean up old screenshots from queue\n    this.cleanupOldScreenshotsFromQueue();\n    \n    // Clean up storage\n    await this.cleanupOldScreenshots();\n    \n    // Log cleanup stats\n    console.log('Background: Periodic cleanup completed', {\n      activeSessions: this.activeSessions.size,\n      queueSize: this.screenshotQueue.length\n    });\n  }\n\n  // Storage management\n  async storeScreenshot(screenshot) {\n    try {\n      // Skip local storage to avoid quota issues - send directly to backend\n      console.log('Background: Screenshot captured, sending to backend immediately');\n      await this.sendScreenshotToBackend(screenshot);\n    } catch (error) {\n      console.error('Background: Screenshot processing failed:', error);\n    }\n  }\n\n  async getSessionScreenshots(sessionId) {\n    try {\n      const storage = await chrome.storage.local.get();\n      const screenshots = [];\n\n      for (const [key, value] of Object.entries(storage)) {\n        if (key.startsWith('screenshot_') && !key.endsWith('_data')) {\n          if (value.sessionId === sessionId) {\n            // Get full image data if available\n            const dataKey = `${key}_data`;\n            if (storage[dataKey]) {\n              value.dataUrl = storage[dataKey];\n            }\n            screenshots.push(value);\n          }\n        }\n      }\n\n      return screenshots.sort((a, b) => a.timestamp - b.timestamp);\n\n    } catch (error) {\n      console.error('Background: Failed to get session screenshots:', error);\n      return [];\n    }\n  }\n\n  async cleanupOldScreenshots() {\n    try {\n      const storage = await chrome.storage.local.get();\n      const cutoffTime = Date.now() - (24 * 60 * 60 * 1000); // 24 hours\n      const keysToRemove = [];\n\n      for (const [key, value] of Object.entries(storage)) {\n        if (key.startsWith('screenshot_')) {\n          if (value.timestamp && value.timestamp < cutoffTime) {\n            keysToRemove.push(key);\n            keysToRemove.push(`${key}_data`);\n          }\n        }\n      }\n\n      if (keysToRemove.length > 0) {\n        await chrome.storage.local.remove(keysToRemove);\n        console.log('Background: Cleaned up', keysToRemove.length, 'old screenshots');\n      }\n\n    } catch (error) {\n      console.error('Background: Screenshot cleanup failed:', error);\n    }\n  }\n\n  async cleanupOldData() {\n    await this.cleanupOldScreenshots();\n    \n    // Clean up other old data\n    try {\n      const storage = await chrome.storage.local.get();\n      const keysToRemove = [];\n      const cutoffTime = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7 days\n\n      for (const [key, value] of Object.entries(storage)) {\n        if (value.timestamp && value.timestamp < cutoffTime) {\n          keysToRemove.push(key);\n        }\n      }\n\n      if (keysToRemove.length > 0) {\n        await chrome.storage.local.remove(keysToRemove);\n        console.log('Background: Cleaned up', keysToRemove.length, 'old data entries');\n      }\n\n    } catch (error) {\n      console.error('Background: Data cleanup failed:', error);\n    }\n  }\n\n  // Utility methods\n  updateConfig(newConfig) {\n    this.config = { ...this.config, ...newConfig };\n    console.log('Background: Config updated:', newConfig);\n  }\n\n  generateId() {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n\n  getBrowserInfo() {\n    return {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      cookieEnabled: navigator.cookieEnabled,\n      onLine: navigator.onLine\n    };\n  }\n\n  async loadSettingsAndConnect() {\n    try {\n      // Load settings from storage\n      const settings = await chrome.storage.sync.get({\n        backendUrl: this.config.backendUrl,\n        apiKey: this.config.apiKey\n      });\n      \n      // Update config with loaded settings\n      this.config.backendUrl = settings.backendUrl;\n      if (settings.apiKey) {\n        this.config.apiKey = settings.apiKey;\n      }\n      \n      console.log('Background: Loaded settings, connecting to:', this.config.backendUrl);\n      \n      // Connect to WebSocket\n      this.connectWebSocket();\n      \n    } catch (error) {\n      console.error('Background: Failed to load settings:', error);\n      // Use default settings and connect anyway\n      this.connectWebSocket();\n    }\n  }\n\n  async sendDataToBackend(data) {\n    if (!this.websocketConnection || this.websocketConnection.readyState !== WebSocket.OPEN) {\n      console.warn('Background: WebSocket not connected, queuing data');\n      // Queue the data for later sending\n      if (!this.dataQueue) this.dataQueue = [];\n      this.dataQueue.push(data);\n      \n      // Try to reconnect if not already trying\n      if (!this.websocketConnection) {\n        this.connectWebSocket();\n      }\n      return false;\n    }\n\n    try {\n      const message = {\n        type: 'interaction_event',\n        data,\n        timestamp: Date.now(),\n        sessionId: data.sessionId || 'unknown'\n      };\n      \n      console.log('Background: Sending interaction data to backend:', data.type);\n      this.websocketConnection.send(JSON.stringify(message));\n      \n      // Process any queued data\n      this.processQueuedData();\n      \n      return true;\n    } catch (error) {\n      console.error('Background: Failed to send data to backend:', error);\n      return false;\n    }\n  }\n\n  processQueuedData() {\n    if (!this.dataQueue || this.dataQueue.length === 0) return;\n    \n    console.log(`Background: Processing ${this.dataQueue.length} queued items`);\n    \n    const queue = [...this.dataQueue];\n    this.dataQueue = [];\n    \n    queue.forEach(data => {\n      this.sendDataToBackend(data);\n    });\n  }\n\n  async startBackendSession(sessionId, config, generatedTask = null) {\n    if (!this.websocketConnection || this.websocketConnection.readyState !== WebSocket.OPEN) {\n      console.warn('Background: Cannot start backend session - WebSocket not connected');\n      return;\n    }\n\n    try {\n      // Store current session ID for screenshot messages\n      this.currentSessionId = sessionId;\n      \n      const message = {\n        type: 'session_start',\n        sessionId,\n        data: {\n          ...config,\n          generatedTask\n        },\n        timestamp: Date.now()\n      };\n\n      console.log('Background: Starting backend session:', sessionId);\n      this.websocketConnection.send(JSON.stringify(message));\n    } catch (error) {\n      console.error('Background: Failed to start backend session:', error);\n    }\n  }\n\n  async stopBackendSession(sessionId) {\n    if (!this.websocketConnection || this.websocketConnection.readyState !== WebSocket.OPEN) {\n      console.warn('Background: Cannot stop backend session - WebSocket not connected');\n      return;\n    }\n\n    try {\n      const message = {\n        type: 'session_stop',\n        sessionId,\n        timestamp: Date.now()\n      };\n\n      console.log('Background: Stopping backend session:', sessionId);\n      this.websocketConnection.send(JSON.stringify(message));\n    } catch (error) {\n      console.error('Background: Failed to stop backend session:', error);\n    }\n  }\n\n  // Fetch task from API (avoids CORS issues from content script)\n  async fetchTaskFromAPI(sessionId, difficulty = 'beginner') {\n    try {\n      console.log('Background: Fetching task from API for session:', sessionId);\n      \n      const response = await fetch('https://gentle-vision-production.up.railway.app/api/test/task/random?difficulty=' + difficulty, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      console.log('Background: Task fetched successfully:', data.task?.title);\n      \n      return data;\n    } catch (error) {\n      console.error('Background: Failed to fetch task from API:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  }\n\n  async clearStorageQuota() {\n    try {\n      // Clear all screenshot data to fix quota exceeded error\n      const storage = await chrome.storage.local.get();\n      const keysToRemove = [];\n      \n      for (const key of Object.keys(storage)) {\n        if (key.startsWith('screenshot_')) {\n          keysToRemove.push(key);\n        }\n      }\n      \n      if (keysToRemove.length > 0) {\n        await chrome.storage.local.remove(keysToRemove);\n        console.log(`Background: Cleared ${keysToRemove.length} screenshot entries from storage`);\n      }\n    } catch (error) {\n      console.error('Background: Failed to clear storage:', error);\n    }\n  }\n}\n\n// Initialize the background service\nconst backgroundService = new UnifiedBackgroundService();\n\n// Keep service worker alive\nchrome.runtime.onStartup.addListener(() => {\n  console.log('Background: Extension startup');\n});\n\nchrome.runtime.onInstalled.addListener(() => {\n  console.log('Background: Extension installed/updated');\n});"],"names":[],"sourceRoot":""}