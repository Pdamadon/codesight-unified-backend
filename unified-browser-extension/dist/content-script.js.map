{"version":3,"file":"content-script.js","mappings":"AAGA","sources":["webpack://unified-codesight-tracker/./content-script.js"],"sourcesContent":["// Unified CodeSight Content Script v2.0\n// Enhanced data capture with privacy protection and quality control\n\n(function() {\n  'use strict';\n  \n  // Prevent multiple injections\n  if (window.UnifiedCodeSightTracker || window.UNIFIED_CODESIGHT_LOADED) {\n    console.log('Unified CodeSight already loaded, skipping');\n    return;\n  }\n  \n  window.UNIFIED_CODESIGHT_LOADED = true;\n\n  class UnifiedCodeSightTracker {\n    constructor() {\n      this.isTracking = false;\n      this.sessionId = null;\n      this.startTime = 0;\n      this.events = [];\n      this.screenshots = [];\n      this.currentUrl = window.location.href;\n      \n      // Configuration\n      this.config = {\n        screenshotQuality: 0.8,\n        maxScreenshots: 200,\n        maxEvents: 1000,\n        privacyMode: true,\n        compressionEnabled: true,\n        burstModeEnabled: true\n      };\n      \n      // State tracking\n      this.pageStructure = null;\n      this.lastInteractionTime = 0;\n      this.interactionSequence = 0;\n      \n      // Task tracking\n      this.currentTask = null;\n      this.taskProgress = {\n        currentStep: 0,\n        completedSteps: []\n      };\n      this.taskOverlay = null;\n      \n      // Privacy filters - Comprehensive PII protection\n      this.sensitiveSelectors = [\n        // Password fields\n        'input[type=\"password\"]',\n        'input[name*=\"password\"]',\n        'input[name*=\"pwd\"]',\n        'input[id*=\"password\"]',\n        'input[placeholder*=\"password\"]',\n        \n        // Personal identification\n        'input[name*=\"ssn\"]',\n        'input[name*=\"social\"]',\n        'input[name*=\"social-security\"]',\n        'input[name*=\"social_security\"]',\n        'input[name*=\"socialsecurity\"]',\n        'input[id*=\"ssn\"]',\n        'input[id*=\"social\"]',\n        \n        // Credit card and payment\n        'input[name*=\"credit\"]',\n        'input[name*=\"card\"]',\n        'input[name*=\"cc\"]',\n        'input[name*=\"cvv\"]',\n        'input[name*=\"cvc\"]',\n        'input[name*=\"security-code\"]',\n        'input[name*=\"security_code\"]',\n        'input[name*=\"securitycode\"]',\n        'input[name*=\"expir\"]',\n        'input[name*=\"exp-\"]',\n        'input[name*=\"pin\"]',\n        'input[id*=\"credit\"]',\n        'input[id*=\"card\"]',\n        'input[id*=\"cvv\"]',\n        'input[id*=\"cvc\"]',\n        'input[autocomplete*=\"cc\"]',\n        \n        // Bank and financial\n        'input[name*=\"bank\"]',\n        'input[name*=\"routing\"]',\n        'input[name*=\"account\"]',\n        'input[name*=\"iban\"]',\n        'input[name*=\"swift\"]',\n        'input[id*=\"bank\"]',\n        'input[id*=\"routing\"]',\n        'input[id*=\"account\"]',\n        \n        // Personal information\n        'input[name*=\"first-name\"]',\n        'input[name*=\"first_name\"]',\n        'input[name*=\"firstname\"]',\n        'input[name*=\"last-name\"]',\n        'input[name*=\"last_name\"]',\n        'input[name*=\"lastname\"]',\n        'input[name*=\"full-name\"]',\n        'input[name*=\"full_name\"]',\n        'input[name*=\"fullname\"]',\n        'input[name=\"name\"]',\n        'input[id*=\"first-name\"]',\n        'input[id*=\"first_name\"]',\n        'input[id*=\"firstname\"]',\n        'input[id*=\"last-name\"]',\n        'input[id*=\"last_name\"]',\n        'input[id*=\"lastname\"]',\n        'input[id=\"name\"]',\n        \n        // Contact information\n        'input[name*=\"email\"]',\n        'input[name*=\"phone\"]',\n        'input[name*=\"mobile\"]',\n        'input[name*=\"telephone\"]',\n        'input[type=\"email\"]',\n        'input[type=\"tel\"]',\n        'input[id*=\"email\"]',\n        'input[id*=\"phone\"]',\n        'input[id*=\"mobile\"]',\n        \n        // Address information\n        'input[name*=\"address\"]',\n        'input[name*=\"street\"]',\n        'input[name*=\"city\"]',\n        'input[name*=\"state\"]',\n        'input[name*=\"zip\"]',\n        'input[name*=\"postal\"]',\n        'input[name*=\"country\"]',\n        'input[id*=\"address\"]',\n        'input[id*=\"street\"]',\n        'input[id*=\"city\"]',\n        'input[id*=\"state\"]',\n        'input[id*=\"zip\"]',\n        'input[id*=\"postal\"]',\n        \n        // Date of birth\n        'input[name*=\"birth\"]',\n        'input[name*=\"dob\"]',\n        'input[name*=\"age\"]',\n        'input[id*=\"birth\"]',\n        'input[id*=\"dob\"]',\n        'input[id*=\"age\"]',\n        \n        // Government IDs\n        'input[name*=\"license\"]',\n        'input[name*=\"passport\"]',\n        'input[name*=\"id-number\"]',\n        'input[name*=\"id_number\"]',\n        'input[name*=\"idnumber\"]',\n        'input[id*=\"license\"]',\n        'input[id*=\"passport\"]',\n        'input[id*=\"id-number\"]',\n        \n        // Generic sensitive fields\n        'input[type=\"hidden\"]',\n        '[data-sensitive]',\n        '.sensitive-data',\n        '[autocomplete=\"new-password\"]',\n        '[autocomplete=\"current-password\"]',\n        '[autocomplete*=\"name\"]',\n        '[autocomplete*=\"email\"]',\n        '[autocomplete*=\"tel\"]',\n        '[autocomplete*=\"address\"]',\n        '[autocomplete*=\"postal-code\"]',\n        '[autocomplete*=\"cc-\"]'\n      ];\n      \n      this.initializeTracker();\n    }\n\n    initializeTracker() {\n      // Listen for messages from background script\n      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n        this.handleMessage(message, sender, sendResponse);\n        return true; // Keep message channel open for async responses\n      });\n\n      // Set up navigation handling\n      this.setupNavigationHandling();\n      \n      // Set up state preservation for navigation\n      this.setupStatePreservation();\n      \n      // Set up periodic state saving for navigation\n      this.setupPeriodicStateSaving();\n      \n      // Restore state if needed\n      this.restoreState();\n      \n      // Restore task overlay if tracking is active (delay to ensure state is fully restored)\n      setTimeout(() => {\n        this.restoreTaskOverlay();\n      }, 200);\n      \n      console.log('Unified CodeSight Tracker initialized v2.0');\n    }\n\n    async handleMessage(message, sender, sendResponse) {\n      try {\n        switch (message.action) {\n          case 'START_TRACKING':\n            await this.startTracking(message.sessionId, message.config, message.generatedTask);\n            sendResponse({ success: true });\n            break;\n            \n          case 'STOP_TRACKING':\n            const result = await this.stopTracking();\n            sendResponse({ success: true, data: result });\n            break;\n            \n          case 'GET_STATUS':\n            sendResponse(this.getStatus());\n            break;\n            \n          case 'GET_SESSION_DATA':\n            const sessionData = this.getSessionData();\n            sendResponse({ success: true, data: sessionData });\n            break;\n            \n          case 'UPDATE_CONFIG':\n            this.updateConfig(message.config);\n            sendResponse({ success: true });\n            break;\n            \n          case 'CAPTURE_SCREENSHOT':\n            const screenshot = await this.captureScreenshot(message.trigger);\n            sendResponse({ success: true, screenshot });\n            break;\n\n          case 'ping':\n            sendResponse({ success: true, message: 'Content script is working', tracker: !!window.UnifiedCodeSightTracker });\n            break;\n            \n          default:\n            sendResponse({ success: false, error: 'Unknown action' });\n        }\n      } catch (error) {\n        console.error('Unified: Message handling error:', error);\n        sendResponse({ success: false, error: error.message });\n      }\n    }\n\n    async startTracking(sessionId, config = {}, generatedTask = null) {\n      if (this.isTracking) {\n        console.log('Unified: Already tracking');\n        return;\n      }\n      \n      // Check for user consent before starting tracking\n      const consentResult = await new Promise((resolve) => {\n        chrome.storage.local.get(['userConsent'], (result) => {\n          resolve(result.userConsent);\n        });\n      });\n      \n      if (consentResult !== true) {\n        console.log('Unified: User consent not granted, cannot start tracking');\n        return;\n      }\n\n      this.sessionId = sessionId;\n      this.startTime = Date.now();\n      this.isTracking = true;\n      this.events = [];\n      this.screenshots = [];\n      this.interactionSequence = 0;\n      \n      // Update configuration\n      this.config = { ...this.config, ...config };\n      \n      // Store generated task if provided\n      if (generatedTask) {\n        this.currentTask = generatedTask;\n        console.log('Unified: Using generated task:', generatedTask.title);\n      }\n      \n      // Analyze initial page structure\n      this.pageStructure = this.analyzePageStructure();\n      \n      // Bind event listeners\n      this.bindEventListeners();\n      \n      // Show tracking indicator\n      this.showTrackingIndicator();\n      \n      // Task display disabled - using extension popup instead\n      // await this.fetchAndDisplayTask();\n      \n      // Save state\n      this.saveState();\n      \n      // Capture initial screenshot\n      await this.captureScreenshot('session_start');\n      \n      // Start periodic validation\n      this.startPeriodicValidation();\n      \n      // Notify background script to start session on backend\n      this.startBackendSession();\n      \n      console.log('Unified: Tracking started for session:', sessionId);\n    }\n\n    async stopTracking() {\n      if (!this.isTracking) {\n        console.log('Unified: Not currently tracking');\n        return null;\n      }\n\n      this.isTracking = false;\n      \n      // Unbind event listeners\n      this.unbindEventListeners();\n      \n      // Stop navigation handling\n      this.cleanupNavigationHandling();\n      \n      // Stop state preservation\n      this.cleanupStatePreservation();\n      \n      // Stop periodic validation\n      this.stopPeriodicValidation();\n      \n      // Hide tracking indicator and task overlay\n      this.hideTrackingIndicator();\n      this.hideTaskOverlay();\n      \n      // Capture final screenshot\n      await this.captureScreenshot('session_end');\n      \n      // Perform final validation\n      const finalValidation = this.validateSessionData();\n      console.log('Unified: Final validation score:', finalValidation.score);\n      \n      // Prepare session data\n      const sessionData = await this.prepareSessionData();\n      \n      // Stop backend session\n      await this.stopBackendSession();\n      \n      // Clear periodic saving\n      if (this.stateSaveInterval) {\n        clearInterval(this.stateSaveInterval);\n        this.stateSaveInterval = null;\n      }\n      \n      // Clear state\n      this.clearState();\n      \n      console.log('Unified: Tracking stopped, captured', this.events.length, 'events');\n      \n      return sessionData;\n    }\n\n    bindEventListeners() {\n      // Enhanced click tracking\n      this.boundClickHandler = this.handleClick.bind(this);\n      document.addEventListener('click', this.boundClickHandler, true);\n      \n      // Input tracking with privacy protection\n      this.boundInputHandler = this.handleInput.bind(this);\n      document.addEventListener('input', this.boundInputHandler, true);\n      \n      // Form submission tracking\n      this.boundFormHandler = this.handleFormSubmit.bind(this);\n      document.addEventListener('submit', this.boundFormHandler, true);\n      \n      // Scroll tracking (throttled)\n      this.boundScrollHandler = this.throttle(this.handleScroll.bind(this), 200);\n      document.addEventListener('scroll', this.boundScrollHandler, true);\n      \n      // Focus tracking for accessibility\n      this.boundFocusHandler = this.handleFocus.bind(this);\n      document.addEventListener('focus', this.boundFocusHandler, true);\n      \n      // Key press tracking (for shortcuts and navigation)\n      this.boundKeyHandler = this.handleKeyPress.bind(this);\n      document.addEventListener('keydown', this.boundKeyHandler, true);\n    }\n\n    unbindEventListeners() {\n      if (this.boundClickHandler) {\n        document.removeEventListener('click', this.boundClickHandler, true);\n      }\n      if (this.boundInputHandler) {\n        document.removeEventListener('input', this.boundInputHandler, true);\n      }\n      if (this.boundFormHandler) {\n        document.removeEventListener('submit', this.boundFormHandler, true);\n      }\n      if (this.boundScrollHandler) {\n        document.removeEventListener('scroll', this.boundScrollHandler, true);\n      }\n      if (this.boundFocusHandler) {\n        document.removeEventListener('focus', this.boundFocusHandler, true);\n      }\n      if (this.boundKeyHandler) {\n        document.removeEventListener('keydown', this.boundKeyHandler, true);\n      }\n    }\n\n    async handleClick(event) {\n      if (!this.isTracking) return;\n      \n      const element = event.target;\n      const timestamp = Date.now();\n      \n      // Skip if element is too small (likely tracking pixel)\n      const rect = element.getBoundingClientRect();\n      if (rect.width < 3 && rect.height < 3) return;\n      \n      // Capture screenshot before state changes\n      const screenshotPromise = this.captureScreenshot('click', timestamp);\n      \n      // Generate enhanced multi-selector strategy with reliability scoring\n      const selectors = this.generateEnhancedSelectors(element);\n      \n      // Capture enhanced DOM context matching reference model\n      const domContext = this.captureEnhancedDOMContext(element);\n      \n      // Get comprehensive element analysis\n      const elementAnalysis = this.analyzeElementEnhanced(element);\n      \n      // Capture page state before interaction\n      const stateBefore = this.capturePageState();\n      \n      const interactionData = {\n        type: 'CLICK',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n\n        // 1) Enhanced selectors (Group 1: Selectors)\n        selectors: {\n          primary: selectors.primary,\n          alternatives: selectors.alternatives,\n          xpath: selectors.xpath,\n          cssPath: selectors.cssPath,\n          selectorReliability: selectors.selectorReliability\n        },\n\n        // Backward compatibility - keep existing flattened fields\n        primarySelector: selectors.primary,\n        selectorAlternatives: selectors.alternatives,\n        xpath: selectors.xpath,\n        cssPath: selectors.cssPath,\n        selectorReliability: selectors.selectorReliability,\n\n        // 2) Enhanced visual context (Group 2: Visual)\n        visual: {\n          boundingBox: elementAnalysis.boundingBox,\n          viewport: this.getViewportInfo(),\n          isInViewport: elementAnalysis.isInViewport,\n          percentVisible: elementAnalysis.percentVisible,\n          screenshot: null // Will be set after screenshot capture\n        },\n\n        // 3) Enhanced element analysis (Group 3: Element)\n        element: elementAnalysis,\n\n        // Backward compatibility - keep existing flattened fields\n        elementTag: elementAnalysis.tagName,\n        elementText: elementAnalysis.text,\n        elementValue: elementAnalysis.value,\n        elementAttributes: elementAnalysis.attributes,\n        boundingBox: elementAnalysis.boundingBox,\n        isInViewport: elementAnalysis.isInViewport,\n        percentVisible: elementAnalysis.percentVisible,\n\n        // 4) Enhanced DOM context (Group 4: Context)\n        context: {\n          parentElements: domContext.parentElements,\n          siblings: domContext.siblings,\n          nearbyElements: domContext.nearbyElements,\n          pageStructure: domContext.pageStructure\n        },\n\n        // Backward compatibility - keep existing flattened fields\n        parentElements: domContext.parentElements,\n        siblingElements: domContext.siblings,\n        nearbyElements: domContext.nearbyElements,\n\n        // 5) Enhanced state tracking (Group 5: State)\n        state: {\n          before: stateBefore,\n          after: null, // Will be captured after delay\n          changes: null // Will be calculated after state capture\n        },\n\n        // 6) Enhanced interaction metadata (Group 6: Interaction)\n        interaction: {\n          coordinates: {\n            clientX: event.clientX,\n            clientY: event.clientY,\n            pageX: event.pageX,\n            pageY: event.pageY,\n            offsetX: event.offsetX,\n            offsetY: event.offsetY\n          },\n          modifiers: {\n            ctrlKey: event.ctrlKey,\n            shiftKey: event.shiftKey,\n            altKey: event.altKey,\n            metaKey: event.metaKey\n          },\n          timestamp: timestamp,\n          sessionTime: timestamp - this.startTime,\n          sequence: this.interactionSequence\n        },\n\n        // Backward compatibility - legacy fields\n        metadata: {\n          sessionId: this.sessionId,\n          userId: 'anon-user',\n          timestamp: new Date(timestamp).toISOString(),\n          pageUrl: window.location.href,\n          pageTitle: document.title,\n          viewport: this.getViewportInfo()\n        },\n        pageContext: {\n          domSnapshot: this.getPrunedDOMSnapshot(element),\n          htmlHash: this.generatePageHash(),\n          networkRequests: this.getRecentNetworkRequests()\n        },\n\n        // 5) Detailed elementDetails & overlays & action\n        elementDetails: {\n          tag: element.tagName.toLowerCase(),\n          text: this.getElementText(element),\n          attributes: this.getElementAttributes(element),\n          cssSelector: this.generateCSSSelector(element),\n          xpath: this.generateXPath(element),\n          boundingBox: this.getElementBoundingBox(element),\n          computedStyle: this.getRelevantComputedStyle(element)\n        },\n        contextData: {\n          parent: this.getParentElementInfo(element),\n          ancestors: this.getAncestorChain(element),\n          siblings: this.getSiblingElements(element),\n          nearestClickable: this.findNearbyClickableElements(element, 100)\n        },\n        overlays: this.detectActiveOverlays(),\n        action: {\n          type: 'click',\n          selector: selectors.primary,\n          timestamp: new Date(timestamp).toISOString()\n        },\n        \n        // 6) Coordinates & modifiers\n        coordinates: {\n          clientX: event.clientX,\n          clientY: event.clientY,\n          pageX: event.pageX,\n          pageY: event.pageY,\n          offsetX: event.offsetX,\n          offsetY: event.offsetY\n        },\n        modifiers: {\n          ctrlKey: event.ctrlKey,\n          shiftKey: event.shiftKey,\n          altKey: event.altKey,\n          metaKey: event.metaKey\n        },\n\n        // 7) Legacy fields (for pipeline)\n        stateBefore,\n        url: window.location.href,\n        pageTitle: document.title,\n        viewport: this.getViewportInfo()\n      };\n\n      // 🔍 LOG: Show what data we're collecting\n      console.log('🎯 CLICK DATA COLLECTED:', {\n        type: interactionData.type,\n        timestamp: new Date(interactionData.timestamp).toISOString(),\n        element: {\n          tag: interactionData.element?.tagName,\n          text: interactionData.element?.text?.substring(0, 50) + '...',\n          selector: interactionData.selectors?.primary,\n          isInteractive: interactionData.element?.isInteractive,\n          percentVisible: interactionData.element?.percentVisible,\n          attributeCount: Object.keys(interactionData.element?.attributes || {}).length\n        },\n        selectors: {\n          primary: interactionData.selectors?.primary,\n          alternativeCount: interactionData.selectors?.alternatives?.length,\n          topReliability: interactionData.selectors?.selectorReliability?.[interactionData.selectors.primary],\n          xpath: interactionData.selectors?.xpath?.substring(0, 50) + '...',\n          cssPath: interactionData.selectors?.cssPath?.substring(0, 50) + '...'\n        },\n        visual: {\n          viewport: interactionData.visual?.viewport,\n          isInViewport: interactionData.visual?.isInViewport,\n          percentVisible: interactionData.visual?.percentVisible,\n          hasScreenshot: !!interactionData.visual?.screenshot\n        },\n        interaction: {\n          coordinates: !!interactionData.interaction?.coordinates,\n          modifiers: !!interactionData.interaction?.modifiers,\n          timestamp: interactionData.interaction?.timestamp,\n          sessionTime: interactionData.interaction?.sessionTime,\n          sequence: interactionData.interaction?.sequence\n        },\n        state: {\n          hasBefore: !!interactionData.state?.before,\n          hasAfter: !!interactionData.state?.after,\n          hasChanges: !!interactionData.state?.changes\n        },\n        context: {\n          parentCount: interactionData.context?.parentElements?.length || 0,\n          siblingCount: interactionData.context?.siblings?.length || 0,\n          nearbyElementCount: interactionData.context?.nearbyElements?.length || 0,\n          hasPageStructure: !!interactionData.context?.pageStructure\n        },\n        enhancedFields: {\n          hasMetadata: !!interactionData.metadata,\n          hasPageContext: !!interactionData.pageContext,\n          hasElementDetails: !!interactionData.elementDetails,\n          hasContextData: !!interactionData.contextData,\n          hasOverlays: !!interactionData.overlays,\n          hasAction: !!interactionData.action,\n          overlayCount: interactionData.overlays?.length || 0\n        }\n      });\n\n      // Wait for screenshot and link to visual context\n      const screenshot = await screenshotPromise;\n      if (screenshot) {\n        interactionData.screenshotId = screenshot.id;\n        interactionData.visual.screenshot = screenshot.id;\n      }\n\n      // Capture state after a delay to see changes (reference model: 1000ms)\n      setTimeout(() => {\n        const stateAfter = this.capturePageState();\n        const stateChanges = this.detectStateChanges(stateBefore, stateAfter);\n        \n        // Update enhanced state structure\n        interactionData.state.after = stateAfter;\n        interactionData.state.changes = stateChanges;\n        \n        // Backward compatibility\n        interactionData.stateAfter = stateAfter;\n        interactionData.stateChanges = stateChanges;\n        \n        // Update the stored event\n        this.updateEvent(interactionData);\n        \n        console.log('Enhanced: State changes detected:', {\n          hasChanges: Object.keys(stateChanges).length > 0,\n          changeTypes: Object.keys(stateChanges),\n          urlChanged: !!stateChanges.urlChanged,\n          titleChanged: !!stateChanges.titleChanged,\n          scrollChanged: !!stateChanges.scrollChanged,\n          details: {\n            urlChange: stateChanges.urlChanged ? {\n              from: stateChanges.urlChanged.from?.substring(0, 50) + '...',\n              to: stateChanges.urlChanged.to?.substring(0, 50) + '...',\n              type: stateChanges.urlChanged.type\n            } : null,\n            titleChange: stateChanges.titleChanged ? {\n              from: stateChanges.titleChanged.from?.substring(0, 30) + '...',\n              to: stateChanges.titleChanged.to?.substring(0, 30) + '...'\n            } : null,\n            scrollChange: stateChanges.scrollChanged ? {\n              delta: stateChanges.scrollChanged.delta,\n              direction: stateChanges.scrollChanged.direction\n            } : null\n          }\n        });\n      }, 1000);\n\n      this.captureEvent(interactionData);\n      this.lastInteractionTime = timestamp;\n    }\n\n    async handleInput(event) {\n      if (!this.isTracking) return;\n      \n      const element = event.target;\n      \n      // Privacy protection - skip sensitive inputs\n      if (this.isSensitiveInput(element)) {\n        console.log('Unified: Skipping sensitive input');\n        return;\n      }\n      \n      const timestamp = Date.now();\n      \n      const interactionData = {\n        type: 'INPUT',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        selectors: this.generateMultipleSelectors(element),\n        element: this.analyzeElement(element),\n        \n        // Input details (sanitized)\n        inputType: element.type || 'text',\n        inputName: element.name || '',\n        placeholder: element.placeholder || '',\n        valueLength: element.value ? element.value.length : 0,\n        \n        url: window.location.href,\n        pageTitle: document.title\n      };\n\n      this.captureEvent(interactionData);\n    }\n\n    async handleFormSubmit(event) {\n      if (!this.isTracking) return;\n      \n      const form = event.target;\n      const timestamp = Date.now();\n      \n      // Capture screenshot of form submission\n      const screenshot = await this.captureScreenshot('form_submit', timestamp);\n      \n      const interactionData = {\n        type: 'FORM_SUBMIT',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        selectors: this.generateMultipleSelectors(form),\n        element: this.analyzeElement(form),\n        \n        // Form details (privacy-safe)\n        formAction: form.action || '',\n        formMethod: form.method || 'GET',\n        fieldCount: form.elements.length,\n        \n        screenshotId: screenshot?.id,\n        url: window.location.href,\n        pageTitle: document.title\n      };\n\n      this.captureEvent(interactionData);\n    }\n\n    handleScroll(event) {\n      if (!this.isTracking) return;\n      \n      // Skip scroll events to reduce noise (can be re-enabled if needed)\n      return;\n      \n      const timestamp = Date.now();\n      \n      const interactionData = {\n        type: 'SCROLL',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        scrollPosition: {\n          x: window.scrollX,\n          y: window.scrollY\n        },\n        \n        viewport: this.getViewportInfo(),\n        url: window.location.href\n      };\n\n      this.captureEvent(interactionData);\n    }\n\n    handleFocus(event) {\n      if (!this.isTracking) return;\n      \n      const element = event.target;\n      const timestamp = Date.now();\n      \n      const interactionData = {\n        type: 'FOCUS',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        selectors: this.generateMultipleSelectors(element),\n        element: this.analyzeElement(element),\n        \n        url: window.location.href\n      };\n\n      this.captureEvent(interactionData);\n    }\n\n    handleKeyPress(event) {\n      if (!this.isTracking) return;\n      \n      // Only capture significant key presses\n      const significantKeys = ['Enter', 'Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n      if (!significantKeys.includes(event.key) && !event.ctrlKey && !event.metaKey) {\n        return;\n      }\n      \n      const timestamp = Date.now();\n      \n      const interactionData = {\n        type: 'KEY_PRESS',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        key: event.key,\n        code: event.code,\n        modifiers: {\n          ctrlKey: event.ctrlKey,\n          shiftKey: event.shiftKey,\n          altKey: event.altKey,\n          metaKey: event.metaKey\n        },\n        \n        url: window.location.href\n      };\n\n      this.captureEvent(interactionData);\n    }\n\n    // Enhanced selector generation\n    generateMultipleSelectors(element) {\n      const selectors = {\n        primary: null,\n        alternatives: [],\n        xpath: null,\n        cssPath: null,\n        reliability: {}\n      };\n\n      // Priority 1: ID selector\n      if (element.id && typeof element.id === 'string' && element.id.trim()) {\n        const idSelector = `#${element.id}`;\n        selectors.primary = idSelector;\n        selectors.alternatives.push(idSelector);\n        selectors.reliability[idSelector] = 0.95;\n      }\n\n      // Priority 2: Data attributes (test-friendly)\n      const dataAttrs = ['data-testid', 'data-test', 'data-cy', 'data-qa', 'data-automation'];\n      for (const attr of dataAttrs) {\n        const value = element.getAttribute(attr);\n        if (value) {\n          const selector = `[${attr}=\"${value}\"]`;\n          if (!selectors.primary) selectors.primary = selector;\n          selectors.alternatives.push(selector);\n          selectors.reliability[selector] = 0.9;\n        }\n      }\n\n      // Priority 3: ARIA attributes\n      const ariaLabel = element.getAttribute('aria-label');\n      if (ariaLabel) {\n        const selector = `[aria-label=\"${ariaLabel}\"]`;\n        if (!selectors.primary) selectors.primary = selector;\n        selectors.alternatives.push(selector);\n        selectors.reliability[selector] = 0.85;\n      }\n\n      // Priority 4: Name attribute (for form elements)\n      if (element.name) {\n        const selector = `[name=\"${element.name}\"]`;\n        if (!selectors.primary) selectors.primary = selector;\n        selectors.alternatives.push(selector);\n        selectors.reliability[selector] = 0.8;\n      }\n\n      // Priority 5: Class-based selector (stable classes only)\n      if (element.className && typeof element.className === 'string') {\n        const classes = element.className.split(' ')\n          .filter(c => c.trim() && !this.isUnstableClass(c));\n        \n        if (classes.length > 0) {\n          const selector = '.' + classes.join('.');\n          if (!selectors.primary) selectors.primary = selector;\n          selectors.alternatives.push(selector);\n          selectors.reliability[selector] = 0.6;\n        }\n      }\n\n      // Priority 6: Tag + attributes combination\n      const tagSelector = this.buildTagSelector(element);\n      if (!selectors.primary) selectors.primary = tagSelector;\n      selectors.alternatives.push(tagSelector);\n      selectors.reliability[tagSelector] = 0.5;\n\n      // Generate XPath\n      selectors.xpath = this.generateXPath(element);\n      selectors.reliability[selectors.xpath] = 0.7;\n\n      // Generate CSS path\n      selectors.cssPath = this.generateCSSPath(element);\n      selectors.reliability[selectors.cssPath] = 0.4;\n\n      // Remove duplicates\n      selectors.alternatives = [...new Set(selectors.alternatives)];\n\n      return selectors;\n    }\n\n    isUnstableClass(className) {\n      const unstablePatterns = [\n        /^(active|hover|focus|selected|current)$/i,\n        /^(is-|has-)/i,\n        /\\d{4,}/, // Long numbers (likely generated)\n        /^[a-f0-9]{8,}$/i, // Hash-like strings\n        /^css-/i, // CSS-in-JS generated classes\n        /^sc-/i, // Styled-components\n        /^emotion-/i // Emotion CSS\n      ];\n      \n      return unstablePatterns.some(pattern => pattern.test(className));\n    }\n\n    buildTagSelector(element) {\n      let selector = element.tagName.toLowerCase();\n      \n      // Add type for input elements\n      if (element.type) {\n        selector += `[type=\"${element.type}\"]`;\n      }\n      \n      // Add role if present\n      if (element.getAttribute('role')) {\n        selector += `[role=\"${element.getAttribute('role')}\"]`;\n      }\n      \n      return selector;\n    }\n\n    generateXPath(element) {\n      if (element.id) {\n        return `//*[@id=\"${element.id}\"]`;\n      }\n      \n      const parts = [];\n      while (element && element.nodeType === Node.ELEMENT_NODE) {\n        let index = 0;\n        let sibling = element.previousSibling;\n        \n        while (sibling) {\n          if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === element.tagName) {\n            index++;\n          }\n          sibling = sibling.previousSibling;\n        }\n        \n        const tagName = element.tagName.toLowerCase();\n        const part = index > 0 ? `${tagName}[${index + 1}]` : tagName;\n        parts.unshift(part);\n        \n        element = element.parentElement;\n      }\n      \n      return parts.length ? '/' + parts.join('/') : null;\n    }\n\n    generateCSSPath(element) {\n      const names = [];\n      while (element.parentNode) {\n        if (element.id) {\n          names.unshift('#' + element.id);\n          break;\n        } else {\n          let tagName = element.nodeName.toLowerCase();\n          \n          if (element.className && typeof element.className === 'string') {\n            const stableClasses = element.className.split(' ')\n              .filter(c => c.trim() && !this.isUnstableClass(c));\n            if (stableClasses.length > 0) {\n              tagName += '.' + stableClasses.join('.');\n            }\n          }\n          \n          const siblings = Array.from(element.parentNode.children);\n          const sameTagSiblings = siblings.filter(sibling => \n            sibling.nodeName === element.nodeName\n          );\n          \n          if (sameTagSiblings.length > 1) {\n            const index = sameTagSiblings.indexOf(element) + 1;\n            tagName += `:nth-of-type(${index})`;\n          }\n          \n          names.unshift(tagName);\n          element = element.parentNode;\n        }\n      }\n      return names.join(' > ');\n    }\n\n    // Enhanced selector generation with priority-based multi-selector strategy\n    generateEnhancedSelectors(element) {\n      const selectors = {\n        primary: null,\n        alternatives: [],\n        xpath: null,\n        cssPath: null,\n        selectorReliability: {}\n      };\n\n      // Priority 1: ID selector (highest reliability)\n      if (element.id && typeof element.id === 'string' && element.id.trim()) {\n        const idSelector = `#${CSS.escape(element.id)}`;\n        selectors.primary = idSelector;\n        selectors.alternatives.push(idSelector);\n        selectors.selectorReliability[idSelector] = this.testSelectorReliability(idSelector);\n      }\n\n      // Priority 2: Data attributes (test-friendly, high reliability)\n      const dataAttrs = ['data-testid', 'data-test', 'data-cy', 'data-qa', 'data-automation'];\n      for (const attr of dataAttrs) {\n        const value = element.getAttribute(attr);\n        if (value && value.trim()) {\n          const selector = `[${attr}=\"${CSS.escape(value)}\"]`;\n          if (!selectors.primary) selectors.primary = selector;\n          selectors.alternatives.push(selector);\n          selectors.selectorReliability[selector] = this.testSelectorReliability(selector);\n        }\n      }\n\n      // Priority 3: ARIA attributes (accessibility-based, good reliability)\n      const ariaLabel = element.getAttribute('aria-label');\n      if (ariaLabel && ariaLabel.trim()) {\n        const selector = `[aria-label=\"${CSS.escape(ariaLabel)}\"]`;\n        if (!selectors.primary) selectors.primary = selector;\n        selectors.alternatives.push(selector);\n        selectors.selectorReliability[selector] = this.testSelectorReliability(selector);\n      }\n\n      // Priority 4: Name attribute (for form elements)\n      const name = element.getAttribute('name');\n      if (name && name.trim()) {\n        const selector = `[name=\"${CSS.escape(name)}\"]`;\n        if (!selectors.primary) selectors.primary = selector;\n        selectors.alternatives.push(selector);\n        selectors.selectorReliability[selector] = this.testSelectorReliability(selector);\n      }\n\n      // Priority 5: Role + text combination (semantic, medium reliability)\n      const role = element.getAttribute('role');\n      const text = this.getElementText(element);\n      if (role && text && text.length < 50) {\n        // Use contains selector for partial text match\n        const selector = `[role=\"${role}\"]:contains(\"${CSS.escape(text.substring(0, 30))}\")`;\n        selectors.alternatives.push(selector);\n        // Note: :contains is not standard CSS, so lower reliability\n        selectors.selectorReliability[selector] = 0.6;\n      }\n\n      // Priority 6: Class-based selector (stable classes only)\n      if (element.className && typeof element.className === 'string') {\n        const stableClasses = element.className.split(' ')\n          .filter(c => c.trim() && !this.isUnstableClass(c))\n          .slice(0, 3); // Limit to prevent overly complex selectors\n        \n        if (stableClasses.length > 0) {\n          const selector = '.' + stableClasses.map(c => CSS.escape(c)).join('.');\n          if (!selectors.primary) selectors.primary = selector;\n          selectors.alternatives.push(selector);\n          selectors.selectorReliability[selector] = this.testSelectorReliability(selector);\n        }\n      }\n\n      // Priority 7: Tag + attributes combination (fallback)\n      const tagSelector = this.buildEnhancedTagSelector(element);\n      if (!selectors.primary) selectors.primary = tagSelector;\n      selectors.alternatives.push(tagSelector);\n      selectors.selectorReliability[tagSelector] = this.testSelectorReliability(tagSelector);\n\n      // Generate XPath (robust fallback)\n      selectors.xpath = this.generateXPath(element);\n      selectors.selectorReliability[selectors.xpath] = 0.7;\n\n      // Generate full CSS path (last resort)\n      selectors.cssPath = this.generateFullCSSPath(element);\n      selectors.selectorReliability[selectors.cssPath] = 0.4;\n\n      // Remove duplicates and sort by reliability\n      selectors.alternatives = [...new Set(selectors.alternatives)]\n        .sort((a, b) => (selectors.selectorReliability[b] || 0) - (selectors.selectorReliability[a] || 0))\n        .slice(0, 5); // Keep top 5 alternatives\n\n      console.log('Enhanced selectors generated:', {\n        primary: selectors.primary,\n        alternativeCount: selectors.alternatives.length,\n        topReliability: selectors.selectorReliability[selectors.primary],\n        alternatives: selectors.alternatives.map(s => ({\n          selector: s.substring(0, 50) + '...',\n          reliability: selectors.selectorReliability[s]\n        }))\n      });\n\n      return selectors;\n    }\n\n    buildEnhancedTagSelector(element) {\n      let selector = element.tagName.toLowerCase();\n      \n      // Add type for input elements\n      if (element.type) {\n        selector += `[type=\"${CSS.escape(element.type)}\"]`;\n      }\n      \n      // Add role if present\n      const role = element.getAttribute('role');\n      if (role) {\n        selector += `[role=\"${CSS.escape(role)}\"]`;\n      }\n\n      // Add href for links (first 50 chars to avoid overly long selectors)\n      if (element.tagName.toLowerCase() === 'a' && element.href) {\n        const href = element.getAttribute('href');\n        if (href && href.length < 100) {\n          selector += `[href=\"${CSS.escape(href)}\"]`;\n        }\n      }\n\n      // Add value for inputs (but mask sensitive inputs)\n      if (element.tagName.toLowerCase() === 'input' && element.value && !this.isSensitiveInput(element)) {\n        const value = element.value.substring(0, 20); // Limit length\n        selector += `[value=\"${CSS.escape(value)}\"]`;\n      }\n      \n      return selector;\n    }\n\n    generateFullCSSPath(element) {\n      const names = [];\n      let current = element;\n      \n      while (current.parentNode && current !== document.body) {\n        if (current.id) {\n          names.unshift('#' + CSS.escape(current.id));\n          break;\n        } else {\n          let tagName = current.nodeName.toLowerCase();\n          \n          if (current.className && typeof current.className === 'string') {\n            const stableClasses = current.className.split(' ')\n              .filter(c => c.trim() && !this.isUnstableClass(c))\n              .slice(0, 2); // Limit to prevent complexity\n            if (stableClasses.length > 0) {\n              tagName += '.' + stableClasses.map(c => CSS.escape(c)).join('.');\n            }\n          }\n          \n          const siblings = Array.from(current.parentNode.children);\n          const sameTagSiblings = siblings.filter(sibling => \n            sibling.nodeName === current.nodeName\n          );\n          \n          if (sameTagSiblings.length > 1) {\n            const index = sameTagSiblings.indexOf(current) + 1;\n            tagName += `:nth-of-type(${index})`;\n          }\n          \n          names.unshift(tagName);\n          current = current.parentNode;\n        }\n      }\n      return names.join(' > ');\n    }\n\n    // DOM context capture\n    captureDOMContext(element) {\n      const context = {\n        parents: [],\n        siblings: [],\n        children: [],\n        nearbyElements: []\n      };\n\n      // Capture parent hierarchy (up to 5 levels)\n      let parent = element.parentElement;\n      let depth = 0;\n      while (parent && depth < 5) {\n        context.parents.push({\n          tagName: parent.tagName.toLowerCase(),\n          id: parent.id || null,\n          className: this.getStableClasses(parent),\n          role: parent.getAttribute('role'),\n          selector: this.generateMultipleSelectors(parent).primary\n        });\n        parent = parent.parentElement;\n        depth++;\n      }\n\n      // Capture siblings\n      if (element.parentElement) {\n        const siblings = Array.from(element.parentElement.children);\n        const elementIndex = siblings.indexOf(element);\n        \n        for (let i = Math.max(0, elementIndex - 2); i <= Math.min(siblings.length - 1, elementIndex + 2); i++) {\n          if (i !== elementIndex) {\n            const sibling = siblings[i];\n            context.siblings.push({\n              position: i < elementIndex ? 'before' : 'after',\n              distance: Math.abs(i - elementIndex),\n              tagName: sibling.tagName.toLowerCase(),\n              text: this.getElementText(sibling),\n              selector: this.generateMultipleSelectors(sibling).primary\n            });\n          }\n        }\n      }\n\n      // Capture nearby interactive elements\n      context.nearbyElements = this.findNearbyInteractiveElements(element);\n\n      return context;\n    }\n\n    // Enhanced DOM context capture matching reference model (Group 4: Context)\n    captureEnhancedDOMContext(element) {\n      const context = {\n        parentElements: [],\n        siblings: [],\n        nearbyElements: [],\n        pageStructure: this.analyzePageStructure()\n      };\n\n      // Capture parent hierarchy (up to 5 levels) with enhanced data\n      let parent = element.parentElement;\n      let depth = 0;\n      while (parent && depth < 5) {\n        context.parentElements.push({\n          tagName: parent.tagName.toLowerCase(),\n          id: parent.id || null,\n          className: this.getStableClasses(parent),\n          role: parent.getAttribute('role'),\n          selector: this.generateEnhancedSelectors(parent).primary,\n          text: this.getElementTextEnhanced(parent).substring(0, 50),\n          level: depth + 1\n        });\n        parent = parent.parentElement;\n        depth++;\n      }\n\n      // Capture siblings with enhanced data\n      if (element.parentElement) {\n        const siblings = Array.from(element.parentElement.children);\n        const elementIndex = siblings.indexOf(element);\n        \n        // Get 2 siblings before and after (reference model pattern)\n        for (let i = Math.max(0, elementIndex - 2); i <= Math.min(siblings.length - 1, elementIndex + 2); i++) {\n          if (i !== elementIndex) {\n            const sibling = siblings[i];\n            context.siblings.push({\n              position: i < elementIndex ? 'before' : 'after',\n              distance: Math.abs(i - elementIndex),\n              tagName: sibling.tagName.toLowerCase(),\n              text: this.getElementTextEnhanced(sibling).substring(0, 50),\n              selector: this.generateEnhancedSelectors(sibling).primary,\n              isInteractive: this.isInteractiveElement(sibling),\n              boundingBox: this.getBoundingBox(sibling)\n            });\n          }\n        }\n      }\n\n      // Capture nearby clickable elements within 100px radius (reference model spec)\n      context.nearbyElements = this.findNearbyClickableElementsEnhanced(element, 100);\n\n      return context;\n    }\n\n    // Enhanced nearby elements detection matching reference model\n    findNearbyClickableElementsEnhanced(targetElement, radius = 100) {\n      const nearby = [];\n      const targetRect = targetElement.getBoundingClientRect();\n      const targetCenter = {\n        x: targetRect.left + targetRect.width / 2,\n        y: targetRect.top + targetRect.height / 2\n      };\n\n      const interactiveSelectors = 'a, button, input, select, textarea, [role=\"button\"], [onclick], [data-clickable], [tabindex]:not([tabindex=\"-1\"])';\n      const candidates = document.querySelectorAll(interactiveSelectors);\n\n      candidates.forEach(element => {\n        if (element === targetElement) return;\n        \n        const rect = element.getBoundingClientRect();\n        if (rect.width === 0 || rect.height === 0) return;\n        \n        const center = {\n          x: rect.left + rect.width / 2,\n          y: rect.top + rect.height / 2\n        };\n\n        const distance = Math.sqrt(\n          Math.pow(center.x - targetCenter.x, 2) +\n          Math.pow(center.y - targetCenter.y, 2)\n        );\n\n        if (distance <= radius) {\n          nearby.push({\n            selector: this.generateEnhancedSelectors(element).primary,\n            tagName: element.tagName.toLowerCase(),\n            text: this.getElementTextEnhanced(element).substring(0, 30),\n            distance: Math.round(distance),\n            direction: this.getRelativeDirection(targetCenter, center),\n            isVisible: this.isElementVisible(element),\n            isInteractive: this.isInteractiveElement(element)\n          });\n        }\n      });\n\n      // Sort by distance and return closest 10 (reference model spec)\n      return nearby.sort((a, b) => a.distance - b.distance).slice(0, 10);\n    }\n\n    findNearbyInteractiveElements(targetElement, radius = 150) {\n      const nearby = [];\n      const targetRect = targetElement.getBoundingClientRect();\n      const targetCenter = {\n        x: targetRect.left + targetRect.width / 2,\n        y: targetRect.top + targetRect.height / 2\n      };\n\n      const interactiveSelectors = 'a, button, input, select, textarea, [role=\"button\"], [onclick], [tabindex]';\n      const candidates = document.querySelectorAll(interactiveSelectors);\n\n      candidates.forEach(element => {\n        if (element === targetElement) return;\n        \n        const rect = element.getBoundingClientRect();\n        if (rect.width === 0 || rect.height === 0) return;\n        \n        const center = {\n          x: rect.left + rect.width / 2,\n          y: rect.top + rect.height / 2\n        };\n\n        const distance = Math.sqrt(\n          Math.pow(center.x - targetCenter.x, 2) +\n          Math.pow(center.y - targetCenter.y, 2)\n        );\n\n        if (distance <= radius) {\n          nearby.push({\n            selector: this.generateMultipleSelectors(element).primary,\n            tagName: element.tagName.toLowerCase(),\n            text: this.getElementText(element),\n            distance: Math.round(distance),\n            direction: this.getRelativeDirection(targetCenter, center),\n            isVisible: this.isElementVisible(element)\n          });\n        }\n      });\n\n      return nearby.sort((a, b) => a.distance - b.distance).slice(0, 8);\n    }\n\n    // Element analysis\n    analyzeElement(element) {\n      const computed = window.getComputedStyle(element);\n      \n      return {\n        tagName: element.tagName.toLowerCase(),\n        text: this.getElementText(element),\n        value: this.isSensitiveInput(element) ? '[PROTECTED]' : (element.value || null),\n        attributes: this.getRelevantAttributes(element),\n        \n        // Visual properties\n        boundingBox: this.getBoundingBox(element),\n        isVisible: this.isElementVisible(element),\n        isInViewport: this.isElementInViewport(element),\n        \n        // Computed styles (relevant ones)\n        styles: {\n          display: computed.display,\n          visibility: computed.visibility,\n          position: computed.position,\n          zIndex: computed.zIndex,\n          cursor: computed.cursor,\n          backgroundColor: computed.backgroundColor,\n          color: computed.color\n        },\n        \n        // Interaction properties\n        isInteractive: this.isInteractiveElement(element),\n        role: element.getAttribute('role') || this.inferElementRole(element),\n        tabIndex: element.tabIndex\n      };\n    }\n\n    // Enhanced element analysis matching reference model (Group 3: Element)\n    analyzeElementEnhanced(element) {\n      const computed = window.getComputedStyle(element);\n      \n      return {\n        // Basic element properties\n        tagName: element.tagName.toLowerCase(),\n        text: this.getElementTextEnhanced(element),\n        value: this.isSensitiveInput(element) ? '[PROTECTED]' : (element.value || null),\n        attributes: this.getAllElementAttributes(element),\n        \n        // Visual and positioning\n        boundingBox: this.getBoundingBox(element),\n        isVisible: this.isElementVisible(element),\n        isInViewport: this.isElementInViewport(element),\n        percentVisible: this.getElementVisibility(element),\n        \n        // Comprehensive computed styles (matching reference model)\n        computedStyles: {\n          display: computed.display,\n          visibility: computed.visibility,\n          position: computed.position,\n          zIndex: computed.zIndex,\n          width: computed.width,\n          height: computed.height,\n          padding: computed.padding,\n          margin: computed.margin,\n          backgroundColor: computed.backgroundColor,\n          color: computed.color,\n          fontSize: computed.fontSize,\n          cursor: computed.cursor,\n          pointerEvents: computed.pointerEvents,\n          opacity: computed.opacity,\n          transform: computed.transform,\n          transition: computed.transition\n        },\n        \n        // Interaction and accessibility\n        isInteractive: this.isInteractiveElement(element),\n        role: element.getAttribute('role') || this.inferElementRole(element),\n        tabIndex: element.tabIndex,\n        \n        // Additional properties from reference model\n        hasClickHandler: !!(element.onclick || element.getAttribute('onclick')),\n        ariaLabel: element.getAttribute('aria-label'),\n        title: element.title,\n        alt: element.alt,\n        placeholder: element.placeholder\n      };\n    }\n\n    // Enhanced text extraction with fallbacks (matching reference model)\n    getElementTextEnhanced(element) {\n      if (!element) return '';\n      \n      // Get direct text content, not including children\n      const textNodes = [];\n      for (let node of element.childNodes) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          textNodes.push(node.textContent.trim());\n        }\n      }\n      \n      let text = textNodes.join(' ').trim();\n      \n      // Fallback to full text content if no direct text\n      if (!text) {\n        text = element.textContent?.trim() || '';\n      }\n      \n      // Also check common attributes (matching reference model priority)\n      if (!text) {\n        text = element.value || \n               element.placeholder || \n               element.alt || \n               element.title || \n               element.getAttribute('aria-label') || '';\n      }\n      \n      // Limit length to prevent huge payloads\n      return text.length > 100 ? text.substring(0, 100) + '...' : text;\n    }\n\n    // Get all element attributes (comprehensive)\n    getAllElementAttributes(element) {\n      const attrs = {};\n      for (let attr of element.attributes) {\n        attrs[attr.name] = attr.value;\n      }\n      return attrs;\n    }\n\n    // Enhanced element visibility calculation (matching reference model)\n    getElementVisibility(element) {\n      const rect = element.getBoundingClientRect();\n      const viewportHeight = window.innerHeight;\n      const viewportWidth = window.innerWidth;\n      \n      const visibleHeight = Math.min(rect.bottom, viewportHeight) - Math.max(rect.top, 0);\n      const visibleWidth = Math.min(rect.right, viewportWidth) - Math.max(rect.left, 0);\n      \n      const visibleArea = Math.max(0, visibleHeight) * Math.max(0, visibleWidth);\n      const totalArea = rect.height * rect.width;\n      \n      return totalArea > 0 ? Math.round((visibleArea / totalArea) * 100) : 0;\n    }\n\n    getRelevantAttributes(element) {\n      const relevantAttrs = [\n        'id', 'class', 'name', 'type', 'role', 'aria-label', 'aria-describedby',\n        'data-testid', 'data-test', 'data-cy', 'data-qa', 'href', 'src', 'alt', 'title'\n      ];\n      \n      const attrs = {};\n      relevantAttrs.forEach(attr => {\n        const value = element.getAttribute(attr);\n        if (value !== null) {\n          attrs[attr] = value;\n        }\n      });\n      \n      return attrs;\n    }\n\n    // Privacy protection - Comprehensive PII detection\n    isSensitiveInput(element) {\n      if (!element) return false;\n      \n      // Check input type\n      if (element.type && ['password', 'hidden'].includes(element.type.toLowerCase())) {\n        return true;\n      }\n      \n      // Check against sensitive selectors\n      const matchesSensitiveSelector = this.sensitiveSelectors.some(selector => {\n        try {\n          return element.matches(selector);\n        } catch (e) {\n          return false;\n        }\n      });\n      \n      if (matchesSensitiveSelector) return true;\n      \n      // Check element properties for PII indicators\n      const sensitivePatterns = [\n        // Names and personal info\n        /\\b(first[-_\\s]*name|last[-_\\s]*name|full[-_\\s]*name|given[-_\\s]*name|surname|family[-_\\s]*name)\\b/i,\n        \n        // Contact information\n        /\\b(email|e[-_\\s]*mail|phone|mobile|telephone|fax)\\b/i,\n        \n        // Address information\n        /\\b(address|street|city|state|province|zip|postal|country|region)\\b/i,\n        \n        // Financial information\n        /\\b(credit[-_\\s]*card|debit[-_\\s]*card|card[-_\\s]*number|cvv|cvc|security[-_\\s]*code|expiry|expiration|routing|account[-_\\s]*number|iban|swift)\\b/i,\n        \n        // Identification\n        /\\b(ssn|social[-_\\s]*security|passport|license|id[-_\\s]*number|tax[-_\\s]*id)\\b/i,\n        \n        // Personal details\n        /\\b(birth[-_\\s]*date|date[-_\\s]*of[-_\\s]*birth|dob|age|gender|nationality)\\b/i,\n        \n        // Security\n        /\\b(password|pin|secret|security[-_\\s]*question|mother[-_\\s]*maiden)\\b/i\n      ];\n      \n      // Check all element attributes and properties\n      const checkText = [\n        element.name,\n        element.id,\n        element.className,\n        element.placeholder,\n        element.title,\n        element.getAttribute('aria-label'),\n        element.getAttribute('data-testid'),\n        element.getAttribute('autocomplete')\n      ].filter(Boolean).join(' ').toLowerCase();\n      \n      if (sensitivePatterns.some(pattern => pattern.test(checkText))) {\n        return true;\n      }\n      \n      // Check parent labels for sensitive content\n      const label = element.closest('label') || document.querySelector(`label[for=\"${element.id}\"]`);\n      if (label) {\n        const labelText = label.textContent.toLowerCase();\n        if (sensitivePatterns.some(pattern => pattern.test(labelText))) {\n          return true;\n        }\n      }\n      \n      // Check for credit card number patterns in value (basic format check)\n      if (element.value && element.value.length > 0) {\n        // Credit card pattern (4 groups of 4 digits or similar)\n        const ccPattern = /^\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{3,4}$/;\n        const ssnPattern = /^\\d{3}[-\\s]?\\d{2}[-\\s]?\\d{4}$/;\n        const phonePattern = /^[\\+]?[1-9][\\d]{0,2}[\\s-]?\\(?[\\d]{3}\\)?[\\s-]?[\\d]{3}[\\s-]?[\\d]{4}$/;\n        \n        if (ccPattern.test(element.value.replace(/\\s/g, '')) || \n            ssnPattern.test(element.value) || \n            phonePattern.test(element.value)) {\n          return true;\n        }\n      }\n      \n      return false;\n    }\n\n    // Sanitize data to remove any PII that might have been captured\n    sanitizeData(data) {\n      if (!data || typeof data !== 'object') return data;\n      \n      const sanitized = JSON.parse(JSON.stringify(data)); // Deep clone\n      \n      // PII patterns to redact\n      const piiPatterns = [\n        // Credit card numbers (various formats)\n        { pattern: /\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{3,4}\\b/g, replacement: '[CREDIT_CARD_REDACTED]' },\n        \n        // Social Security Numbers\n        { pattern: /\\b\\d{3}[-\\s]?\\d{2}[-\\s]?\\d{4}\\b/g, replacement: '[SSN_REDACTED]' },\n        \n        // Phone numbers\n        { pattern: /\\b[\\+]?[1-9][\\d]{0,2}[\\s-]?\\(?[\\d]{3}\\)?[\\s-]?[\\d]{3}[\\s-]?[\\d]{4}\\b/g, replacement: '[PHONE_REDACTED]' },\n        \n        // Email addresses\n        { pattern: /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g, replacement: '[EMAIL_REDACTED]' },\n        \n        // Zip codes (US format)\n        { pattern: /\\b\\d{5}(-\\d{4})?\\b/g, replacement: '[ZIP_REDACTED]' },\n        \n        // Generic patterns for names in common formats\n        { pattern: /\\b[A-Z][a-z]+ [A-Z][a-z]+\\b/g, replacement: '[NAME_REDACTED]' }\n      ];\n      \n      // Recursively sanitize object\n      const sanitizeValue = (value) => {\n        if (typeof value === 'string') {\n          let sanitizedValue = value;\n          piiPatterns.forEach(({ pattern, replacement }) => {\n            sanitizedValue = sanitizedValue.replace(pattern, replacement);\n          });\n          return sanitizedValue;\n        } else if (Array.isArray(value)) {\n          return value.map(sanitizeValue);\n        } else if (value && typeof value === 'object') {\n          const sanitizedObj = {};\n          for (const [key, val] of Object.entries(value)) {\n            // Skip sensitive keys entirely\n            if (this.isSensitiveKey(key)) {\n              sanitizedObj[key] = '[PII_REDACTED]';\n            } else {\n              sanitizedObj[key] = sanitizeValue(val);\n            }\n          }\n          return sanitizedObj;\n        }\n        return value;\n      };\n      \n      return sanitizeValue(sanitized);\n    }\n\n    // Check if a key name suggests it contains PII\n    isSensitiveKey(key) {\n      if (!key || typeof key !== 'string') return false;\n      \n      const sensitiveKeyPatterns = [\n        /password/i,\n        /email/i,\n        /phone/i,\n        /address/i,\n        /name/i,\n        /credit/i,\n        /card/i,\n        /ssn/i,\n        /social/i,\n        /birth/i,\n        /dob/i,\n        /license/i,\n        /passport/i\n      ];\n      \n      return sensitiveKeyPatterns.some(pattern => pattern.test(key));\n    }\n\n    // Screenshot capture\n    async captureScreenshot(trigger, timestamp = Date.now()) {\n      if (!this.config.screenshotEnabled || this.screenshots.length >= this.config.maxScreenshots) {\n        return null;\n      }\n\n      try {\n        const screenshotData = {\n          trigger,\n          timestamp,\n          viewport: this.getViewportInfo(),\n          url: window.location.href,\n          quality: this.config.screenshotQuality\n        };\n\n        // Send to background script for actual capture\n        const response = await chrome.runtime.sendMessage({\n          action: 'CAPTURE_SCREENSHOT',\n          data: screenshotData\n        });\n\n        if (response && response.success) {\n          const screenshot = {\n            id: response.screenshotId,\n            trigger,\n            timestamp,\n            ...screenshotData\n          };\n          \n          this.screenshots.push(screenshot);\n          return screenshot;\n        }\n      } catch (error) {\n        console.error('Unified: Screenshot capture failed:', error);\n      }\n      \n      return null;\n    }\n\n    // Page structure analysis\n    analyzePageStructure() {\n      return {\n        hasNavigation: !!document.querySelector('nav, [role=\"navigation\"]'),\n        hasSearch: !!document.querySelector('input[type=\"search\"], [role=\"searchbox\"]'),\n        hasFilters: document.querySelectorAll('[class*=\"filter\"], [data-filter]').length > 0,\n        hasProductGrid: !!document.querySelector('[class*=\"grid\"], [class*=\"product\"], [data-products]'),\n        hasShoppingCart: !!document.querySelector('[class*=\"cart\"], [data-cart]'),\n        hasPagination: !!document.querySelector('[class*=\"page\"], [aria-label*=\"page\"]'),\n        \n        // Element counts\n        totalElements: document.querySelectorAll('*').length,\n        interactiveElements: document.querySelectorAll('button, a, input, select, textarea, [role=\"button\"]').length,\n        images: document.querySelectorAll('img').length,\n        forms: document.querySelectorAll('form').length,\n        \n        // Page type detection\n        pageType: this.detectPageType(),\n        \n        // Framework detection\n        framework: this.detectFramework()\n      };\n    }\n\n    detectPageType() {\n      const url = window.location.href.toLowerCase();\n      const title = document.title.toLowerCase();\n      const content = document.body.textContent.toLowerCase();\n      \n      if (url.includes('/cart') || title.includes('cart') || content.includes('shopping cart')) {\n        return 'cart';\n      }\n      if (url.includes('/checkout') || title.includes('checkout')) {\n        return 'checkout';\n      }\n      if (url.includes('/product') || url.includes('/item') || document.querySelector('[itemtype*=\"Product\"]')) {\n        return 'product';\n      }\n      if (url.includes('/search') || url.includes('?q=') || document.querySelector('[role=\"search\"]')) {\n        return 'search';\n      }\n      if (url.includes('/category') || url.includes('/browse')) {\n        return 'category';\n      }\n      \n      return 'other';\n    }\n\n    detectFramework() {\n      const frameworks = [];\n      \n      if (window.React || document.querySelector('[data-reactroot]')) {\n        frameworks.push('React');\n      }\n      if (window.Vue || document.querySelector('[data-v-]')) {\n        frameworks.push('Vue');\n      }\n      if (window.angular || document.querySelector('[ng-app], [data-ng-app]')) {\n        frameworks.push('Angular');\n      }\n      if (window.jQuery || window.$) {\n        frameworks.push('jQuery');\n      }\n      \n      return frameworks;\n    }\n\n    // Navigation handling\n    setupNavigationHandling() {\n      // URL change detection\n      let lastUrl = window.location.href;\n      \n      const checkUrlChange = () => {\n        if (this.isTracking && window.location.href !== lastUrl) {\n          this.handleNavigation(lastUrl, window.location.href);\n          lastUrl = window.location.href;\n        }\n      };\n      \n      // Check every second\n      this.navigationInterval = setInterval(checkUrlChange, 1000);\n      \n      // Also listen for popstate\n      this.popstateHandler = () => {\n        if (this.isTracking) {\n          setTimeout(checkUrlChange, 100);\n        }\n      };\n      window.addEventListener('popstate', this.popstateHandler);\n    }\n    \n    cleanupNavigationHandling() {\n      if (this.navigationInterval) {\n        clearInterval(this.navigationInterval);\n        this.navigationInterval = null;\n      }\n      \n      if (this.popstateHandler) {\n        window.removeEventListener('popstate', this.popstateHandler);\n        this.popstateHandler = null;\n      }\n    }\n\n    async handleNavigation(fromUrl, toUrl) {\n      const timestamp = Date.now();\n      \n      // Capture navigation screenshot burst\n      if (this.config.burstModeEnabled) {\n        this.startBurstMode('navigation');\n      }\n      \n      // Update page structure\n      setTimeout(() => {\n        this.pageStructure = this.analyzePageStructure();\n      }, 1000);\n      \n      const navigationData = {\n        type: 'NAVIGATION',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        fromUrl,\n        toUrl,\n        pageTitle: document.title,\n        \n        // Navigation type detection\n        navigationType: this.detectNavigationType(fromUrl, toUrl),\n        \n        // Page structure will be updated after delay\n        pageStructure: this.pageStructure\n      };\n\n      this.captureEvent(navigationData);\n    }\n\n    detectNavigationType(fromUrl, toUrl) {\n      if (fromUrl === toUrl) return 'refresh';\n      if (toUrl.includes('#')) return 'hash_change';\n      if (new URL(fromUrl).pathname === new URL(toUrl).pathname) return 'query_change';\n      return 'page_change';\n    }\n\n    startBurstMode(trigger) {\n      const burstCount = trigger === 'navigation' ? 3 : 5;\n      const interval = 500; // 500ms between shots\n      \n      for (let i = 0; i < burstCount; i++) {\n        setTimeout(() => {\n          if (this.isTracking) {\n            this.captureScreenshot(`burst_${trigger}_${i + 1}`);\n          }\n        }, i * interval);\n      }\n    }\n\n    // Utility methods\n    captureEvent(eventData) {\n      if (this.events.length >= this.config.maxEvents) {\n        console.warn('Unified: Max events reached, dropping oldest');\n        this.events.shift();\n      }\n      \n      // Sanitize event data to remove any PII before storing\n      const sanitizedEventData = this.sanitizeData(eventData);\n      \n      this.events.push({\n        ...sanitizedEventData,\n        id: this.generateId(),\n        sessionId: this.sessionId\n      });\n      \n      // Task progress is tracked naturally through user interactions\n      \n      // Send to background script for processing\n      this.sendEventToBackground(eventData);\n      \n      // Save state\n      this.saveState();\n      \n      // Periodic cleanup to prevent memory issues\n      if (this.events.length > this.config.maxEvents / 2) {\n        this.performEventCleanup();\n      }\n    }\n    \n    performEventCleanup() {\n      const now = Date.now();\n      const maxAge = 30 * 60 * 1000; // 30 minutes\n      \n      // Remove very old events\n      this.events = this.events.filter(event => {\n        return (now - event.timestamp) < maxAge;\n      });\n      \n      // If still too many, keep only the most recent\n      if (this.events.length > this.config.maxEvents) {\n        this.events = this.events.slice(-this.config.maxEvents);\n      }\n    }\n\n    updateEvent(eventData) {\n      const index = this.events.findIndex(e => e.id === eventData.id);\n      if (index !== -1) {\n        this.events[index] = { ...this.events[index], ...eventData };\n        this.saveState();\n      }\n    }\n\n    async sendEventToBackground(eventData) {\n      try {\n        console.log('Unified: Sending event to background:', eventData.type);\n        const response = await chrome.runtime.sendMessage({\n          action: 'SEND_DATA',\n          data: eventData\n        });\n        console.log('Unified: Background response:', response);\n      } catch (error) {\n        console.error('Unified: Failed to send event to background:', error);\n        \n        // If background script is not ready, try to wake it up\n        if (error.message.includes('Could not establish connection')) {\n          console.log('Unified: Background script disconnected, attempting to reconnect...');\n          setTimeout(() => {\n            this.sendEventToBackground(eventData);\n          }, 1000);\n        }\n      }\n    }\n\n    async startBackendSession() {\n      try {\n        console.log('Unified: Starting backend session:', this.sessionId);\n        const response = await chrome.runtime.sendMessage({\n          action: 'START_BACKEND_SESSION',\n          sessionId: this.sessionId,\n          generatedTask: this.currentTask,\n          config: {\n            type: 'AUTOMATED',\n            url: window.location.href,\n            userAgent: navigator.userAgent,\n            timestamp: Date.now()\n          }\n        });\n        console.log('Unified: Backend session started:', response);\n      } catch (error) {\n        console.error('Unified: Failed to start backend session:', error);\n      }\n    }\n\n    async stopBackendSession() {\n      try {\n        console.log('Unified: Stopping backend session:', this.sessionId);\n        const response = await chrome.runtime.sendMessage({\n          action: 'STOP_BACKEND_SESSION',\n          sessionId: this.sessionId\n        });\n        console.log('Unified: Backend session stopped:', response);\n      } catch (error) {\n        console.error('Unified: Failed to stop backend session:', error);\n      }\n    }\n\n    // Page state capture\n    capturePageState() {\n      return {\n        url: window.location.href,\n        title: document.title,\n        scrollPosition: {\n          x: window.scrollX,\n          y: window.scrollY\n        },\n        viewport: this.getViewportInfo(),\n        activeElement: this.getActiveElementInfo(),\n        visibleElements: this.getVisibleElementsCount(),\n        timestamp: Date.now()\n      };\n    }\n\n    detectStateChanges(stateBefore, stateAfter) {\n      const changes = {};\n      \n      // Enhanced URL change detection (matching reference model)\n      if (stateBefore.url !== stateAfter.url) {\n        changes.urlChanged = {\n          from: stateBefore.url,\n          to: stateAfter.url,\n          type: this.detectNavigationType(stateBefore.url, stateAfter.url)\n        };\n        // Backward compatibility\n        changes.newUrl = stateAfter.url;\n      }\n      \n      // Enhanced title change detection  \n      if (stateBefore.title !== stateAfter.title) {\n        changes.titleChanged = {\n          from: stateBefore.title,\n          to: stateAfter.title\n        };\n        // Backward compatibility\n        changes.newTitle = stateAfter.title;\n      }\n      \n      // Enhanced scroll change detection (matching reference model)  \n      const scrollDiff = {\n        x: Math.abs(stateAfter.scrollPosition.x - stateBefore.scrollPosition.x),\n        y: Math.abs(stateAfter.scrollPosition.y - stateBefore.scrollPosition.y)\n      };\n      \n      if (scrollDiff.x > 10 || scrollDiff.y > 10) {\n        changes.scrollChanged = {\n          from: stateBefore.scrollPosition.y,\n          to: stateAfter.scrollPosition.y,\n          delta: stateAfter.scrollPosition.y - stateBefore.scrollPosition.y,\n          direction: stateAfter.scrollPosition.y > stateBefore.scrollPosition.y ? 'down' : 'up'\n        };\n        // Backward compatibility\n        changes.scrollDiff = scrollDiff;\n      }\n      \n      if (stateBefore.visibleElements !== stateAfter.visibleElements) {\n        changes.elementsChanged = true;\n        changes.elementDiff = stateAfter.visibleElements - stateBefore.visibleElements;\n      }\n      \n      return changes;\n    }\n\n    getActiveElementInfo() {\n      const activeElement = document.activeElement;\n      if (!activeElement || activeElement === document.body) {\n        return null;\n      }\n      \n      return {\n        tagName: activeElement.tagName.toLowerCase(),\n        id: activeElement.id || null,\n        className: activeElement.className || null,\n        selector: this.generateMultipleSelectors(activeElement).primary\n      };\n    }\n\n    getVisibleElementsCount() {\n      const elements = document.querySelectorAll('*');\n      let visibleCount = 0;\n      \n      for (const element of elements) {\n        if (this.isElementVisible(element)) {\n          visibleCount++;\n        }\n      }\n      \n      return visibleCount;\n    }\n\n    // Utility methods\n    getViewportInfo() {\n      return {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        scrollX: window.scrollX,\n        scrollY: window.scrollY,\n        devicePixelRatio: window.devicePixelRatio || 1\n      };\n    }\n\n    getBoundingBox(element) {\n      const rect = element.getBoundingClientRect();\n      return {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left\n      };\n    }\n\n    isElementVisible(element) {\n      if (!element) return false;\n      \n      const rect = element.getBoundingClientRect();\n      if (rect.width === 0 || rect.height === 0) return false;\n      \n      const style = window.getComputedStyle(element);\n      if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {\n        return false;\n      }\n      \n      return true;\n    }\n\n    isElementInViewport(element) {\n      const rect = element.getBoundingClientRect();\n      return (\n        rect.top >= 0 &&\n        rect.left >= 0 &&\n        rect.bottom <= window.innerHeight &&\n        rect.right <= window.innerWidth\n      );\n    }\n\n    isInteractiveElement(element) {\n      const interactiveTags = ['a', 'button', 'input', 'select', 'textarea'];\n      const interactiveRoles = ['button', 'link', 'menuitem', 'tab'];\n      \n      if (interactiveTags.includes(element.tagName.toLowerCase())) {\n        return true;\n      }\n      \n      const role = element.getAttribute('role');\n      if (role && interactiveRoles.includes(role.toLowerCase())) {\n        return true;\n      }\n      \n      if (element.hasAttribute('onclick') || element.hasAttribute('tabindex')) {\n        return true;\n      }\n      \n      return false;\n    }\n\n    inferElementRole(element) {\n      const tagName = element.tagName.toLowerCase();\n      \n      const roleMap = {\n        'a': 'link',\n        'button': 'button',\n        'input': 'textbox',\n        'select': 'combobox',\n        'textarea': 'textbox',\n        'img': 'image',\n        'nav': 'navigation',\n        'main': 'main',\n        'header': 'banner',\n        'footer': 'contentinfo',\n        'aside': 'complementary'\n      };\n      \n      return roleMap[tagName] || 'generic';\n    }\n\n    getElementText(element) {\n      if (!element) return '';\n      \n      // For input elements, get placeholder or value\n      if (element.tagName.toLowerCase() === 'input') {\n        return element.placeholder || element.value || '';\n      }\n      \n      // Get text content, but limit length\n      const text = element.textContent || element.innerText || '';\n      return text.trim().substring(0, 200);\n    }\n\n    getStableClasses(element) {\n      if (!element.className || typeof element.className !== 'string') {\n        return '';\n      }\n      \n      return element.className.split(' ')\n        .filter(c => c.trim() && !this.isUnstableClass(c))\n        .join(' ');\n    }\n\n    getRelativeDirection(center1, center2) {\n      const dx = center2.x - center1.x;\n      const dy = center2.y - center1.y;\n      \n      if (Math.abs(dx) > Math.abs(dy)) {\n        return dx > 0 ? 'right' : 'left';\n      } else {\n        return dy > 0 ? 'below' : 'above';\n      }\n    }\n\n    // State management\n    saveState() {\n      if (!this.sessionId) return;\n      \n      const state = {\n        sessionId: this.sessionId,\n        isTracking: this.isTracking,\n        startTime: this.startTime,\n        eventCount: this.events.length,\n        screenshotCount: this.screenshots.length,\n        currentTask: this.currentTask,\n        taskProgress: this.taskProgress,\n        lastSaved: Date.now()\n      };\n      \n      try {\n        localStorage.setItem('unified_codesight_state', JSON.stringify(state));\n      } catch (error) {\n        console.error('Unified: Failed to save state:', error);\n      }\n    }\n\n    restoreState() {\n      try {\n        const stateStr = localStorage.getItem('unified_codesight_state');\n        if (!stateStr) return;\n        \n        const state = JSON.parse(stateStr);\n        \n        // Only restore if recent (within 1 hour)\n        if (Date.now() - state.lastSaved < 60 * 60 * 1000) {\n          this.sessionId = state.sessionId;\n          this.isTracking = state.isTracking;\n          this.startTime = state.startTime;\n          this.currentTask = state.currentTask;\n          this.taskProgress = state.taskProgress || { currentStep: 0, completedSteps: [] };\n          \n          // Initialize arrays if not already initialized\n          if (!this.events) this.events = [];\n          if (!this.screenshots) this.screenshots = [];\n          \n          // Restore approximate counts (actual events are sent to backend)\n          this.restoredEventCount = state.eventCount || 0;\n          this.restoredScreenshotCount = state.screenshotCount || 0;\n          \n          if (this.isTracking) {\n            console.log('Unified: Restored tracking state for session:', this.sessionId);\n            \n            // Re-initialize tracking components after state restoration\n            this.bindEventListeners();\n            this.showTrackingIndicator();\n            \n            // Re-establish backend connection if needed\n            this.sendEventToBackground({\n              type: 'navigation_restored',\n              sessionId: this.sessionId,\n              url: window.location.href,\n              timestamp: Date.now()\n            });\n            \n            // Start periodic validation to ensure connection remains active\n            this.startPeriodicValidation();\n          }\n        }\n      } catch (error) {\n        console.error('Unified: Failed to restore state:', error);\n      }\n    }\n\n    clearState() {\n      try {\n        localStorage.removeItem('unified_codesight_state');\n      } catch (error) {\n        console.error('Unified: Failed to clear state:', error);\n      }\n    }\n\n    setupPeriodicStateSaving() {\n      // Save state every 2 seconds when tracking to handle navigation\n      this.stateSaveInterval = setInterval(() => {\n        if (this.isTracking) {\n          this.saveState();\n        }\n      }, 2000);\n    }\n\n    // Session data preparation\n    async prepareSessionData() {\n      const sessionData = {\n        sessionId: this.sessionId,\n        startTime: this.startTime,\n        endTime: Date.now(),\n        duration: Date.now() - this.startTime,\n        \n        // Event data\n        events: this.events,\n        eventCount: this.events.length,\n        \n        // Screenshot data\n        screenshots: this.screenshots,\n        screenshotCount: this.screenshots.length,\n        \n        // Page data\n        initialUrl: this.currentUrl,\n        finalUrl: window.location.href,\n        pageStructure: this.pageStructure,\n        \n        // Browser data\n        userAgent: navigator.userAgent,\n        viewport: this.getViewportInfo(),\n        \n        // Quality metrics\n        qualityScore: this.calculateQualityScore(),\n        completeness: this.calculateCompleteness()\n      };\n      \n      return sessionData;\n    }\n\n    calculateQualityScore() {\n      let score = 0;\n      \n      // Base score for having events\n      if (this.events.length > 0) score += 20;\n      \n      // Bonus for variety of event types\n      const eventTypes = new Set(this.events.map(e => e.type));\n      score += Math.min(eventTypes.size * 10, 30);\n      \n      // Bonus for screenshots\n      if (this.screenshots.length > 0) score += 20;\n      \n      // Bonus for session duration (sweet spot: 30s - 5min)\n      const duration = Date.now() - this.startTime;\n      const durationMinutes = duration / (1000 * 60);\n      if (durationMinutes >= 0.5 && durationMinutes <= 5) {\n        score += 20;\n      } else if (durationMinutes > 5) {\n        score += 10;\n      }\n      \n      // Bonus for interaction variety\n      const clickEvents = this.events.filter(e => e.type === 'CLICK').length;\n      const inputEvents = this.events.filter(e => e.type === 'INPUT').length;\n      const navEvents = this.events.filter(e => e.type === 'NAVIGATION').length;\n      \n      if (clickEvents > 0 && inputEvents > 0) score += 10;\n      if (navEvents > 0) score += 10;\n      \n      return Math.min(score, 100);\n    }\n\n    calculateCompleteness() {\n      let completeness = 0;\n      \n      // Check for essential data\n      if (this.events.length > 0) completeness += 25;\n      if (this.screenshots.length > 0) completeness += 25;\n      if (this.pageStructure) completeness += 25;\n      \n      // Check for interaction completeness\n      const hasClicks = this.events.some(e => e.type === 'CLICK');\n      const hasNavigation = this.events.some(e => e.type === 'NAVIGATION');\n      \n      if (hasClicks) completeness += 12.5;\n      if (hasNavigation) completeness += 12.5;\n      \n      return Math.min(completeness, 100);\n    }\n\n    // Data Quality Validation System\n    validateSessionData() {\n      const validation = {\n        isValid: true,\n        score: 100,\n        errors: [],\n        warnings: [],\n        suggestions: [],\n        metrics: {}\n      };\n\n      // Validate basic session data\n      this.validateBasicSessionData(validation);\n      \n      // Validate events\n      this.validateEvents(validation);\n      \n      // Validate screenshots\n      this.validateScreenshots(validation);\n      \n      // Validate interaction patterns\n      this.validateInteractionPatterns(validation);\n      \n      // Validate data completeness\n      this.validateDataCompleteness(validation);\n      \n      // Calculate final validation score\n      validation.score = Math.max(0, validation.score - (validation.errors.length * 10) - (validation.warnings.length * 5));\n      validation.isValid = validation.score >= 60 && validation.errors.length === 0;\n      \n      return validation;\n    }\n\n    validateBasicSessionData(validation) {\n      // Check session ID\n      if (!this.sessionId) {\n        validation.errors.push('Missing session ID');\n        validation.score -= 20;\n      }\n\n      // Check session duration\n      const duration = Date.now() - this.startTime;\n      if (duration < 10000) { // Less than 10 seconds\n        validation.warnings.push('Session duration is very short (< 10s)');\n        validation.suggestions.push('Consider longer interaction sessions for better training data');\n      } else if (duration > 30 * 60 * 1000) { // More than 30 minutes\n        validation.warnings.push('Session duration is very long (> 30min)');\n        validation.suggestions.push('Consider breaking long sessions into smaller chunks');\n      }\n\n      validation.metrics.sessionDuration = duration;\n      validation.metrics.sessionDurationMinutes = Math.round(duration / 60000);\n    }\n\n    validateEvents(validation) {\n      if (this.events.length === 0) {\n        validation.errors.push('No interaction events captured');\n        validation.score -= 30;\n        return;\n      }\n\n      let validEvents = 0;\n      let invalidEvents = 0;\n      const eventTypes = new Set();\n      const missingSelectors = [];\n      const missingTimestamps = [];\n\n      this.events.forEach((event, index) => {\n        let eventValid = true;\n\n        // Check required fields\n        if (!event.type) {\n          validation.errors.push(`Event ${index}: Missing event type`);\n          eventValid = false;\n        } else {\n          eventTypes.add(event.type);\n        }\n\n        if (!event.timestamp) {\n          validation.errors.push(`Event ${index}: Missing timestamp`);\n          missingTimestamps.push(index);\n          eventValid = false;\n        }\n\n        // Validate selectors for click events\n        if (event.type === 'CLICK') {\n          if (!event.selectors || !event.selectors.primary) {\n            validation.warnings.push(`Click event ${index}: Missing primary selector`);\n            missingSelectors.push(index);\n          } else {\n            // Test selector reliability\n            const reliability = this.testSelectorReliability(event.selectors.primary);\n            if (reliability < 0.5) {\n              validation.warnings.push(`Click event ${index}: Low selector reliability (${Math.round(reliability * 100)}%)`);\n            }\n          }\n\n          // Check for coordinates\n          if (!event.coordinates) {\n            validation.warnings.push(`Click event ${index}: Missing click coordinates`);\n          }\n        }\n\n        // Validate URL\n        if (!event.url) {\n          validation.warnings.push(`Event ${index}: Missing URL`);\n        }\n\n        if (eventValid) {\n          validEvents++;\n        } else {\n          invalidEvents++;\n        }\n      });\n\n      // Event diversity check\n      if (eventTypes.size < 2) {\n        validation.warnings.push('Low event type diversity - consider capturing more interaction types');\n        validation.suggestions.push('Try to include clicks, inputs, navigation, and scrolling');\n      }\n\n      // Check for suspicious patterns\n      this.detectSuspiciousPatterns(validation);\n\n      validation.metrics.totalEvents = this.events.length;\n      validation.metrics.validEvents = validEvents;\n      validation.metrics.invalidEvents = invalidEvents;\n      validation.metrics.eventTypes = Array.from(eventTypes);\n      validation.metrics.eventTypeCount = eventTypes.size;\n      validation.metrics.missingSelectors = missingSelectors.length;\n      validation.metrics.missingTimestamps = missingTimestamps.length;\n    }\n\n    validateScreenshots(validation) {\n      if (this.screenshots.length === 0) {\n        validation.warnings.push('No screenshots captured');\n        validation.suggestions.push('Screenshots provide valuable visual context for training');\n        validation.score -= 10;\n      } else {\n        let validScreenshots = 0;\n        let corruptedScreenshots = 0;\n\n        this.screenshots.forEach((screenshot, index) => {\n          if (!screenshot.dataUrl || !screenshot.dataUrl.startsWith('data:image/')) {\n            validation.errors.push(`Screenshot ${index}: Invalid or missing image data`);\n            corruptedScreenshots++;\n          } else {\n            validScreenshots++;\n          }\n\n          if (!screenshot.timestamp) {\n            validation.warnings.push(`Screenshot ${index}: Missing timestamp`);\n          }\n\n          if (!screenshot.trigger) {\n            validation.warnings.push(`Screenshot ${index}: Missing trigger information`);\n          }\n        });\n\n        // Check screenshot frequency\n        const duration = Date.now() - this.startTime;\n        const screenshotRate = this.screenshots.length / (duration / 1000);\n        \n        if (screenshotRate > 2) { // More than 2 per second\n          validation.warnings.push('Very high screenshot capture rate - may impact performance');\n        } else if (screenshotRate < 0.1) { // Less than 1 per 10 seconds\n          validation.warnings.push('Low screenshot capture rate - may miss important visual changes');\n        }\n\n        validation.metrics.totalScreenshots = this.screenshots.length;\n        validation.metrics.validScreenshots = validScreenshots;\n        validation.metrics.corruptedScreenshots = corruptedScreenshots;\n        validation.metrics.screenshotRate = screenshotRate;\n      }\n    }\n\n    validateInteractionPatterns(validation) {\n      const clickEvents = this.events.filter(e => e.type === 'CLICK');\n      const inputEvents = this.events.filter(e => e.type === 'INPUT');\n      const navEvents = this.events.filter(e => e.type === 'NAVIGATION');\n      const scrollEvents = this.events.filter(e => e.type === 'SCROLL');\n\n      // Check for realistic interaction patterns\n      if (clickEvents.length === 0) {\n        validation.warnings.push('No click interactions captured');\n        validation.suggestions.push('Click interactions are essential for shopping behavior training');\n      }\n\n      // Check interaction timing\n      if (clickEvents.length > 1) {\n        const intervals = [];\n        for (let i = 1; i < clickEvents.length; i++) {\n          intervals.push(clickEvents[i].timestamp - clickEvents[i-1].timestamp);\n        }\n        \n        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;\n        const minInterval = Math.min(...intervals);\n        \n        if (minInterval < 100) { // Less than 100ms between clicks\n          validation.warnings.push('Suspiciously fast clicking detected - may indicate automated behavior');\n        }\n        \n        if (avgInterval < 500) { // Average less than 500ms\n          validation.warnings.push('Very rapid clicking pattern - may not represent natural human behavior');\n        }\n\n        validation.metrics.averageClickInterval = avgInterval;\n        validation.metrics.minimumClickInterval = minInterval;\n      }\n\n      // Check for shopping-specific patterns\n      this.validateShoppingPatterns(validation);\n\n      validation.metrics.clickCount = clickEvents.length;\n      validation.metrics.inputCount = inputEvents.length;\n      validation.metrics.navigationCount = navEvents.length;\n      validation.metrics.scrollCount = scrollEvents.length;\n    }\n\n    validateShoppingPatterns(validation) {\n      const urls = this.events.map(e => e.url).filter(Boolean);\n      const uniqueUrls = new Set(urls);\n      \n      // Check for shopping-related URLs\n      const shoppingKeywords = ['product', 'item', 'cart', 'checkout', 'buy', 'shop', 'category', 'search'];\n      const hasShoppingUrls = urls.some(url => \n        shoppingKeywords.some(keyword => url.toLowerCase().includes(keyword))\n      );\n\n      if (!hasShoppingUrls) {\n        validation.warnings.push('No shopping-related URLs detected');\n        validation.suggestions.push('Ensure interactions occur on e-commerce pages for relevant training data');\n      }\n\n      // Check for product interaction patterns\n      const productViews = this.events.filter(e => \n        e.url && e.url.toLowerCase().includes('product')\n      ).length;\n\n      const cartActions = this.events.filter(e => \n        e.elementText && e.elementText.toLowerCase().includes('cart')\n      ).length;\n\n      if (productViews === 0) {\n        validation.warnings.push('No product page interactions detected');\n      }\n\n      if (cartActions === 0) {\n        validation.suggestions.push('Consider including cart interactions for complete shopping behavior');\n      }\n\n      validation.metrics.uniqueUrls = uniqueUrls.size;\n      validation.metrics.productViews = productViews;\n      validation.metrics.cartActions = cartActions;\n      validation.metrics.hasShoppingUrls = hasShoppingUrls;\n    }\n\n    validateDataCompleteness(validation) {\n      const completeness = this.calculateCompleteness();\n      \n      if (completeness < 50) {\n        validation.errors.push('Data completeness is too low for quality training');\n        validation.score -= 20;\n      } else if (completeness < 75) {\n        validation.warnings.push('Data completeness could be improved');\n        validation.suggestions.push('Try to capture more diverse interactions and screenshots');\n      }\n\n      // Check for missing critical data\n      const criticalMissing = [];\n      \n      if (this.events.length === 0) criticalMissing.push('interaction events');\n      if (this.screenshots.length === 0) criticalMissing.push('screenshots');\n      if (!this.pageStructure) criticalMissing.push('page structure analysis');\n\n      if (criticalMissing.length > 0) {\n        validation.errors.push(`Missing critical data: ${criticalMissing.join(', ')}`);\n      }\n\n      validation.metrics.completeness = completeness;\n      validation.metrics.criticalMissing = criticalMissing;\n    }\n\n    detectSuspiciousPatterns(validation) {\n      // Check for bot-like behavior patterns\n      const clickEvents = this.events.filter(e => e.type === 'CLICK');\n      \n      if (clickEvents.length > 0) {\n        // Check for identical coordinates (bot-like)\n        const coordinates = clickEvents.map(e => `${e.coordinates?.clientX},${e.coordinates?.clientY}`);\n        const uniqueCoordinates = new Set(coordinates);\n        \n        if (coordinates.length > 3 && uniqueCoordinates.size === 1) {\n          validation.warnings.push('Identical click coordinates detected - may indicate automated behavior');\n        }\n\n        // Check for perfect timing patterns\n        const intervals = [];\n        for (let i = 1; i < clickEvents.length; i++) {\n          intervals.push(clickEvents[i].timestamp - clickEvents[i-1].timestamp);\n        }\n        \n        if (intervals.length > 2) {\n          const variance = this.calculateVariance(intervals);\n          if (variance < 100) { // Very low variance in timing\n            validation.warnings.push('Suspiciously consistent timing pattern detected');\n          }\n        }\n      }\n\n      // Check for missing human-like variations\n      const hasScrolling = this.events.some(e => e.type === 'SCROLL');\n      const hasMouseMovement = this.events.some(e => e.coordinates);\n      \n      if (!hasScrolling && this.events.length > 5) {\n        validation.suggestions.push('Consider including scrolling behavior for more natural interaction patterns');\n      }\n    }\n\n    testSelectorReliability(selector) {\n      try {\n        const elements = document.querySelectorAll(selector);\n        if (elements.length === 0) return 0; // Selector doesn't match anything\n        if (elements.length === 1) return 1; // Perfect match\n        if (elements.length <= 3) return 0.8; // Good match\n        if (elements.length <= 10) return 0.6; // Okay match\n        return 0.3; // Poor match (too many elements)\n      } catch (error) {\n        return 0; // Invalid selector\n      }\n    }\n\n    calculateVariance(numbers) {\n      const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;\n      const squaredDiffs = numbers.map(n => Math.pow(n - mean, 2));\n      return squaredDiffs.reduce((a, b) => a + b, 0) / numbers.length;\n    }\n\n    // Real-time validation feedback\n    showValidationFeedback(validation) {\n      // Remove existing feedback\n      const existingFeedback = document.getElementById('unified-validation-feedback');\n      if (existingFeedback) {\n        existingFeedback.remove();\n      }\n\n      // Only show if there are issues\n      if (validation.errors.length === 0 && validation.warnings.length === 0) {\n        return;\n      }\n\n      const feedback = document.createElement('div');\n      feedback.id = 'unified-validation-feedback';\n      feedback.innerHTML = `\n        <div style=\"\n          position: fixed;\n          top: 50px;\n          right: 10px;\n          background: ${validation.errors.length > 0 ? '#f44336' : '#ff9800'};\n          color: white;\n          padding: 12px;\n          border-radius: 4px;\n          font-family: Arial, sans-serif;\n          font-size: 12px;\n          z-index: 999998;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n          max-width: 300px;\n          cursor: pointer;\n        \" onclick=\"this.style.display='none'\">\n          <div style=\"font-weight: bold; margin-bottom: 8px;\">\n            Data Quality: ${validation.score}/100\n          </div>\n          ${validation.errors.length > 0 ? `\n            <div style=\"margin-bottom: 4px;\">\n              <strong>Errors:</strong> ${validation.errors.length}\n            </div>\n          ` : ''}\n          ${validation.warnings.length > 0 ? `\n            <div style=\"margin-bottom: 4px;\">\n              <strong>Warnings:</strong> ${validation.warnings.length}\n            </div>\n          ` : ''}\n          <div style=\"font-size: 10px; opacity: 0.8;\">\n            Click to dismiss\n          </div>\n        </div>\n      `;\n      \n      document.body.appendChild(feedback);\n\n      // Auto-hide after 10 seconds\n      setTimeout(() => {\n        if (feedback.parentNode) {\n          feedback.remove();\n        }\n      }, 10000);\n    }\n\n    // Periodic validation during session\n    startPeriodicValidation() {\n      if (this.validationInterval) {\n        clearInterval(this.validationInterval);\n      }\n\n      this.validationInterval = setInterval(() => {\n        if (this.isTracking && this.events.length > 0) {\n          const validation = this.validateSessionData();\n          \n          // Show feedback for significant issues\n          if (validation.errors.length > 0 || validation.warnings.length > 2) {\n            this.showValidationFeedback(validation);\n          }\n\n          // Send validation metrics to background\n          chrome.runtime.sendMessage({\n            action: 'VALIDATION_UPDATE',\n            sessionId: this.sessionId,\n            validation: {\n              score: validation.score,\n              isValid: validation.isValid,\n              errorCount: validation.errors.length,\n              warningCount: validation.warnings.length,\n              metrics: validation.metrics\n            }\n          }).catch(() => {\n            // Ignore errors - background script might not be ready\n          });\n        }\n      }, 30000); // Every 30 seconds\n    }\n\n    stopPeriodicValidation() {\n      if (this.validationInterval) {\n        clearInterval(this.validationInterval);\n        this.validationInterval = null;\n      }\n    }\n\n    // UI feedback\n    showTrackingIndicator() {\n      if (document.getElementById('unified-tracking-indicator')) return;\n      \n      const indicator = document.createElement('div');\n      indicator.id = 'unified-tracking-indicator';\n      indicator.innerHTML = `\n        <div style=\"\n          position: fixed;\n          top: 10px;\n          right: 10px;\n          background: #4CAF50;\n          color: white;\n          padding: 8px 12px;\n          border-radius: 4px;\n          font-family: Arial, sans-serif;\n          font-size: 12px;\n          z-index: 999999;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n        \">\n          🔴 CodeSight Recording\n        </div>\n      `;\n      \n      document.body.appendChild(indicator);\n    }\n\n    hideTrackingIndicator() {\n      const indicator = document.getElementById('unified-tracking-indicator');\n      if (indicator) {\n        indicator.remove();\n      }\n    }\n\n    // Task overlay methods\n    async fetchAndDisplayTask() {\n      console.log('Unified: fetchAndDisplayTask() called'); // Debug log\n      try {\n        console.log('Unified: Fetching task for session:', this.sessionId);\n        \n        // Request task from background script to avoid CORS issues\n        const response = await chrome.runtime.sendMessage({\n          action: 'FETCH_TASK',\n          sessionId: this.sessionId,\n          difficulty: 'beginner'\n        });\n        \n        if (response && response.success && response.task) {\n          this.currentTask = response.task;\n          // this.showTaskOverlay(); // Disabled per user request\n          console.log('Unified: Task loaded:', this.currentTask.title);\n        } else {\n          throw new Error('Failed to fetch task: ' + (response?.error || 'Unknown error'));\n        }\n      } catch (error) {\n        console.error('Unified: Failed to fetch task:', error);\n        // Show fallback task\n        this.currentTask = {\n          title: \"Explore this website\",\n          description: \"Browse around and interact with different elements to help train our AI system\",\n          website: window.location.href,\n          difficulty: \"BEGINNER\"\n        };\n        // this.showTaskOverlay(); // Disabled per user request\n      }\n    }\n\n    showTaskOverlay() {\n      if (document.getElementById('unified-task-overlay')) return;\n      if (!this.currentTask) return;\n      \n      const overlay = document.createElement('div');\n      overlay.id = 'unified-task-overlay';\n      \n      // Get website URL for display\n      const targetWebsite = this.currentTask.website || 'the target website';\n      const websiteDomain = targetWebsite.includes('://') ? new URL(targetWebsite).hostname : targetWebsite;\n      \n      overlay.innerHTML = `\n        <div style=\"\n          position: fixed;\n          top: 50px;\n          right: 10px;\n          width: 320px;\n          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n          color: white;\n          padding: 18px;\n          border-radius: 12px;\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\n          font-size: 14px;\n          z-index: 999998;\n          box-shadow: 0 4px 20px rgba(0,0,0,0.25);\n          border: 1px solid rgba(255,255,255,0.2);\n        \">\n          <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px;\">\n            <h4 style=\"margin: 0; font-size: 18px; color: #fff; display: flex; align-items: center;\">\n              🎯 <span style=\"margin-left: 8px;\">Your Task</span>\n            </h4>\n            <button onclick=\"document.getElementById('unified-task-overlay').style.display='none'\" \n                    style=\"background: none; border: none; color: white; font-size: 20px; cursor: pointer; opacity: 0.8; padding: 4px;\">×</button>\n          </div>\n          \n          <div style=\"margin-bottom: 16px;\">\n            <div style=\"font-weight: 600; margin-bottom: 6px; font-size: 15px;\">${this.currentTask.title}</div>\n            <div style=\"font-size: 13px; opacity: 0.9; line-height: 1.4;\">${this.currentTask.description}</div>\n          </div>\n          \n          <div style=\"\n            background: rgba(255,255,255,0.15);\n            border-radius: 8px;\n            padding: 12px;\n            margin-bottom: 12px;\n          \">\n            <div style=\"font-size: 12px; font-weight: 600; margin-bottom: 6px; opacity: 0.9;\">🌐 Target Website:</div>\n            <div style=\"font-size: 13px; font-weight: 500; color: #e8f4fd;\">${websiteDomain}</div>\n          </div>\n          \n          <div style=\"font-size: 11px; opacity: 0.8; text-align: center; font-style: italic;\">\n            Navigate to the website and complete your task naturally\n          </div>\n        </div>\n      `;\n      \n      document.body.appendChild(overlay);\n      this.taskOverlay = overlay;\n    }\n\n    hideTaskOverlay() {\n      const overlay = document.getElementById('unified-task-overlay');\n      if (overlay) {\n        overlay.remove();\n      }\n      this.taskOverlay = null;\n    }\n\n    // Task progress is no longer automatically tracked - let users complete tasks naturally\n\n    // Task completion is now handled naturally by user behavior, not automated step tracking\n\n    restoreTaskOverlay() {\n      // Check if we're tracking and have a current task\n      if (this.isTracking && this.currentTask) {\n        console.log('Unified: Restoring task overlay after navigation for task:', this.currentTask.title);\n        \n        // Small delay to ensure DOM is ready and tracking indicator is shown\n        setTimeout(() => {\n          // this.showTaskOverlay(); // Disabled per user request\n        }, 100);\n      } else if (this.isTracking && !this.currentTask) {\n        // If we're tracking but lost the task, try to fetch it again\n        console.log('Unified: Tracking active but no current task - attempting to fetch task');\n        setTimeout(() => {\n          // this.fetchAndDisplayTask(); // Disabled per user request\n        }, 500);\n      }\n      \n      // Check if current domain matches task website domain  \n      if (this.isTracking && this.currentTask && this.currentTask.website) {\n        const currentDomain = window.location.hostname;\n        const taskDomain = new URL(this.currentTask.website).hostname;\n        \n        if (currentDomain === taskDomain || currentDomain.includes(taskDomain)) {\n          console.log('Unified: Now on task target website!', currentDomain);\n          // Highlight that we've reached the task website\n          this.showTaskCompletionHint();\n        }\n      }\n    }\n\n    showTaskCompletionHint() {\n      // Remove any existing hints\n      const existingHint = document.getElementById('unified-task-completion-hint');\n      if (existingHint) existingHint.remove();\n      \n      const hint = document.createElement('div');\n      hint.id = 'unified-task-completion-hint';\n      hint.innerHTML = `\n        <div style=\"\n          position: fixed;\n          bottom: 20px;\n          right: 20px;\n          background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);\n          color: white;\n          padding: 16px 20px;\n          border-radius: 8px;\n          font-family: Arial, sans-serif;\n          font-size: 14px;\n          z-index: 999999;\n          box-shadow: 0 4px 12px rgba(0,0,0,0.3);\n          max-width: 300px;\n          animation: slideIn 0.3s ease-out;\n        \">\n          <div style=\"font-size: 18px; margin-bottom: 8px;\">🎯 Task Website Reached!</div>\n          <div style=\"font-weight: bold; margin-bottom: 4px;\">You're now on the target website</div>\n          <div style=\"font-size: 12px; opacity: 0.9;\">Start completing your task objectives</div>\n        </div>\n        <style>\n          @keyframes slideIn {\n            from { transform: translateX(100%); opacity: 0; }\n            to { transform: translateX(0); opacity: 1; }\n          }\n        </style>\n      `;\n      \n      document.body.appendChild(hint);\n      \n      // Auto remove after 4 seconds\n      setTimeout(() => {\n        if (hint.parentNode) {\n          hint.remove();\n        }\n      }, 4000);\n    }\n\n    // Status methods\n    getStatus() {\n      // Use restored counts if available, otherwise use current array lengths\n      const eventCount = this.events.length + (this.restoredEventCount || 0);\n      const screenshotCount = this.screenshots.length + (this.restoredScreenshotCount || 0);\n      \n      return {\n        isTracking: this.isTracking,\n        sessionId: this.sessionId,\n        startTime: this.startTime,\n        duration: this.isTracking ? Date.now() - this.startTime : 0,\n        eventCount: eventCount,\n        screenshotCount: screenshotCount,\n        currentUrl: window.location.href,\n        qualityScore: this.calculateQualityScore(),\n        completeness: this.calculateCompleteness(),\n        currentTask: this.currentTask,\n        taskProgress: this.taskProgress\n      };\n    }\n\n    async getSessionData() {\n      if (!this.isTracking) {\n        return null;\n      }\n      \n      return await this.prepareSessionData();\n    }\n\n    updateConfig(newConfig) {\n      this.config = { ...this.config, ...newConfig };\n      console.log('Unified: Config updated:', newConfig);\n    }\n\n    // Utility methods\n    throttle(func, limit) {\n      let inThrottle;\n      return function() {\n        const args = arguments;\n        const context = this;\n        if (!inThrottle) {\n          func.apply(context, args);\n          inThrottle = true;\n          setTimeout(() => inThrottle = false, limit);\n        }\n      };\n    }\n\n    generateId() {\n      return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n\n    setupStatePreservation() {\n      // Save state before page unloads\n      const saveBeforeUnload = () => {\n        if (this.isTracking) {\n          console.log('Unified: Saving state before navigation');\n          this.saveState();\n        }\n      };\n\n      // Multiple event listeners to catch all navigation scenarios\n      window.addEventListener('beforeunload', saveBeforeUnload);\n      window.addEventListener('pagehide', saveBeforeUnload);\n      // Note: unload event removed due to permissions policy violation\n      \n      // Also save state periodically during tracking\n      if (this.statePreservationInterval) {\n        clearInterval(this.statePreservationInterval);\n      }\n      \n      this.statePreservationInterval = setInterval(() => {\n        if (this.isTracking) {\n          this.saveState();\n        }\n      }, 5000); // Save every 5 seconds\n    }\n\n    cleanupStatePreservation() {\n      if (this.statePreservationInterval) {\n        clearInterval(this.statePreservationInterval);\n        this.statePreservationInterval = null;\n      }\n    }\n\n    // Enhanced data collection methods per ChatGPT specification\n    \n    getPrunedDOMSnapshot(targetElement) {\n      // Get a focused DOM snapshot around the target element (5 levels up/down)\n      let container = targetElement;\n      for (let i = 0; i < 5 && container.parentElement; i++) {\n        container = container.parentElement;\n      }\n      \n      return this.serializeElementTree(container, 5);\n    }\n    \n    serializeElementTree(element, maxDepth) {\n      if (maxDepth <= 0) return null;\n      \n      const result = {\n        tag: element.tagName.toLowerCase(),\n        attributes: {},\n        children: []\n      };\n      \n      // Copy important attributes\n      for (const attr of element.attributes) {\n        if (['id', 'class', 'data-testid', 'role', 'type'].includes(attr.name)) {\n          result.attributes[attr.name] = attr.value;\n        }\n      }\n      \n      // Add text content for text nodes\n      if (element.childNodes.length === 1 && element.childNodes[0].nodeType === Node.TEXT_NODE) {\n        result.text = element.textContent.trim().substring(0, 100);\n      }\n      \n      // Recursively serialize children (but limit to avoid huge payloads)\n      for (let i = 0; i < Math.min(element.children.length, 10); i++) {\n        const child = this.serializeElementTree(element.children[i], maxDepth - 1);\n        if (child) result.children.push(child);\n      }\n      \n      return result;\n    }\n    \n    generatePageHash() {\n      // Simple hash of page structure for duplicate detection\n      const content = document.title + window.location.pathname + document.body.innerHTML.substring(0, 1000);\n      let hash = 0;\n      for (let i = 0; i < content.length; i++) {\n        const char = content.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash; // Convert to 32-bit integer\n      }\n      return `sha256-${Math.abs(hash).toString(16)}`;\n    }\n    \n    getRecentNetworkRequests() {\n      // This would require additional setup to capture network requests\n      // For now, return placeholder\n      return [];\n    }\n    \n    getElementAttributes(element) {\n      const attrs = {};\n      for (const attr of element.attributes) {\n        attrs[attr.name] = attr.value;\n      }\n      return attrs;\n    }\n    \n    generateCSSSelector(element) {\n      const path = [];\n      let current = element;\n      \n      while (current && current !== document.body) {\n        let selector = current.tagName.toLowerCase();\n        \n        if (current.id) {\n          selector += `#${current.id}`;\n          path.unshift(selector);\n          break;\n        }\n        \n        if (current.className) {\n          // Handle both regular HTML elements (string) and SVG elements (object)\n          const classValue = typeof current.className === 'string' \n            ? current.className \n            : current.className.baseVal || current.className.toString();\n            \n          if (classValue && typeof classValue === 'string') {\n            const classes = classValue.split(' ').filter(c => c.trim());\n            if (classes.length > 0) {\n              selector += `.${classes.join('.')}`;\n            }\n          }\n        }\n        \n        // Add nth-child if needed for uniqueness\n        const parent = current.parentElement;\n        if (parent) {\n          const siblings = Array.from(parent.children).filter(s => s.tagName === current.tagName);\n          if (siblings.length > 1) {\n            const index = siblings.indexOf(current) + 1;\n            selector += `:nth-child(${index})`;\n          }\n        }\n        \n        path.unshift(selector);\n        current = current.parentElement;\n      }\n      \n      return path.join(' > ');\n    }\n    \n    generateXPath(element) {\n      const path = [];\n      let current = element;\n      \n      while (current && current !== document.documentElement) {\n        let selector = current.tagName.toLowerCase();\n        \n        if (current.id) {\n          selector = `${selector}[@id='${current.id}']`;\n          path.unshift(selector);\n          break;\n        }\n        \n        // Add position among siblings\n        const parent = current.parentElement;\n        if (parent) {\n          const siblings = Array.from(parent.children).filter(s => s.tagName === current.tagName);\n          if (siblings.length > 1) {\n            const index = siblings.indexOf(current) + 1;\n            selector += `[${index}]`;\n          }\n        }\n        \n        path.unshift(selector);\n        current = current.parentElement;\n      }\n      \n      return '//' + path.join('/');\n    }\n    \n    getElementBoundingBox(element) {\n      const rect = element.getBoundingClientRect();\n      return {\n        x: Math.round(rect.left),\n        y: Math.round(rect.top),\n        width: Math.round(rect.width),\n        height: Math.round(rect.height)\n      };\n    }\n    \n    getRelevantComputedStyle(element) {\n      const computed = window.getComputedStyle(element);\n      return {\n        visibility: computed.visibility,\n        display: computed.display,\n        cursor: computed.cursor,\n        z_index: computed.zIndex,\n        position: computed.position\n      };\n    }\n    \n    getParentElementInfo(element) {\n      const parent = element.parentElement;\n      if (!parent) return null;\n      \n      // Handle both HTML and SVG className properly\n      const classValue = typeof parent.className === 'string' \n        ? parent.className \n        : parent.className.baseVal || parent.className.toString();\n      \n      return {\n        tag: parent.tagName.toLowerCase(),\n        classes: classValue ? classValue.split(' ').filter(c => c.trim()) : [],\n        id: parent.id || null,\n        css_selector: this.generateCSSSelector(parent)\n      };\n    }\n    \n    getAncestorChain(element) {\n      const ancestors = [];\n      let current = element.parentElement;\n      \n      while (current && current !== document.body && ancestors.length < 10) {\n        // Handle both HTML and SVG className properly\n        const classValue = typeof current.className === 'string' \n          ? current.className \n          : current.className.baseVal || current.className.toString();\n        \n        ancestors.push({\n          tag: current.tagName.toLowerCase(),\n          classes: classValue ? classValue.split(' ').filter(c => c.trim()) : [],\n          id: current.id || null,\n          css_selector: this.generateCSSSelector(current)\n        });\n        current = current.parentElement;\n      }\n      \n      return ancestors;\n    }\n    \n    getSiblingElements(element) {\n      const parent = element.parentElement;\n      if (!parent) return [];\n      \n      const siblings = [];\n      const children = Array.from(parent.children);\n      const elementIndex = children.indexOf(element);\n      \n      // Get 2 siblings on each side\n      for (let i = Math.max(0, elementIndex - 2); i <= Math.min(children.length - 1, elementIndex + 2); i++) {\n        if (i !== elementIndex) {\n          const sibling = children[i];\n          siblings.push({\n            position: i < elementIndex ? 'before' : 'after',\n            tag: sibling.tagName.toLowerCase(),\n            text: this.getElementText(sibling).substring(0, 50),\n            css_selector: this.generateCSSSelector(sibling)\n          });\n        }\n      }\n      \n      return siblings;\n    }\n    \n    findNearbyClickableElements(targetElement, radius = 100) {\n      const nearby = [];\n      const targetRect = targetElement.getBoundingClientRect();\n      const targetCenter = {\n        x: targetRect.left + targetRect.width / 2,\n        y: targetRect.top + targetRect.height / 2\n      };\n      \n      const clickableSelectors = 'a, button, input, select, textarea, [role=\"button\"], [onclick], [tabindex]';\n      const candidates = document.querySelectorAll(clickableSelectors);\n      \n      candidates.forEach(element => {\n        if (element === targetElement) return;\n        \n        const rect = element.getBoundingClientRect();\n        if (rect.width === 0 || rect.height === 0) return;\n        \n        const center = {\n          x: rect.left + rect.width / 2,\n          y: rect.top + rect.height / 2\n        };\n        \n        const distance = Math.sqrt(\n          Math.pow(center.x - targetCenter.x, 2) + \n          Math.pow(center.y - targetCenter.y, 2)\n        );\n        \n        if (distance <= radius) {\n          nearby.push({\n            tag: element.tagName.toLowerCase(),\n            text: this.getElementText(element).substring(0, 50),\n            css_selector: this.generateCSSSelector(element),\n            distance: Math.round(distance)\n          });\n        }\n      });\n      \n      return nearby.sort((a, b) => a.distance - b.distance).slice(0, 5);\n    }\n    \n    detectActiveOverlays() {\n      const overlays = [];\n      \n      // Common modal/overlay selectors\n      const overlaySelectors = [\n        '.modal:not([style*=\"display: none\"])',\n        '.overlay:not([style*=\"display: none\"])',\n        '.popup:not([style*=\"display: none\"])',\n        '.dialog:not([style*=\"display: none\"])',\n        '[role=\"dialog\"]:not([style*=\"display: none\"])',\n        '.cookie-banner:not([style*=\"display: none\"])',\n        '.cookie-consent:not([style*=\"display: none\"])'\n      ];\n      \n      overlaySelectors.forEach(selector => {\n        const elements = document.querySelectorAll(selector);\n        elements.forEach(element => {\n          const computed = window.getComputedStyle(element);\n          if (computed.display !== 'none' && computed.visibility !== 'hidden') {\n            const closeButton = element.querySelector('button[class*=\"close\"], .close, [aria-label*=\"close\"]');\n            overlays.push({\n              id: element.id || `overlay-${overlays.length}`,\n              css_selector: this.generateCSSSelector(element),\n              bounding_box: this.getElementBoundingBox(element),\n              close_button: closeButton ? {\n                css_selector: this.generateCSSSelector(closeButton)\n              } : null\n            });\n          }\n        });\n      });\n      \n      return overlays;\n    }\n\n    // Check if element is in viewport\n    isElementInViewport(element) {\n      const rect = element.getBoundingClientRect();\n      return (\n        rect.top >= 0 &&\n        rect.left >= 0 &&\n        rect.bottom <= window.innerHeight &&\n        rect.right <= window.innerWidth\n      );\n    }\n\n    // Test selector reliability (simplified)\n    testSelectorReliability(selector) {\n      try {\n        const elements = document.querySelectorAll(selector);\n        return elements.length === 1 ? 1.0 : Math.max(0.1, 1.0 / elements.length);\n      } catch (e) {\n        return 0.1;\n      }\n    }\n\n    // Get viewport information\n    getViewportInfo() {\n      return {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        scrollX: window.scrollX,\n        scrollY: window.scrollY,\n        devicePixelRatio: window.devicePixelRatio || 1\n      };\n    }\n\n    // Update existing event and send to background\n    updateEvent(eventData) {\n      const idx = this.events.findIndex(e => e.id === eventData.id);\n      if (idx !== -1) {\n        this.events[idx] = { ...this.events[idx], ...eventData };\n        this.saveState();\n        // **New**: push updated event to background\n        chrome.runtime.sendMessage({\n          action: 'SEND_DATA',\n          data: this.events[idx]\n        });\n      }\n    }\n\n    // Get complete session data for download\n    getSessionData() {\n      const duration = this.isTracking ? Date.now() - this.startTime : 0;\n      \n      const sessionData = {\n        sessionId: this.sessionId,\n        isTracking: this.isTracking,\n        startTime: this.startTime,\n        duration: duration,\n        currentUrl: window.location.href,\n        \n        // Enhanced interaction data\n        events: this.events,\n        eventCount: this.events.length,\n        \n        // Screenshots\n        screenshots: this.screenshots,\n        screenshotCount: this.screenshots.length,\n        \n        // Session metadata\n        config: this.config,\n        \n        // Quality metrics\n        quality: this.calculateQualityScore(),\n        \n        // Page context\n        pageContext: {\n          title: document.title,\n          url: window.location.href,\n          timestamp: Date.now(),\n          viewport: this.getViewportInfo(),\n          userAgent: navigator.userAgent\n        },\n        \n        // Data structure info\n        dataStructure: {\n          enhancedDataGroups: 6,\n          version: '2.0',\n          features: [\n            'multi-selector-generation',\n            'enhanced-element-analysis', \n            'visual-context-collection',\n            'dom-hierarchy-mapping',\n            'state-change-detection',\n            'detailed-interaction-metadata'\n          ]\n        }\n      };\n      \n      // Apply comprehensive PII sanitization to entire session data\n      return this.sanitizeData(sessionData);\n    }\n\n    // Calculate session quality score\n    calculateQualityScore() {\n      if (this.events.length === 0) return 0;\n      \n      let score = 0;\n      let totalChecks = 0;\n      \n      // Check for enhanced data completeness\n      this.events.forEach(event => {\n        totalChecks++;\n        \n        // Check for selector data\n        if (event.selectors && event.selectors.primary) score += 20;\n        \n        // Check for element analysis\n        if (event.element && event.element.tag) score += 20;\n        \n        // Check for visual context\n        if (event.visual && event.visual.boundingBox) score += 20;\n        \n        // Check for DOM context\n        if (event.context && event.context.parentElements) score += 20;\n        \n        // Check for interaction metadata\n        if (event.interaction && event.interaction.coordinates) score += 20;\n      });\n      \n      return totalChecks > 0 ? Math.round(score / totalChecks) : 0;\n    }\n\n    // Get current tracking status\n    getStatus() {\n      return {\n        isTracking: this.isTracking,\n        sessionId: this.sessionId,\n        eventCount: this.events.length,\n        screenshotCount: this.screenshots.length,\n        duration: this.isTracking ? Date.now() - this.startTime : 0,\n        quality: this.calculateQualityScore()\n      };\n    }\n  }\n\n  // Initialize the tracker\n  window.UnifiedCodeSightTracker = new UnifiedCodeSightTracker();\n  \n  // 🔍 TEST: Immediate console log to verify script loading\n  console.log('🚀 CodeSight Enhanced Tracker Loaded!', new Date().toISOString());\n\n})();"],"names":[],"sourceRoot":""}