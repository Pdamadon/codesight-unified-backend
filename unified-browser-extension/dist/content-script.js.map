{"version":3,"file":"content-script.js","mappings":"AAGA","sources":["webpack://unified-codesight-tracker/./content-script.js"],"sourcesContent":["// Unified CodeSight Content Script v2.0\n// Enhanced data capture with privacy protection and quality control\n\n(function() {\n  'use strict';\n  \n  // Prevent multiple injections\n  if (window.UnifiedCodeSightTracker || window.UNIFIED_CODESIGHT_LOADED) {\n    console.log('Unified CodeSight already loaded, skipping');\n    return;\n  }\n  \n  window.UNIFIED_CODESIGHT_LOADED = true;\n\n  class UnifiedCodeSightTracker {\n    constructor() {\n      this.isTracking = false;\n      this.sessionId = null;\n      this.startTime = 0;\n      this.events = [];\n      this.screenshots = [];\n      this.currentUrl = window.location.href;\n      \n      // Configuration\n      this.config = {\n        screenshotQuality: 0.8,\n        maxScreenshots: 200,\n        maxEvents: 1000,\n        privacyMode: true,\n        compressionEnabled: true,\n        burstModeEnabled: true\n      };\n      \n      // State tracking\n      this.pageStructure = null;\n      this.lastInteractionTime = 0;\n      this.interactionSequence = 0;\n      \n      // Task tracking\n      this.currentTask = null;\n      this.taskProgress = {\n        currentStep: 0,\n        completedSteps: []\n      };\n      this.taskOverlay = null;\n      \n      // Privacy filters - Comprehensive PII protection\n      this.sensitiveSelectors = [\n        // Password fields\n        'input[type=\"password\"]',\n        'input[name*=\"password\"]',\n        'input[name*=\"pwd\"]',\n        'input[id*=\"password\"]',\n        'input[placeholder*=\"password\"]',\n        \n        // Personal identification\n        'input[name*=\"ssn\"]',\n        'input[name*=\"social\"]',\n        'input[name*=\"social-security\"]',\n        'input[name*=\"social_security\"]',\n        'input[name*=\"socialsecurity\"]',\n        'input[id*=\"ssn\"]',\n        'input[id*=\"social\"]',\n        \n        // Credit card and payment\n        'input[name*=\"credit\"]',\n        'input[name*=\"card\"]',\n        'input[name*=\"cc\"]',\n        'input[name*=\"cvv\"]',\n        'input[name*=\"cvc\"]',\n        'input[name*=\"security-code\"]',\n        'input[name*=\"security_code\"]',\n        'input[name*=\"securitycode\"]',\n        'input[name*=\"expir\"]',\n        'input[name*=\"exp-\"]',\n        'input[name*=\"pin\"]',\n        'input[id*=\"credit\"]',\n        'input[id*=\"card\"]',\n        'input[id*=\"cvv\"]',\n        'input[id*=\"cvc\"]',\n        'input[autocomplete*=\"cc\"]',\n        \n        // Bank and financial\n        'input[name*=\"bank\"]',\n        'input[name*=\"routing\"]',\n        'input[name*=\"account\"]',\n        'input[name*=\"iban\"]',\n        'input[name*=\"swift\"]',\n        'input[id*=\"bank\"]',\n        'input[id*=\"routing\"]',\n        'input[id*=\"account\"]',\n        \n        // Personal information\n        'input[name*=\"first-name\"]',\n        'input[name*=\"first_name\"]',\n        'input[name*=\"firstname\"]',\n        'input[name*=\"last-name\"]',\n        'input[name*=\"last_name\"]',\n        'input[name*=\"lastname\"]',\n        'input[name*=\"full-name\"]',\n        'input[name*=\"full_name\"]',\n        'input[name*=\"fullname\"]',\n        'input[name=\"name\"]',\n        'input[id*=\"first-name\"]',\n        'input[id*=\"first_name\"]',\n        'input[id*=\"firstname\"]',\n        'input[id*=\"last-name\"]',\n        'input[id*=\"last_name\"]',\n        'input[id*=\"lastname\"]',\n        'input[id=\"name\"]',\n        \n        // Contact information\n        'input[name*=\"email\"]',\n        'input[name*=\"phone\"]',\n        'input[name*=\"mobile\"]',\n        'input[name*=\"telephone\"]',\n        'input[type=\"email\"]',\n        'input[type=\"tel\"]',\n        'input[id*=\"email\"]',\n        'input[id*=\"phone\"]',\n        'input[id*=\"mobile\"]',\n        \n        // Address information\n        'input[name*=\"address\"]',\n        'input[name*=\"street\"]',\n        'input[name*=\"city\"]',\n        'input[name*=\"state\"]',\n        'input[name*=\"zip\"]',\n        'input[name*=\"postal\"]',\n        'input[name*=\"country\"]',\n        'input[id*=\"address\"]',\n        'input[id*=\"street\"]',\n        'input[id*=\"city\"]',\n        'input[id*=\"state\"]',\n        'input[id*=\"zip\"]',\n        'input[id*=\"postal\"]',\n        \n        // Date of birth\n        'input[name*=\"birth\"]',\n        'input[name*=\"dob\"]',\n        'input[name*=\"age\"]',\n        'input[id*=\"birth\"]',\n        'input[id*=\"dob\"]',\n        'input[id*=\"age\"]',\n        \n        // Government IDs\n        'input[name*=\"license\"]',\n        'input[name*=\"passport\"]',\n        'input[name*=\"id-number\"]',\n        'input[name*=\"id_number\"]',\n        'input[name*=\"idnumber\"]',\n        'input[id*=\"license\"]',\n        'input[id*=\"passport\"]',\n        'input[id*=\"id-number\"]',\n        \n        // Generic sensitive fields\n        'input[type=\"hidden\"]',\n        '[data-sensitive]',\n        '.sensitive-data',\n        '[autocomplete=\"new-password\"]',\n        '[autocomplete=\"current-password\"]',\n        '[autocomplete*=\"name\"]',\n        '[autocomplete*=\"email\"]',\n        '[autocomplete*=\"tel\"]',\n        '[autocomplete*=\"address\"]',\n        '[autocomplete*=\"postal-code\"]',\n        '[autocomplete*=\"cc-\"]'\n      ];\n      \n      this.initializeTracker();\n    }\n\n    initializeTracker() {\n      // Listen for messages from background script\n      chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n        this.handleMessage(message, sender, sendResponse);\n        return true; // Keep message channel open for async responses\n      });\n\n      // Set up navigation handling\n      this.setupNavigationHandling();\n      \n      // Set up state preservation for navigation\n      this.setupStatePreservation();\n      \n      // Set up periodic state saving for navigation\n      this.setupPeriodicStateSaving();\n      \n      // Restore state if needed\n      this.restoreState();\n      \n      // Restore task overlay if tracking is active (delay to ensure state is fully restored)\n      setTimeout(() => {\n        this.restoreTaskOverlay();\n      }, 200);\n      \n      console.log('Unified CodeSight Tracker initialized v2.0');\n    }\n\n    async handleMessage(message, sender, sendResponse) {\n      try {\n        switch (message.action) {\n          case 'START_TRACKING':\n            await this.startTracking(message.sessionId, message.config, message.generatedTask);\n            sendResponse({ success: true });\n            break;\n            \n          case 'STOP_TRACKING':\n            const result = await this.stopTracking();\n            sendResponse({ success: true, data: result });\n            break;\n            \n          case 'GET_STATUS':\n            sendResponse(this.getStatus());\n            break;\n            \n          case 'GET_SESSION_DATA':\n            const sessionData = this.getSessionData();\n            sendResponse({ success: true, data: sessionData });\n            break;\n            \n          case 'UPDATE_CONFIG':\n            this.updateConfig(message.config);\n            sendResponse({ success: true });\n            break;\n            \n          case 'CAPTURE_SCREENSHOT':\n            const screenshot = await this.captureScreenshot(message.trigger);\n            sendResponse({ success: true, screenshot });\n            break;\n\n          case 'ping':\n            sendResponse({ success: true, message: 'Content script is working', tracker: !!window.UnifiedCodeSightTracker });\n            break;\n            \n          default:\n            sendResponse({ success: false, error: 'Unknown action' });\n        }\n      } catch (error) {\n        console.error('Unified: Message handling error:', error);\n        sendResponse({ success: false, error: error.message });\n      }\n    }\n\n    async startTracking(sessionId, config = {}, generatedTask = null) {\n      if (this.isTracking) {\n        console.log('Unified: Already tracking');\n        return;\n      }\n      \n      // Check for user consent before starting tracking\n      const consentResult = await new Promise((resolve) => {\n        chrome.storage.local.get(['userConsent'], (result) => {\n          resolve(result.userConsent);\n        });\n      });\n      \n      if (consentResult !== true) {\n        console.log('Unified: User consent not granted, cannot start tracking');\n        return;\n      }\n\n      this.sessionId = sessionId;\n      this.startTime = Date.now();\n      this.isTracking = true;\n      this.events = [];\n      this.screenshots = [];\n      this.interactionSequence = 0;\n      \n      // Update configuration\n      this.config = { ...this.config, ...config };\n      \n      // Store generated task if provided\n      if (generatedTask) {\n        this.currentTask = generatedTask;\n        console.log('Unified: Using generated task:', generatedTask.title);\n      }\n      \n      // Analyze initial page structure\n      this.pageStructure = this.analyzePageStructure();\n      \n      // Bind event listeners\n      this.bindEventListeners();\n      \n      // Show tracking indicator\n      this.showTrackingIndicator();\n      \n      // Task display disabled - using extension popup instead\n      // await this.fetchAndDisplayTask();\n      \n      // Save state\n      this.saveState();\n      \n      // Capture initial screenshot\n      await this.captureScreenshot('session_start');\n      \n      // Start periodic validation\n      this.startPeriodicValidation();\n      \n      // Notify background script to start session on backend\n      this.startBackendSession();\n      \n      console.log('Unified: Tracking started for session:', sessionId);\n    }\n\n    async stopTracking() {\n      if (!this.isTracking) {\n        console.log('Unified: Not currently tracking');\n        return null;\n      }\n\n      this.isTracking = false;\n      \n      // Unbind event listeners\n      this.unbindEventListeners();\n      \n      // Stop navigation handling\n      this.cleanupNavigationHandling();\n      \n      // Stop state preservation\n      this.cleanupStatePreservation();\n      \n      // Stop periodic validation\n      this.stopPeriodicValidation();\n      \n      // Hide tracking indicator and task overlay\n      this.hideTrackingIndicator();\n      this.hideTaskOverlay();\n      \n      // Capture final screenshot\n      await this.captureScreenshot('session_end');\n      \n      // Perform final validation\n      const finalValidation = this.validateSessionData();\n      console.log('Unified: Final validation score:', finalValidation.score);\n      \n      // Prepare session data\n      const sessionData = await this.prepareSessionData();\n      \n      // Stop backend session\n      await this.stopBackendSession();\n      \n      // Clear periodic saving\n      if (this.stateSaveInterval) {\n        clearInterval(this.stateSaveInterval);\n        this.stateSaveInterval = null;\n      }\n      \n      // Clear state\n      this.clearState();\n      \n      console.log('Unified: Tracking stopped, captured', this.events.length, 'events');\n      \n      // 🆕 Download collected interaction data\n      await this.downloadSessionData();\n      \n      return sessionData;\n    }\n\n    bindEventListeners() {\n      // Enhanced click tracking\n      this.boundClickHandler = this.handleClick.bind(this);\n      document.addEventListener('click', this.boundClickHandler, true);\n      \n      // Input tracking with privacy protection\n      this.boundInputHandler = this.handleInput.bind(this);\n      document.addEventListener('input', this.boundInputHandler, true);\n      \n      // Form submission tracking\n      this.boundFormHandler = this.handleFormSubmit.bind(this);\n      document.addEventListener('submit', this.boundFormHandler, true);\n      \n      // Scroll tracking (throttled)\n      this.boundScrollHandler = this.throttle(this.handleScroll.bind(this), 200);\n      document.addEventListener('scroll', this.boundScrollHandler, true);\n      \n      // Focus tracking for accessibility\n      this.boundFocusHandler = this.handleFocus.bind(this);\n      document.addEventListener('focus', this.boundFocusHandler, true);\n      \n      // Key press tracking (for shortcuts and navigation)\n      this.boundKeyHandler = this.handleKeyPress.bind(this);\n      document.addEventListener('keydown', this.boundKeyHandler, true);\n      \n      // Hover tracking for dropdown navigation (debounced)\n      this.boundHoverHandler = this.createDebouncedHover(this.handleHover.bind(this), 300);\n      document.addEventListener('mouseenter', this.boundHoverHandler, true);\n      document.addEventListener('mouseleave', this.boundHoverHandler, true);\n    }\n\n    unbindEventListeners() {\n      if (this.boundClickHandler) {\n        document.removeEventListener('click', this.boundClickHandler, true);\n      }\n      if (this.boundInputHandler) {\n        document.removeEventListener('input', this.boundInputHandler, true);\n      }\n      if (this.boundFormHandler) {\n        document.removeEventListener('submit', this.boundFormHandler, true);\n      }\n      if (this.boundScrollHandler) {\n        document.removeEventListener('scroll', this.boundScrollHandler, true);\n      }\n      if (this.boundFocusHandler) {\n        document.removeEventListener('focus', this.boundFocusHandler, true);\n      }\n      if (this.boundKeyHandler) {\n        document.removeEventListener('keydown', this.boundKeyHandler, true);\n      }\n      if (this.boundHoverHandler) {\n        document.removeEventListener('mouseenter', this.boundHoverHandler, true);\n        document.removeEventListener('mouseleave', this.boundHoverHandler, true);\n      }\n    }\n\n    async handleClick(event) {\n      if (!this.isTracking) return;\n      \n      const element = event.target;\n      const timestamp = Date.now();\n      \n      // Skip if element is too small (likely tracking pixel)\n      const rect = element.getBoundingClientRect();\n      if (rect.width < 3 && rect.height < 3) return;\n      \n      // Capture screenshot before state changes\n      const screenshotPromise = this.captureScreenshot('click', timestamp);\n      \n      // Generate enhanced multi-selector strategy with reliability scoring\n      const selectors = this.generateEnhancedSelectors(element);\n      \n      // Capture enhanced DOM context matching reference model\n      const domContext = this.captureEnhancedDOMContext(element);\n      \n      // Get comprehensive element analysis\n      const elementAnalysis = this.analyzeElementEnhanced(element);\n      \n      // Capture page state before interaction\n      const stateBefore = this.capturePageState();\n      \n      const interactionData = {\n        type: 'CLICK',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n\n        // 1) Enhanced selectors (Group 1: Selectors)\n        selectors: {\n          primary: selectors.primary,\n          alternatives: selectors.alternatives,\n          xpath: selectors.xpath,\n          cssPath: selectors.cssPath,\n          selectorReliability: selectors.selectorReliability\n        },\n\n        // Backward compatibility - keep existing flattened fields\n        primarySelector: selectors.primary,\n        selectorAlternatives: selectors.alternatives,\n        xpath: selectors.xpath,\n        cssPath: selectors.cssPath,\n        selectorReliability: selectors.selectorReliability,\n\n        // 2) Enhanced visual context (Group 2: Visual)\n        visual: {\n          boundingBox: elementAnalysis.boundingBox,\n          viewport: this.getViewportInfo(),\n          isInViewport: elementAnalysis.isInViewport,\n          percentVisible: elementAnalysis.percentVisible,\n          screenshot: null // Will be set after screenshot capture\n        },\n\n        // 3) Enhanced element analysis (Group 3: Element)\n        element: elementAnalysis,\n\n        // Backward compatibility - keep existing flattened fields\n        elementTag: elementAnalysis.tagName,\n        elementText: elementAnalysis.text,\n        elementValue: elementAnalysis.value,\n        elementAttributes: elementAnalysis.attributes,\n        boundingBox: elementAnalysis.boundingBox,\n        isInViewport: elementAnalysis.isInViewport,\n        percentVisible: elementAnalysis.percentVisible,\n\n        // 4) Enhanced DOM context (Group 4: Context)\n        context: {\n          parentElements: domContext.parentElements,\n          siblings: domContext.siblings,\n          nearbyElements: domContext.nearbyElements,\n          pageStructure: domContext.pageStructure\n        },\n\n        // Backward compatibility - keep existing flattened fields\n        parentElements: domContext.parentElements,\n        siblingElements: domContext.siblings,\n        nearbyElements: domContext.nearbyElements,\n\n        // 5) Enhanced state tracking (Group 5: State)\n        state: {\n          before: stateBefore,\n          after: null, // Will be captured after delay\n          changes: null // Will be calculated after state capture\n        },\n\n        // 6) Enhanced interaction metadata (Group 6: Interaction)\n        interaction: {\n          coordinates: {\n            clientX: event.clientX,\n            clientY: event.clientY,\n            pageX: event.pageX,\n            pageY: event.pageY,\n            offsetX: event.offsetX,\n            offsetY: event.offsetY\n          },\n          modifiers: {\n            ctrlKey: event.ctrlKey,\n            shiftKey: event.shiftKey,\n            altKey: event.altKey,\n            metaKey: event.metaKey\n          },\n          timestamp: timestamp,\n          sessionTime: timestamp - this.startTime,\n          sequence: this.interactionSequence\n        },\n\n        // Backward compatibility - legacy fields\n        metadata: {\n          sessionId: this.sessionId,\n          userId: 'anon-user',\n          timestamp: new Date(timestamp).toISOString(),\n          pageUrl: window.location.href,\n          pageTitle: document.title,\n          viewport: this.getViewportInfo()\n        },\n        pageContext: {\n          domSnapshot: this.getPrunedDOMSnapshot(element),\n          htmlHash: this.generatePageHash(),\n          networkRequests: this.getRecentNetworkRequests()\n        },\n\n        // 5) Detailed elementDetails & overlays & action\n        elementDetails: {\n          tag: element.tagName.toLowerCase(),\n          text: this.getElementText(element),\n          attributes: this.getElementAttributes(element),\n          cssSelector: this.generateCSSSelector(element),\n          xpath: this.generateXPath(element),\n          boundingBox: this.getElementBoundingBox(element),\n          computedStyle: this.getRelevantComputedStyle(element)\n        },\n        contextData: {\n          parent: this.getParentElementInfo(element),\n          ancestors: this.getAncestorChain(element),\n          siblings: this.getSiblingElements(element),\n          nearestClickable: this.findNearbyElementsExpanded(element, 300)\n        },\n        overlays: this.detectActiveOverlays(),\n        action: {\n          type: 'click',\n          selector: selectors.primary,\n          timestamp: new Date(timestamp).toISOString()\n        },\n\n        // 🆕 Phase 2: Comprehensive price and product data extraction\n        priceData: this.extractPriceData(element),\n        \n        // 6) Coordinates & modifiers\n        coordinates: {\n          clientX: event.clientX,\n          clientY: event.clientY,\n          pageX: event.pageX,\n          pageY: event.pageY,\n          offsetX: event.offsetX,\n          offsetY: event.offsetY\n        },\n        modifiers: {\n          ctrlKey: event.ctrlKey,\n          shiftKey: event.shiftKey,\n          altKey: event.altKey,\n          metaKey: event.metaKey\n        },\n\n        // 7) Legacy fields (for pipeline)\n        stateBefore,\n        url: window.location.href,\n        pageTitle: document.title,\n        viewport: this.getViewportInfo()\n      };\n\n      // 🔍 LOG: Show what data we're collecting\n      console.log('🎯 CLICK DATA COLLECTED:', {\n        type: interactionData.type,\n        timestamp: new Date(interactionData.timestamp).toISOString(),\n        element: {\n          tag: interactionData.element?.tagName,\n          text: interactionData.element?.text?.substring(0, 50) + '...',\n          selector: interactionData.selectors?.primary,\n          isInteractive: interactionData.element?.isInteractive,\n          percentVisible: interactionData.element?.percentVisible,\n          attributeCount: Object.keys(interactionData.element?.attributes || {}).length\n        },\n        selectors: {\n          primary: interactionData.selectors?.primary,\n          alternativeCount: interactionData.selectors?.alternatives?.length,\n          topReliability: interactionData.selectors?.selectorReliability?.[interactionData.selectors.primary],\n          xpath: interactionData.selectors?.xpath?.substring(0, 50) + '...',\n          cssPath: interactionData.selectors?.cssPath?.substring(0, 50) + '...'\n        },\n        visual: {\n          viewport: interactionData.visual?.viewport,\n          isInViewport: interactionData.visual?.isInViewport,\n          percentVisible: interactionData.visual?.percentVisible,\n          hasScreenshot: !!interactionData.visual?.screenshot\n        },\n        interaction: {\n          coordinates: !!interactionData.interaction?.coordinates,\n          modifiers: !!interactionData.interaction?.modifiers,\n          timestamp: interactionData.interaction?.timestamp,\n          sessionTime: interactionData.interaction?.sessionTime,\n          sequence: interactionData.interaction?.sequence\n        },\n        state: {\n          hasBefore: !!interactionData.state?.before,\n          hasAfter: !!interactionData.state?.after,\n          hasChanges: !!interactionData.state?.changes\n        },\n        context: {\n          parentCount: interactionData.context?.parentElements?.length || 0,\n          siblingCount: interactionData.context?.siblings?.length || 0,\n          nearbyElementCount: interactionData.context?.nearbyElements?.length || 0,\n          hasPageStructure: !!interactionData.context?.pageStructure\n        },\n        enhancedFields: {\n          hasMetadata: !!interactionData.metadata,\n          hasPageContext: !!interactionData.pageContext,\n          hasElementDetails: !!interactionData.elementDetails,\n          hasContextData: !!interactionData.contextData,\n          hasOverlays: !!interactionData.overlays,\n          hasAction: !!interactionData.action,\n          overlayCount: interactionData.overlays?.length || 0\n        },\n        \n        // 🆕 Phase 1: Enhanced nearby elements with quality scoring\n        nearbyElements: {\n          totalCount: interactionData.contextData?.nearestClickable?.length || 0,\n          radius: '300px (expanded from 100px)',\n          qualityScores: interactionData.contextData?.nearestClickable?.slice(0, 3).map(el => ({\n            element: el.text?.substring(0, 30) + '...',\n            score: el.qualityScore?.score,\n            confidence: el.qualityScore?.confidence,\n            signals: el.qualityScore?.signals?.slice(0, 2)\n          })) || [],\n          categorization: {\n            priceElements: interactionData.contextData?.nearestClickable?.filter(el => el.elementCategory?.type === 'price').length || 0,\n            productElements: interactionData.contextData?.nearestClickable?.filter(el => el.elementCategory?.type === 'product').length || 0,\n            shoppingActions: interactionData.contextData?.nearestClickable?.filter(el => el.elementCategory?.type === 'shopping-action').length || 0,\n            interactiveElements: interactionData.contextData?.nearestClickable?.filter(el => el.elementCategory?.type === 'interactive').length || 0\n          }\n        },\n\n        // 🆕 Phase 2: Comprehensive price and product data\n        priceData: interactionData.priceData ? {\n          clickedElementPrices: {\n            count: interactionData.priceData.clickedElementPrices?.length || 0,\n            examples: interactionData.priceData.clickedElementPrices?.slice(0, 2).map(p => ({\n              raw: p.raw,\n              currency: p.currency,\n              amount: p.amount,\n              normalized: p.normalized\n            })) || []\n          },\n          nearbyPrices: {\n            count: interactionData.priceData.nearbyPrices?.length || 0,\n            avgConfidence: interactionData.priceData.nearbyPrices?.length > 0 \n              ? Math.round((interactionData.priceData.nearbyPrices.reduce((sum, p) => sum + p.confidence, 0) / interactionData.priceData.nearbyPrices.length) * 100) / 100\n              : 0,\n            topPrices: interactionData.priceData.nearbyPrices?.slice(0, 2).map(p => ({\n              price: p.price,\n              confidence: p.confidence,\n              distance: p.element?.distance\n            })) || []\n          },\n          productInfo: {\n            hasName: !!interactionData.priceData.productInfo?.name,\n            name: interactionData.priceData.productInfo?.name?.substring(0, 50) + (interactionData.priceData.productInfo?.name?.length > 50 ? '...' : ''),\n            hasBrand: !!interactionData.priceData.productInfo?.brand,\n            brand: interactionData.priceData.productInfo?.brand,\n            hasSKU: !!interactionData.priceData.productInfo?.sku,\n            hasCategory: !!interactionData.priceData.productInfo?.category,\n            category: interactionData.priceData.productInfo?.category\n          },\n          variants: {\n            hasSize: !!interactionData.priceData.variants?.size,\n            size: interactionData.priceData.variants?.size,\n            hasColor: !!interactionData.priceData.variants?.color,\n            color: interactionData.priceData.variants?.color,\n            hasStyle: !!interactionData.priceData.variants?.style,\n            optionsCount: interactionData.priceData.variants?.options?.length || 0\n          },\n          discounts: {\n            isOnSale: interactionData.priceData.discounts?.isOnSale || false,\n            hasOriginalPrice: !!interactionData.priceData.discounts?.originalPrice,\n            hasSalePrice: !!interactionData.priceData.discounts?.salePrice,\n            discountAmount: interactionData.priceData.discounts?.discount,\n            discountType: interactionData.priceData.discounts?.discountType\n          },\n          context: {\n            pageType: interactionData.priceData.context?.pageType,\n            isProductPage: interactionData.priceData.context?.isProductPage,\n            isCartPage: interactionData.priceData.context?.isCartPage\n          }\n        } : { error: 'No price data extracted' }\n      });\n\n      // Wait for screenshot and link to visual context\n      const screenshot = await screenshotPromise;\n      if (screenshot) {\n        interactionData.screenshotId = screenshot.id;\n        interactionData.visual.screenshot = screenshot.id;\n      }\n\n      // Capture state after a delay to see changes (reference model: 1000ms)\n      setTimeout(() => {\n        const stateAfter = this.capturePageState();\n        const stateChanges = this.detectStateChanges(stateBefore, stateAfter);\n        \n        // Update enhanced state structure\n        interactionData.state.after = stateAfter;\n        interactionData.state.changes = stateChanges;\n        \n        // Backward compatibility\n        interactionData.stateAfter = stateAfter;\n        interactionData.stateChanges = stateChanges;\n        \n        // Update the stored event\n        this.updateEvent(interactionData);\n        \n        console.log('Enhanced: State changes detected:', {\n          hasChanges: Object.keys(stateChanges).length > 0,\n          changeTypes: Object.keys(stateChanges),\n          urlChanged: !!stateChanges.urlChanged,\n          titleChanged: !!stateChanges.titleChanged,\n          scrollChanged: !!stateChanges.scrollChanged,\n          details: {\n            urlChange: stateChanges.urlChanged ? {\n              from: stateChanges.urlChanged.from?.substring(0, 50) + '...',\n              to: stateChanges.urlChanged.to?.substring(0, 50) + '...',\n              type: stateChanges.urlChanged.type\n            } : null,\n            titleChange: stateChanges.titleChanged ? {\n              from: stateChanges.titleChanged.from?.substring(0, 30) + '...',\n              to: stateChanges.titleChanged.to?.substring(0, 30) + '...'\n            } : null,\n            scrollChange: stateChanges.scrollChanged ? {\n              delta: stateChanges.scrollChanged.delta,\n              direction: stateChanges.scrollChanged.direction\n            } : null\n          }\n        });\n      }, 1000);\n\n      this.captureEvent(interactionData);\n      this.lastInteractionTime = timestamp;\n    }\n\n    async handleInput(event) {\n      if (!this.isTracking) return;\n      \n      const element = event.target;\n      \n      // Privacy protection - skip sensitive inputs\n      if (this.isSensitiveInput(element)) {\n        console.log('Unified: Skipping sensitive input');\n        return;\n      }\n      \n      const timestamp = Date.now();\n      \n      const interactionData = {\n        type: 'INPUT',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        selectors: this.generateMultipleSelectors(element),\n        element: this.analyzeElement(element),\n        \n        // Input details (sanitized)\n        inputType: element.type || 'text',\n        inputName: element.name || '',\n        placeholder: element.placeholder || '',\n        valueLength: element.value ? element.value.length : 0,\n        \n        url: window.location.href,\n        pageTitle: document.title\n      };\n\n      this.captureEvent(interactionData);\n    }\n\n    async handleFormSubmit(event) {\n      if (!this.isTracking) return;\n      \n      const form = event.target;\n      const timestamp = Date.now();\n      \n      // Capture screenshot of form submission\n      const screenshot = await this.captureScreenshot('form_submit', timestamp);\n      \n      const interactionData = {\n        type: 'FORM_SUBMIT',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        selectors: this.generateMultipleSelectors(form),\n        element: this.analyzeElement(form),\n        \n        // Form details (privacy-safe)\n        formAction: form.action || '',\n        formMethod: form.method || 'GET',\n        fieldCount: form.elements.length,\n        \n        screenshotId: screenshot?.id,\n        url: window.location.href,\n        pageTitle: document.title\n      };\n\n      this.captureEvent(interactionData);\n    }\n\n    handleScroll(event) {\n      if (!this.isTracking) return;\n      \n      // Skip scroll events to reduce noise (can be re-enabled if needed)\n      return;\n      \n      const timestamp = Date.now();\n      \n      const interactionData = {\n        type: 'SCROLL',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        scrollPosition: {\n          x: window.scrollX,\n          y: window.scrollY\n        },\n        \n        viewport: this.getViewportInfo(),\n        url: window.location.href\n      };\n\n      this.captureEvent(interactionData);\n    }\n\n    handleFocus(event) {\n      if (!this.isTracking) return;\n      \n      const element = event.target;\n      const timestamp = Date.now();\n      \n      const interactionData = {\n        type: 'FOCUS',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        selectors: this.generateMultipleSelectors(element),\n        element: this.analyzeElement(element),\n        \n        url: window.location.href\n      };\n\n      this.captureEvent(interactionData);\n    }\n\n    handleKeyPress(event) {\n      if (!this.isTracking) return;\n      \n      // Only capture significant key presses\n      const significantKeys = ['Enter', 'Tab', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n      if (!significantKeys.includes(event.key) && !event.ctrlKey && !event.metaKey) {\n        return;\n      }\n      \n      const timestamp = Date.now();\n      \n      const interactionData = {\n        type: 'KEY_PRESS',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        key: event.key,\n        code: event.code,\n        modifiers: {\n          ctrlKey: event.ctrlKey,\n          shiftKey: event.shiftKey,\n          altKey: event.altKey,\n          metaKey: event.metaKey\n        },\n        \n        url: window.location.href\n      };\n\n      this.captureEvent(interactionData);\n    }\n\n    // Hover event handling for dropdown navigation\n    createDebouncedHover(fn, delay) {\n      let timeoutId = null;\n      return (event) => {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(() => fn(event), delay);\n      };\n    }\n\n    isDropdownTrigger(element) {\n      // Check if element is a valid DOM element\n      if (!element || !element.nodeType || element.nodeType !== Node.ELEMENT_NODE) {\n        return false;\n      }\n      \n      // Ensure element has required DOM methods\n      if (typeof element.hasAttribute !== 'function' || \n          typeof element.classList !== 'object' ||\n          typeof element.closest !== 'function') {\n        return false;\n      }\n      \n      // 1. Semantic indicators - ARIA and data attributes\n      const hasDropdownAttributes = element.hasAttribute('aria-haspopup') ||\n                                    element.hasAttribute('data-toggle') ||\n                                    element.classList.contains('dropdown') ||\n                                    element.classList.contains('dropdown-toggle') ||\n                                    element.role === 'button';\n      \n      // 2. Navigation context - must be inside navigation structure\n      const isNavigation = element.closest('nav, .nav, .navigation, .menu, header, .navbar, .nav-menu');\n      \n      // 3. E-commerce specific text patterns\n      const elementText = element.textContent?.trim() || '';\n      const ecommercePattern = /^(Men|Women|Sale|Shop|Category|Browse|Kids|Home|New|Clothing|Shoes|Accessories|Collections)$/i;\n      const hasEcommerceText = ecommercePattern.test(elementText);\n      \n      // 4. Structural hints - has child menu elements\n      const hasChildMenu = element.querySelector('ul, .dropdown-menu, .submenu, .mega-menu') ||\n                          element.parentElement?.querySelector('.dropdown-menu, .submenu');\n      \n      // 5. CSS classes that indicate dropdown functionality\n      const hasDropdownClasses = element.classList.contains('has-dropdown') ||\n                                 element.classList.contains('dropdown-trigger') ||\n                                 element.classList.contains('menu-item-has-children');\n      \n      // Must be in navigation AND have either semantic indicators, e-commerce text, child menus, or dropdown classes\n      return isNavigation && (hasDropdownAttributes || hasEcommerceText || hasChildMenu || hasDropdownClasses);\n    }\n\n    async handleHover(event) {\n      if (!this.isTracking) return;\n      \n      const element = event.target;\n      const timestamp = Date.now();\n      \n      // Only process dropdown triggers\n      if (!this.isDropdownTrigger(element)) return;\n      \n      // Skip if element is too small (likely tracking pixel)\n      const rect = element.getBoundingClientRect();\n      if (rect.width < 10 && rect.height < 10) return;\n      \n      try {\n        // Capture DOM state before hover effect\n        const preHoverState = this.captureDropdownContext(element);\n        \n        // Wait for CSS transitions and dynamic content to load\n        await this.waitForDOMChanges(150);\n        \n        // Capture DOM state after hover effect\n        const postHoverState = this.captureDropdownContext(element);\n        \n        // Only send interaction if DOM actually changed (meaningful hover)\n        if (!this.hasSignificantDOMChange(preHoverState, postHoverState)) {\n          return;\n        }\n        \n        // Capture screenshot after hover effect reveals content\n        const screenshotPromise = this.captureScreenshot('hover', timestamp);\n        \n        // Generate selectors and element analysis (same as click handler)\n        const selectors = this.generateEnhancedSelectors(element);\n        const domContext = this.captureEnhancedDOMContext(element);\n        const elementAnalysis = this.analyzeElementEnhanced(element);\n        \n        const interactionData = {\n          type: 'HOVER',\n          timestamp,\n          sessionTime: timestamp - this.startTime,\n          sequence: ++this.interactionSequence,\n\n          // Enhanced selectors (same structure as click events)\n          selectors: {\n            primary: selectors.primary,\n            alternatives: selectors.alternatives,\n            xpath: selectors.xpath,\n            cssPath: selectors.cssPath,\n            selectorReliability: selectors.selectorReliability\n          },\n\n          // Backward compatibility\n          primarySelector: selectors.primary,\n          selectorAlternatives: selectors.alternatives,\n          xpath: selectors.xpath,\n          cssPath: selectors.cssPath,\n          selectorReliability: selectors.selectorReliability,\n\n          // Visual context\n          visual: {\n            boundingBox: elementAnalysis.boundingBox,\n            viewport: this.getViewportInfo(),\n            isInViewport: elementAnalysis.isInViewport,\n            percentVisible: elementAnalysis.percentVisible,\n            screenshot: null // Will be set after screenshot capture\n          },\n\n          // Element analysis\n          element: elementAnalysis,\n\n          // Backward compatibility\n          elementTag: elementAnalysis.tagName,\n          elementText: elementAnalysis.text,\n          elementValue: elementAnalysis.value,\n          elementAttributes: elementAnalysis.attributes,\n          boundingBox: elementAnalysis.boundingBox,\n          isInViewport: elementAnalysis.isInViewport,\n          percentVisible: elementAnalysis.percentVisible,\n\n          // DOM context\n          context: {\n            parentElements: domContext.parentElements,\n            siblings: domContext.siblings,\n            nearbyElements: domContext.nearbyElements,\n            pageStructure: domContext.pageStructure\n          },\n\n          // Backward compatibility\n          parentElements: domContext.parentElements,\n          siblingElements: domContext.siblings,\n          nearbyElements: domContext.nearbyElements,\n\n          // Hover-specific context\n          hoverContext: {\n            preHoverDOM: preHoverState,\n            postHoverDOM: postHoverState,\n            revealedElements: this.getRevealedElements(preHoverState, postHoverState),\n            dropdownTarget: elementAnalysis.text,\n            hoverType: event.type, // 'mouseenter' or 'mouseleave'\n            isDropdownTrigger: true\n          },\n\n          // Interaction metadata\n          interaction: {\n            coordinates: {\n              clientX: event.clientX,\n              clientY: event.clientY,\n              pageX: event.pageX,\n              pageY: event.pageY\n            },\n            timestamp: timestamp,\n            sessionTime: timestamp - this.startTime,\n            sequence: this.interactionSequence\n          },\n\n          // Legacy fields for compatibility\n          metadata: {\n            sessionId: this.sessionId,\n            userId: 'anon-user',\n            timestamp: new Date(timestamp).toISOString(),\n            pageUrl: window.location.href,\n            pageTitle: document.title,\n            viewport: this.getViewportInfo()\n          },\n          pageContext: {\n            domSnapshot: this.getPrunedDOMSnapshot(element),\n            htmlHash: this.generatePageHash(),\n            networkRequests: this.getRecentNetworkRequests()\n          }\n        };\n\n        // Wait for screenshot to complete\n        const screenshot = await screenshotPromise;\n        if (screenshot) {\n          interactionData.screenshot = screenshot;\n          interactionData.visual.screenshot = screenshot;\n        }\n\n        // Send the interaction data\n        this.captureEvent(interactionData);\n        \n        console.log('Unified: Captured hover interaction on dropdown trigger:', elementAnalysis.text);\n        \n      } catch (error) {\n        console.error('Unified: Error handling hover event:', error);\n      }\n    }\n\n    captureDropdownContext(element) {\n      try {\n        const visibleElements = Array.from(element.querySelectorAll('*'))\n          .filter(el => this.isElementVisible(el))\n          .map(el => ({\n            tag: el.tagName.toLowerCase(),\n            text: el.textContent?.trim() || '',\n            classes: el.className,\n            id: el.id,\n            visible: this.isElementVisible(el)\n          }));\n\n        return {\n          elementText: element.textContent?.trim() || '',\n          visibleChildren: visibleElements,\n          boundingRect: element.getBoundingClientRect(),\n          computedStyle: {\n            display: getComputedStyle(element).display,\n            visibility: getComputedStyle(element).visibility,\n            opacity: getComputedStyle(element).opacity\n          },\n          childElementCount: element.children.length,\n          timestamp: Date.now()\n        };\n      } catch (error) {\n        console.error('Unified: Error capturing dropdown context:', error);\n        return { error: error.message, timestamp: Date.now() };\n      }\n    }\n\n    hasSignificantDOMChange(before, after) {\n      if (!before || !after || before.error || after.error) return false;\n      \n      try {\n        // Check if new elements became visible (dropdown menu appeared)\n        const beforeVisible = before.visibleChildren ? before.visibleChildren.length : 0;\n        const afterVisible = after.visibleChildren ? after.visibleChildren.length : 0;\n        \n        // Significant if 2+ new elements appeared (indicating dropdown menu items)\n        const hasNewElements = afterVisible > beforeVisible + 1;\n        \n        // Also check if child element count changed significantly\n        const beforeChildren = before.childElementCount || 0;\n        const afterChildren = after.childElementCount || 0;\n        const hasNewChildren = afterChildren > beforeChildren;\n        \n        return hasNewElements || hasNewChildren;\n      } catch (error) {\n        console.error('Unified: Error comparing DOM states:', error);\n        return false;\n      }\n    }\n\n    getRevealedElements(before, after) {\n      if (!before?.visibleChildren || !after?.visibleChildren) return [];\n      \n      try {\n        const beforeTexts = new Set(before.visibleChildren.map(el => el.text));\n        const revealedElements = after.visibleChildren\n          .filter(el => !beforeTexts.has(el.text) && el.text.trim())\n          .map(el => ({\n            text: el.text,\n            tag: el.tag,\n            classes: el.classes\n          }));\n        \n        return revealedElements;\n      } catch (error) {\n        console.error('Unified: Error getting revealed elements:', error);\n        return [];\n      }\n    }\n\n    waitForDOMChanges(milliseconds) {\n      return new Promise(resolve => {\n        setTimeout(resolve, milliseconds);\n      });\n    }\n\n    isElementVisible(element) {\n      if (!element) return false;\n      \n      try {\n        const style = getComputedStyle(element);\n        const rect = element.getBoundingClientRect();\n        \n        return style.display !== 'none' &&\n               style.visibility !== 'hidden' &&\n               style.opacity !== '0' &&\n               rect.width > 0 &&\n               rect.height > 0;\n      } catch (error) {\n        return false;\n      }\n    }\n\n    // Enhanced selector generation\n    generateMultipleSelectors(element) {\n      const selectors = {\n        primary: null,\n        alternatives: [],\n        xpath: null,\n        cssPath: null,\n        reliability: {}\n      };\n\n      // Priority 1: ID selector\n      if (element.id && typeof element.id === 'string' && element.id.trim()) {\n        const idSelector = `#${element.id}`;\n        selectors.primary = idSelector;\n        selectors.alternatives.push(idSelector);\n        selectors.reliability[idSelector] = 0.95;\n      }\n\n      // Priority 2: Data attributes (test-friendly)\n      const dataAttrs = ['data-testid', 'data-test', 'data-cy', 'data-qa', 'data-automation'];\n      for (const attr of dataAttrs) {\n        const value = element.getAttribute(attr);\n        if (value) {\n          const selector = `[${attr}=\"${value}\"]`;\n          if (!selectors.primary) selectors.primary = selector;\n          selectors.alternatives.push(selector);\n          selectors.reliability[selector] = 0.9;\n        }\n      }\n\n      // Priority 3: ARIA attributes\n      const ariaLabel = element.getAttribute('aria-label');\n      if (ariaLabel) {\n        const selector = `[aria-label=\"${ariaLabel}\"]`;\n        if (!selectors.primary) selectors.primary = selector;\n        selectors.alternatives.push(selector);\n        selectors.reliability[selector] = 0.85;\n      }\n\n      // Priority 4: Name attribute (for form elements)\n      if (element.name) {\n        const selector = `[name=\"${element.name}\"]`;\n        if (!selectors.primary) selectors.primary = selector;\n        selectors.alternatives.push(selector);\n        selectors.reliability[selector] = 0.8;\n      }\n\n      // Priority 5: Class-based selector (stable classes only)\n      if (element.className && typeof element.className === 'string') {\n        const classes = element.className.split(' ')\n          .filter(c => c.trim() && !this.isUnstableClass(c));\n        \n        if (classes.length > 0) {\n          const selector = '.' + classes.join('.');\n          if (!selectors.primary) selectors.primary = selector;\n          selectors.alternatives.push(selector);\n          selectors.reliability[selector] = 0.6;\n        }\n      }\n\n      // Priority 6: Tag + attributes combination\n      const tagSelector = this.buildTagSelector(element);\n      if (!selectors.primary) selectors.primary = tagSelector;\n      selectors.alternatives.push(tagSelector);\n      selectors.reliability[tagSelector] = 0.5;\n\n      // Generate XPath\n      selectors.xpath = this.generateXPath(element);\n      selectors.reliability[selectors.xpath] = 0.7;\n\n      // Generate CSS path\n      selectors.cssPath = this.generateCSSPath(element);\n      selectors.reliability[selectors.cssPath] = 0.4;\n\n      // Remove duplicates\n      selectors.alternatives = [...new Set(selectors.alternatives)];\n\n      return selectors;\n    }\n\n    isUnstableClass(className) {\n      const unstablePatterns = [\n        /^(active|hover|focus|selected|current)$/i,\n        /^(is-|has-)/i,\n        /\\d{4,}/, // Long numbers (likely generated)\n        /^[a-f0-9]{8,}$/i, // Hash-like strings\n        /^css-/i, // CSS-in-JS generated classes\n        /^sc-/i, // Styled-components\n        /^emotion-/i // Emotion CSS\n      ];\n      \n      return unstablePatterns.some(pattern => pattern.test(className));\n    }\n\n    buildTagSelector(element) {\n      let selector = element.tagName.toLowerCase();\n      \n      // Add type for input elements\n      if (element.type) {\n        selector += `[type=\"${element.type}\"]`;\n      }\n      \n      // Add role if present\n      if (element.getAttribute('role')) {\n        selector += `[role=\"${element.getAttribute('role')}\"]`;\n      }\n      \n      return selector;\n    }\n\n    generateXPath(element) {\n      if (element.id) {\n        return `//*[@id=\"${element.id}\"]`;\n      }\n      \n      const parts = [];\n      while (element && element.nodeType === Node.ELEMENT_NODE) {\n        let index = 0;\n        let sibling = element.previousSibling;\n        \n        while (sibling) {\n          if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === element.tagName) {\n            index++;\n          }\n          sibling = sibling.previousSibling;\n        }\n        \n        const tagName = element.tagName.toLowerCase();\n        const part = index > 0 ? `${tagName}[${index + 1}]` : tagName;\n        parts.unshift(part);\n        \n        element = element.parentElement;\n      }\n      \n      return parts.length ? '/' + parts.join('/') : null;\n    }\n\n    generateCSSPath(element) {\n      const names = [];\n      while (element.parentNode) {\n        if (element.id) {\n          names.unshift('#' + element.id);\n          break;\n        } else {\n          let tagName = element.nodeName.toLowerCase();\n          \n          if (element.className && typeof element.className === 'string') {\n            const stableClasses = element.className.split(' ')\n              .filter(c => c.trim() && !this.isUnstableClass(c));\n            if (stableClasses.length > 0) {\n              tagName += '.' + stableClasses.join('.');\n            }\n          }\n          \n          const siblings = Array.from(element.parentNode.children);\n          const sameTagSiblings = siblings.filter(sibling => \n            sibling.nodeName === element.nodeName\n          );\n          \n          if (sameTagSiblings.length > 1) {\n            const index = sameTagSiblings.indexOf(element) + 1;\n            tagName += `:nth-of-type(${index})`;\n          }\n          \n          names.unshift(tagName);\n          element = element.parentNode;\n        }\n      }\n      return names.join(' > ');\n    }\n\n    // Enhanced selector generation with priority-based multi-selector strategy\n    generateEnhancedSelectors(element) {\n      const selectors = {\n        primary: null,\n        alternatives: [],\n        xpath: null,\n        cssPath: null,\n        selectorReliability: {}\n      };\n\n      // Priority 1: ID selector (highest reliability)\n      if (element.id && typeof element.id === 'string' && element.id.trim()) {\n        const idSelector = `#${CSS.escape(element.id)}`;\n        selectors.primary = idSelector;\n        selectors.alternatives.push(idSelector);\n        selectors.selectorReliability[idSelector] = this.testSelectorReliability(idSelector);\n      }\n\n      // Priority 2: Data attributes (test-friendly, high reliability)\n      const dataAttrs = ['data-testid', 'data-test', 'data-cy', 'data-qa', 'data-automation'];\n      for (const attr of dataAttrs) {\n        const value = element.getAttribute(attr);\n        if (value && value.trim()) {\n          const selector = `[${attr}=\"${CSS.escape(value)}\"]`;\n          if (!selectors.primary) selectors.primary = selector;\n          selectors.alternatives.push(selector);\n          selectors.selectorReliability[selector] = this.testSelectorReliability(selector);\n        }\n      }\n\n      // Priority 3: ARIA attributes (accessibility-based, good reliability)\n      const ariaLabel = element.getAttribute('aria-label');\n      if (ariaLabel && ariaLabel.trim()) {\n        const selector = `[aria-label=\"${CSS.escape(ariaLabel)}\"]`;\n        if (!selectors.primary) selectors.primary = selector;\n        selectors.alternatives.push(selector);\n        selectors.selectorReliability[selector] = this.testSelectorReliability(selector);\n      }\n\n      // Priority 4: Name attribute (for form elements)\n      const name = element.getAttribute('name');\n      if (name && name.trim()) {\n        const selector = `[name=\"${CSS.escape(name)}\"]`;\n        if (!selectors.primary) selectors.primary = selector;\n        selectors.alternatives.push(selector);\n        selectors.selectorReliability[selector] = this.testSelectorReliability(selector);\n      }\n\n      // Priority 5: Role + text combination (semantic, medium reliability)\n      const role = element.getAttribute('role');\n      const text = this.getElementText(element);\n      if (role && text && text.length < 50) {\n        // Use contains selector for partial text match\n        const selector = `[role=\"${role}\"]:contains(\"${CSS.escape(text.substring(0, 30))}\")`;\n        selectors.alternatives.push(selector);\n        // Note: :contains is not standard CSS, so lower reliability\n        selectors.selectorReliability[selector] = 0.6;\n      }\n\n      // Priority 6: Class-based selector (stable classes only)\n      if (element.className && typeof element.className === 'string') {\n        const stableClasses = element.className.split(' ')\n          .filter(c => c.trim() && !this.isUnstableClass(c))\n          .slice(0, 3); // Limit to prevent overly complex selectors\n        \n        if (stableClasses.length > 0) {\n          const selector = '.' + stableClasses.map(c => CSS.escape(c)).join('.');\n          if (!selectors.primary) selectors.primary = selector;\n          selectors.alternatives.push(selector);\n          selectors.selectorReliability[selector] = this.testSelectorReliability(selector);\n        }\n      }\n\n      // Priority 7: Tag + attributes combination (fallback)\n      const tagSelector = this.buildEnhancedTagSelector(element);\n      if (!selectors.primary) selectors.primary = tagSelector;\n      selectors.alternatives.push(tagSelector);\n      selectors.selectorReliability[tagSelector] = this.testSelectorReliability(tagSelector);\n\n      // Generate XPath (robust fallback)\n      selectors.xpath = this.generateXPath(element);\n      selectors.selectorReliability[selectors.xpath] = 0.7;\n\n      // Generate full CSS path (last resort)\n      selectors.cssPath = this.generateFullCSSPath(element);\n      selectors.selectorReliability[selectors.cssPath] = 0.4;\n\n      // Remove duplicates and sort by reliability\n      selectors.alternatives = [...new Set(selectors.alternatives)]\n        .sort((a, b) => (selectors.selectorReliability[b] || 0) - (selectors.selectorReliability[a] || 0))\n        .slice(0, 5); // Keep top 5 alternatives\n\n      console.log('Enhanced selectors generated:', {\n        primary: selectors.primary,\n        alternativeCount: selectors.alternatives.length,\n        topReliability: selectors.selectorReliability[selectors.primary],\n        alternatives: selectors.alternatives.map(s => ({\n          selector: s.substring(0, 50) + '...',\n          reliability: selectors.selectorReliability[s]\n        }))\n      });\n\n      return selectors;\n    }\n\n    buildEnhancedTagSelector(element) {\n      let selector = element.tagName.toLowerCase();\n      \n      // Add type for input elements\n      if (element.type) {\n        selector += `[type=\"${CSS.escape(element.type)}\"]`;\n      }\n      \n      // Add role if present\n      const role = element.getAttribute('role');\n      if (role) {\n        selector += `[role=\"${CSS.escape(role)}\"]`;\n      }\n\n      // Add href for links (first 50 chars to avoid overly long selectors)\n      if (element.tagName.toLowerCase() === 'a' && element.href) {\n        const href = element.getAttribute('href');\n        if (href && href.length < 100) {\n          selector += `[href=\"${CSS.escape(href)}\"]`;\n        }\n      }\n\n      // Add value for inputs (but mask sensitive inputs)\n      if (element.tagName.toLowerCase() === 'input' && element.value && !this.isSensitiveInput(element)) {\n        const value = element.value.substring(0, 20); // Limit length\n        selector += `[value=\"${CSS.escape(value)}\"]`;\n      }\n      \n      return selector;\n    }\n\n    generateFullCSSPath(element) {\n      const names = [];\n      let current = element;\n      \n      while (current.parentNode && current !== document.body) {\n        if (current.id) {\n          names.unshift('#' + CSS.escape(current.id));\n          break;\n        } else {\n          let tagName = current.nodeName.toLowerCase();\n          \n          if (current.className && typeof current.className === 'string') {\n            const stableClasses = current.className.split(' ')\n              .filter(c => c.trim() && !this.isUnstableClass(c))\n              .slice(0, 2); // Limit to prevent complexity\n            if (stableClasses.length > 0) {\n              tagName += '.' + stableClasses.map(c => CSS.escape(c)).join('.');\n            }\n          }\n          \n          const siblings = Array.from(current.parentNode.children);\n          const sameTagSiblings = siblings.filter(sibling => \n            sibling.nodeName === current.nodeName\n          );\n          \n          if (sameTagSiblings.length > 1) {\n            const index = sameTagSiblings.indexOf(current) + 1;\n            tagName += `:nth-of-type(${index})`;\n          }\n          \n          names.unshift(tagName);\n          current = current.parentNode;\n        }\n      }\n      return names.join(' > ');\n    }\n\n    // DOM context capture\n    captureDOMContext(element) {\n      const context = {\n        parents: [],\n        siblings: [],\n        children: [],\n        nearbyElements: []\n      };\n\n      // Capture parent hierarchy (up to 5 levels)\n      let parent = element.parentElement;\n      let depth = 0;\n      while (parent && depth < 5) {\n        context.parents.push({\n          tagName: parent.tagName.toLowerCase(),\n          id: parent.id || null,\n          className: this.getStableClasses(parent),\n          role: parent.getAttribute('role'),\n          selector: this.generateMultipleSelectors(parent).primary\n        });\n        parent = parent.parentElement;\n        depth++;\n      }\n\n      // Capture siblings\n      if (element.parentElement) {\n        const siblings = Array.from(element.parentElement.children);\n        const elementIndex = siblings.indexOf(element);\n        \n        for (let i = Math.max(0, elementIndex - 2); i <= Math.min(siblings.length - 1, elementIndex + 2); i++) {\n          if (i !== elementIndex) {\n            const sibling = siblings[i];\n            context.siblings.push({\n              position: i < elementIndex ? 'before' : 'after',\n              distance: Math.abs(i - elementIndex),\n              tagName: sibling.tagName.toLowerCase(),\n              text: this.getElementText(sibling),\n              selector: this.generateMultipleSelectors(sibling).primary\n            });\n          }\n        }\n      }\n\n      // Capture nearby interactive elements\n      context.nearbyElements = this.findNearbyInteractiveElements(element);\n\n      return context;\n    }\n\n    // Enhanced DOM context capture matching reference model (Group 4: Context)\n    captureEnhancedDOMContext(element) {\n      const context = {\n        parentElements: [],\n        siblings: [],\n        nearbyElements: [],\n        pageStructure: this.analyzePageStructure()\n      };\n\n      // Capture parent hierarchy (up to 5 levels) with enhanced data\n      let parent = element.parentElement;\n      let depth = 0;\n      while (parent && depth < 5) {\n        context.parentElements.push({\n          tagName: parent.tagName.toLowerCase(),\n          id: parent.id || null,\n          className: this.getStableClasses(parent),\n          role: parent.getAttribute('role'),\n          selector: this.generateEnhancedSelectors(parent).primary,\n          text: this.getElementTextEnhanced(parent).substring(0, 50),\n          level: depth + 1\n        });\n        parent = parent.parentElement;\n        depth++;\n      }\n\n      // Capture siblings with enhanced data\n      if (element.parentElement) {\n        const siblings = Array.from(element.parentElement.children);\n        const elementIndex = siblings.indexOf(element);\n        \n        // Get 2 siblings before and after (reference model pattern)\n        for (let i = Math.max(0, elementIndex - 2); i <= Math.min(siblings.length - 1, elementIndex + 2); i++) {\n          if (i !== elementIndex) {\n            const sibling = siblings[i];\n            context.siblings.push({\n              position: i < elementIndex ? 'before' : 'after',\n              distance: Math.abs(i - elementIndex),\n              tagName: sibling.tagName.toLowerCase(),\n              text: this.getElementTextEnhanced(sibling).substring(0, 50),\n              selector: this.generateEnhancedSelectors(sibling).primary,\n              isInteractive: this.isInteractiveElement(sibling),\n              boundingBox: this.getBoundingBox(sibling)\n            });\n          }\n        }\n      }\n\n      // Capture nearby clickable elements within 100px radius (reference model spec)\n      context.nearbyElements = this.findNearbyClickableElementsEnhanced(element, 100);\n\n      return context;\n    }\n\n    // Enhanced nearby elements detection matching reference model\n    findNearbyClickableElementsEnhanced(targetElement, radius = 100) {\n      const nearby = [];\n      const targetRect = targetElement.getBoundingClientRect();\n      const targetCenter = {\n        x: targetRect.left + targetRect.width / 2,\n        y: targetRect.top + targetRect.height / 2\n      };\n\n      const interactiveSelectors = 'a, button, input, select, textarea, [role=\"button\"], [onclick], [data-clickable], [tabindex]:not([tabindex=\"-1\"])';\n      const candidates = document.querySelectorAll(interactiveSelectors);\n\n      candidates.forEach(element => {\n        if (element === targetElement) return;\n        \n        const rect = element.getBoundingClientRect();\n        if (rect.width === 0 || rect.height === 0) return;\n        \n        const center = {\n          x: rect.left + rect.width / 2,\n          y: rect.top + rect.height / 2\n        };\n\n        const distance = Math.sqrt(\n          Math.pow(center.x - targetCenter.x, 2) +\n          Math.pow(center.y - targetCenter.y, 2)\n        );\n\n        if (distance <= radius) {\n          nearby.push({\n            selector: this.generateEnhancedSelectors(element).primary,\n            tagName: element.tagName.toLowerCase(),\n            text: this.getElementTextEnhanced(element).substring(0, 30),\n            distance: Math.round(distance),\n            direction: this.getRelativeDirection(targetCenter, center),\n            isVisible: this.isElementVisible(element),\n            isInteractive: this.isInteractiveElement(element)\n          });\n        }\n      });\n\n      // Sort by distance and return closest 10 (reference model spec)\n      return nearby.sort((a, b) => a.distance - b.distance).slice(0, 10);\n    }\n\n    findNearbyInteractiveElements(targetElement, radius = 150) {\n      const nearby = [];\n      const targetRect = targetElement.getBoundingClientRect();\n      const targetCenter = {\n        x: targetRect.left + targetRect.width / 2,\n        y: targetRect.top + targetRect.height / 2\n      };\n\n      const interactiveSelectors = 'a, button, input, select, textarea, [role=\"button\"], [onclick], [tabindex]';\n      const candidates = document.querySelectorAll(interactiveSelectors);\n\n      candidates.forEach(element => {\n        if (element === targetElement) return;\n        \n        const rect = element.getBoundingClientRect();\n        if (rect.width === 0 || rect.height === 0) return;\n        \n        const center = {\n          x: rect.left + rect.width / 2,\n          y: rect.top + rect.height / 2\n        };\n\n        const distance = Math.sqrt(\n          Math.pow(center.x - targetCenter.x, 2) +\n          Math.pow(center.y - targetCenter.y, 2)\n        );\n\n        if (distance <= radius) {\n          nearby.push({\n            selector: this.generateMultipleSelectors(element).primary,\n            tagName: element.tagName.toLowerCase(),\n            text: this.getElementText(element),\n            distance: Math.round(distance),\n            direction: this.getRelativeDirection(targetCenter, center),\n            isVisible: this.isElementVisible(element)\n          });\n        }\n      });\n\n      return nearby.sort((a, b) => a.distance - b.distance).slice(0, 8);\n    }\n\n    // Element analysis\n    analyzeElement(element) {\n      const computed = window.getComputedStyle(element);\n      \n      return {\n        tagName: element.tagName.toLowerCase(),\n        text: this.getElementText(element),\n        value: this.isSensitiveInput(element) ? '[PROTECTED]' : (element.value || null),\n        attributes: this.getRelevantAttributes(element),\n        \n        // Visual properties\n        boundingBox: this.getBoundingBox(element),\n        isVisible: this.isElementVisible(element),\n        isInViewport: this.isElementInViewport(element),\n        \n        // Computed styles (relevant ones)\n        styles: {\n          display: computed.display,\n          visibility: computed.visibility,\n          position: computed.position,\n          zIndex: computed.zIndex,\n          cursor: computed.cursor,\n          backgroundColor: computed.backgroundColor,\n          color: computed.color\n        },\n        \n        // Interaction properties\n        isInteractive: this.isInteractiveElement(element),\n        role: element.getAttribute('role') || this.inferElementRole(element),\n        tabIndex: element.tabIndex\n      };\n    }\n\n    // Enhanced element analysis matching reference model (Group 3: Element)\n    analyzeElementEnhanced(element) {\n      const computed = window.getComputedStyle(element);\n      \n      return {\n        // Basic element properties\n        tagName: element.tagName.toLowerCase(),\n        text: this.getElementTextEnhanced(element),\n        value: this.isSensitiveInput(element) ? '[PROTECTED]' : (element.value || null),\n        attributes: this.getAllElementAttributes(element),\n        \n        // Visual and positioning\n        boundingBox: this.getBoundingBox(element),\n        isVisible: this.isElementVisible(element),\n        isInViewport: this.isElementInViewport(element),\n        percentVisible: this.getElementVisibility(element),\n        \n        // Comprehensive computed styles (matching reference model)\n        computedStyles: {\n          display: computed.display,\n          visibility: computed.visibility,\n          position: computed.position,\n          zIndex: computed.zIndex,\n          width: computed.width,\n          height: computed.height,\n          padding: computed.padding,\n          margin: computed.margin,\n          backgroundColor: computed.backgroundColor,\n          color: computed.color,\n          fontSize: computed.fontSize,\n          cursor: computed.cursor,\n          pointerEvents: computed.pointerEvents,\n          opacity: computed.opacity,\n          transform: computed.transform,\n          transition: computed.transition\n        },\n        \n        // Interaction and accessibility\n        isInteractive: this.isInteractiveElement(element),\n        role: element.getAttribute('role') || this.inferElementRole(element),\n        tabIndex: element.tabIndex,\n        \n        // Additional properties from reference model\n        hasClickHandler: !!(element.onclick || element.getAttribute('onclick')),\n        ariaLabel: element.getAttribute('aria-label'),\n        title: element.title,\n        alt: element.alt,\n        placeholder: element.placeholder\n      };\n    }\n\n    // Enhanced text extraction with fallbacks (matching reference model)\n    getElementTextEnhanced(element) {\n      if (!element) return '';\n      \n      // Get direct text content, not including children\n      const textNodes = [];\n      for (let node of element.childNodes) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          textNodes.push(node.textContent.trim());\n        }\n      }\n      \n      let text = textNodes.join(' ').trim();\n      \n      // Fallback to full text content if no direct text\n      if (!text) {\n        text = element.textContent?.trim() || '';\n      }\n      \n      // Also check common attributes (matching reference model priority)\n      if (!text) {\n        text = element.value || \n               element.placeholder || \n               element.alt || \n               element.title || \n               element.getAttribute('aria-label') || '';\n      }\n      \n      // Limit length to prevent huge payloads\n      return text.length > 100 ? text.substring(0, 100) + '...' : text;\n    }\n\n    // Get all element attributes (comprehensive)\n    getAllElementAttributes(element) {\n      const attrs = {};\n      for (let attr of element.attributes) {\n        attrs[attr.name] = attr.value;\n      }\n      return attrs;\n    }\n\n    // Enhanced element visibility calculation (matching reference model)\n    getElementVisibility(element) {\n      const rect = element.getBoundingClientRect();\n      const viewportHeight = window.innerHeight;\n      const viewportWidth = window.innerWidth;\n      \n      const visibleHeight = Math.min(rect.bottom, viewportHeight) - Math.max(rect.top, 0);\n      const visibleWidth = Math.min(rect.right, viewportWidth) - Math.max(rect.left, 0);\n      \n      const visibleArea = Math.max(0, visibleHeight) * Math.max(0, visibleWidth);\n      const totalArea = rect.height * rect.width;\n      \n      return totalArea > 0 ? Math.round((visibleArea / totalArea) * 100) : 0;\n    }\n\n    getRelevantAttributes(element) {\n      const relevantAttrs = [\n        'id', 'class', 'name', 'type', 'role', 'aria-label', 'aria-describedby',\n        'data-testid', 'data-test', 'data-cy', 'data-qa', 'href', 'src', 'alt', 'title'\n      ];\n      \n      const attrs = {};\n      relevantAttrs.forEach(attr => {\n        const value = element.getAttribute(attr);\n        if (value !== null) {\n          attrs[attr] = value;\n        }\n      });\n      \n      return attrs;\n    }\n\n    // Privacy protection - Comprehensive PII detection\n    isSensitiveInput(element) {\n      if (!element) return false;\n      \n      // Check input type\n      if (element.type && ['password', 'hidden'].includes(element.type.toLowerCase())) {\n        return true;\n      }\n      \n      // Check against sensitive selectors\n      const matchesSensitiveSelector = this.sensitiveSelectors.some(selector => {\n        try {\n          return element.matches(selector);\n        } catch (e) {\n          return false;\n        }\n      });\n      \n      if (matchesSensitiveSelector) return true;\n      \n      // Check element properties for PII indicators\n      const sensitivePatterns = [\n        // Names and personal info\n        /\\b(first[-_\\s]*name|last[-_\\s]*name|full[-_\\s]*name|given[-_\\s]*name|surname|family[-_\\s]*name)\\b/i,\n        \n        // Contact information\n        /\\b(email|e[-_\\s]*mail|phone|mobile|telephone|fax)\\b/i,\n        \n        // Address information\n        /\\b(address|street|city|state|province|zip|postal|country|region)\\b/i,\n        \n        // Financial information\n        /\\b(credit[-_\\s]*card|debit[-_\\s]*card|card[-_\\s]*number|cvv|cvc|security[-_\\s]*code|expiry|expiration|routing|account[-_\\s]*number|iban|swift)\\b/i,\n        \n        // Identification\n        /\\b(ssn|social[-_\\s]*security|passport|license|id[-_\\s]*number|tax[-_\\s]*id)\\b/i,\n        \n        // Personal details\n        /\\b(birth[-_\\s]*date|date[-_\\s]*of[-_\\s]*birth|dob|age|gender|nationality)\\b/i,\n        \n        // Security\n        /\\b(password|pin|secret|security[-_\\s]*question|mother[-_\\s]*maiden)\\b/i\n      ];\n      \n      // Check all element attributes and properties\n      const checkText = [\n        element.name,\n        element.id,\n        element.className,\n        element.placeholder,\n        element.title,\n        element.getAttribute('aria-label'),\n        element.getAttribute('data-testid'),\n        element.getAttribute('autocomplete')\n      ].filter(Boolean).join(' ').toLowerCase();\n      \n      if (sensitivePatterns.some(pattern => pattern.test(checkText))) {\n        return true;\n      }\n      \n      // Check parent labels for sensitive content\n      const label = element.closest('label') || document.querySelector(`label[for=\"${element.id}\"]`);\n      if (label) {\n        const labelText = label.textContent.toLowerCase();\n        if (sensitivePatterns.some(pattern => pattern.test(labelText))) {\n          return true;\n        }\n      }\n      \n      // Check for credit card number patterns in value (basic format check)\n      if (element.value && element.value.length > 0) {\n        // Credit card pattern (4 groups of 4 digits or similar)\n        const ccPattern = /^\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{3,4}$/;\n        const ssnPattern = /^\\d{3}[-\\s]?\\d{2}[-\\s]?\\d{4}$/;\n        const phonePattern = /^[\\+]?[1-9][\\d]{0,2}[\\s-]?\\(?[\\d]{3}\\)?[\\s-]?[\\d]{3}[\\s-]?[\\d]{4}$/;\n        \n        if (ccPattern.test(element.value.replace(/\\s/g, '')) || \n            ssnPattern.test(element.value) || \n            phonePattern.test(element.value)) {\n          return true;\n        }\n      }\n      \n      return false;\n    }\n\n    // Sanitize data to remove any PII that might have been captured\n    sanitizeData(data) {\n      if (!data || typeof data !== 'object') return data;\n      \n      const sanitized = JSON.parse(JSON.stringify(data)); // Deep clone\n      \n      // PII patterns to redact\n      const piiPatterns = [\n        // Credit card numbers (various formats)\n        { pattern: /\\b\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{4}[\\s-]?\\d{3,4}\\b/g, replacement: '[CREDIT_CARD_REDACTED]' },\n        \n        // Social Security Numbers\n        { pattern: /\\b\\d{3}[-\\s]?\\d{2}[-\\s]?\\d{4}\\b/g, replacement: '[SSN_REDACTED]' },\n        \n        // Phone numbers\n        { pattern: /\\b[\\+]?[1-9][\\d]{0,2}[\\s-]?\\(?[\\d]{3}\\)?[\\s-]?[\\d]{3}[\\s-]?[\\d]{4}\\b/g, replacement: '[PHONE_REDACTED]' },\n        \n        // Email addresses\n        { pattern: /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b/g, replacement: '[EMAIL_REDACTED]' },\n        \n        // Zip codes (US format)\n        { pattern: /\\b\\d{5}(-\\d{4})?\\b/g, replacement: '[ZIP_REDACTED]' },\n        \n        // Generic patterns for names in common formats\n        { pattern: /\\b[A-Z][a-z]+ [A-Z][a-z]+\\b/g, replacement: '[NAME_REDACTED]' }\n      ];\n      \n      // Recursively sanitize object\n      const sanitizeValue = (value) => {\n        if (typeof value === 'string') {\n          let sanitizedValue = value;\n          piiPatterns.forEach(({ pattern, replacement }) => {\n            sanitizedValue = sanitizedValue.replace(pattern, replacement);\n          });\n          return sanitizedValue;\n        } else if (Array.isArray(value)) {\n          return value.map(sanitizeValue);\n        } else if (value && typeof value === 'object') {\n          const sanitizedObj = {};\n          for (const [key, val] of Object.entries(value)) {\n            // Skip sensitive keys entirely\n            if (this.isSensitiveKey(key)) {\n              sanitizedObj[key] = '[PII_REDACTED]';\n            } else {\n              sanitizedObj[key] = sanitizeValue(val);\n            }\n          }\n          return sanitizedObj;\n        }\n        return value;\n      };\n      \n      return sanitizeValue(sanitized);\n    }\n\n    // Check if a key name suggests it contains PII\n    isSensitiveKey(key) {\n      if (!key || typeof key !== 'string') return false;\n      \n      const sensitiveKeyPatterns = [\n        /password/i,\n        /email/i,\n        /phone/i,\n        /address/i,\n        /name/i,\n        /credit/i,\n        /card/i,\n        /ssn/i,\n        /social/i,\n        /birth/i,\n        /dob/i,\n        /license/i,\n        /passport/i\n      ];\n      \n      return sensitiveKeyPatterns.some(pattern => pattern.test(key));\n    }\n\n    // Screenshot capture\n    async captureScreenshot(trigger, timestamp = Date.now()) {\n      if (!this.config.screenshotEnabled || this.screenshots.length >= this.config.maxScreenshots) {\n        return null;\n      }\n\n      try {\n        const screenshotData = {\n          trigger,\n          timestamp,\n          viewport: this.getViewportInfo(),\n          url: window.location.href,\n          quality: this.config.screenshotQuality\n        };\n\n        // Send to background script for actual capture\n        const response = await chrome.runtime.sendMessage({\n          action: 'CAPTURE_SCREENSHOT',\n          data: screenshotData\n        });\n\n        if (response && response.success) {\n          const screenshot = {\n            id: response.screenshotId,\n            trigger,\n            timestamp,\n            ...screenshotData\n          };\n          \n          this.screenshots.push(screenshot);\n          return screenshot;\n        }\n      } catch (error) {\n        console.error('Unified: Screenshot capture failed:', error);\n      }\n      \n      return null;\n    }\n\n    // Page structure analysis\n    analyzePageStructure() {\n      return {\n        hasNavigation: !!document.querySelector('nav, [role=\"navigation\"]'),\n        hasSearch: !!document.querySelector('input[type=\"search\"], [role=\"searchbox\"]'),\n        hasFilters: document.querySelectorAll('[class*=\"filter\"], [data-filter]').length > 0,\n        hasProductGrid: !!document.querySelector('[class*=\"grid\"], [class*=\"product\"], [data-products]'),\n        hasShoppingCart: !!document.querySelector('[class*=\"cart\"], [data-cart]'),\n        hasPagination: !!document.querySelector('[class*=\"page\"], [aria-label*=\"page\"]'),\n        \n        // Element counts\n        totalElements: document.querySelectorAll('*').length,\n        interactiveElements: document.querySelectorAll('button, a, input, select, textarea, [role=\"button\"]').length,\n        images: document.querySelectorAll('img').length,\n        forms: document.querySelectorAll('form').length,\n        \n        // Page type detection\n        pageType: this.detectPageType(),\n        \n        // Framework detection\n        framework: this.detectFramework()\n      };\n    }\n\n    detectPageType() {\n      const url = window.location.href.toLowerCase();\n      const title = document.title.toLowerCase();\n      const content = document.body.textContent.toLowerCase();\n      \n      if (url.includes('/cart') || title.includes('cart') || content.includes('shopping cart')) {\n        return 'cart';\n      }\n      if (url.includes('/checkout') || title.includes('checkout')) {\n        return 'checkout';\n      }\n      if (url.includes('/product') || url.includes('/item') || document.querySelector('[itemtype*=\"Product\"]')) {\n        return 'product';\n      }\n      if (url.includes('/search') || url.includes('?q=') || document.querySelector('[role=\"search\"]')) {\n        return 'search';\n      }\n      if (url.includes('/category') || url.includes('/browse')) {\n        return 'category';\n      }\n      \n      return 'other';\n    }\n\n    detectFramework() {\n      const frameworks = [];\n      \n      if (window.React || document.querySelector('[data-reactroot]')) {\n        frameworks.push('React');\n      }\n      if (window.Vue || document.querySelector('[data-v-]')) {\n        frameworks.push('Vue');\n      }\n      if (window.angular || document.querySelector('[ng-app], [data-ng-app]')) {\n        frameworks.push('Angular');\n      }\n      if (window.jQuery || window.$) {\n        frameworks.push('jQuery');\n      }\n      \n      return frameworks;\n    }\n\n    // Navigation handling\n    setupNavigationHandling() {\n      // URL change detection\n      let lastUrl = window.location.href;\n      \n      const checkUrlChange = () => {\n        if (this.isTracking && window.location.href !== lastUrl) {\n          this.handleNavigation(lastUrl, window.location.href);\n          lastUrl = window.location.href;\n        }\n      };\n      \n      // Check every second\n      this.navigationInterval = setInterval(checkUrlChange, 1000);\n      \n      // Also listen for popstate\n      this.popstateHandler = () => {\n        if (this.isTracking) {\n          setTimeout(checkUrlChange, 100);\n        }\n      };\n      window.addEventListener('popstate', this.popstateHandler);\n    }\n    \n    cleanupNavigationHandling() {\n      if (this.navigationInterval) {\n        clearInterval(this.navigationInterval);\n        this.navigationInterval = null;\n      }\n      \n      if (this.popstateHandler) {\n        window.removeEventListener('popstate', this.popstateHandler);\n        this.popstateHandler = null;\n      }\n    }\n\n    async handleNavigation(fromUrl, toUrl) {\n      const timestamp = Date.now();\n      \n      // Capture navigation screenshot burst\n      if (this.config.burstModeEnabled) {\n        this.startBurstMode('navigation');\n      }\n      \n      // Update page structure\n      setTimeout(() => {\n        this.pageStructure = this.analyzePageStructure();\n      }, 1000);\n      \n      const navigationData = {\n        type: 'NAVIGATION',\n        timestamp,\n        sessionTime: timestamp - this.startTime,\n        sequence: ++this.interactionSequence,\n        \n        fromUrl,\n        toUrl,\n        pageTitle: document.title,\n        \n        // Navigation type detection\n        navigationType: this.detectNavigationType(fromUrl, toUrl),\n        \n        // Page structure will be updated after delay\n        pageStructure: this.pageStructure\n      };\n\n      this.captureEvent(navigationData);\n    }\n\n    detectNavigationType(fromUrl, toUrl) {\n      if (fromUrl === toUrl) return 'refresh';\n      if (toUrl.includes('#')) return 'hash_change';\n      if (new URL(fromUrl).pathname === new URL(toUrl).pathname) return 'query_change';\n      return 'page_change';\n    }\n\n    startBurstMode(trigger) {\n      const burstCount = trigger === 'navigation' ? 3 : 5;\n      const interval = 500; // 500ms between shots\n      \n      for (let i = 0; i < burstCount; i++) {\n        setTimeout(() => {\n          if (this.isTracking) {\n            this.captureScreenshot(`burst_${trigger}_${i + 1}`);\n          }\n        }, i * interval);\n      }\n    }\n\n    // Utility methods\n    captureEvent(eventData) {\n      if (this.events.length >= this.config.maxEvents) {\n        console.warn('Unified: Max events reached, dropping oldest');\n        this.events.shift();\n      }\n      \n      // Sanitize event data to remove any PII before storing\n      const sanitizedEventData = this.sanitizeData(eventData);\n      \n      this.events.push({\n        ...sanitizedEventData,\n        id: this.generateId(),\n        sessionId: this.sessionId\n      });\n      \n      // Task progress is tracked naturally through user interactions\n      \n      // Send to background script for processing\n      this.sendEventToBackground(eventData);\n      \n      // 🆕 Collect interaction data for session download\n      this.collectInteractionForDownload(eventData);\n      \n      // Save state\n      this.saveState();\n      \n      // Periodic cleanup to prevent memory issues\n      if (this.events.length > this.config.maxEvents / 2) {\n        this.performEventCleanup();\n      }\n    }\n    \n    performEventCleanup() {\n      const now = Date.now();\n      const maxAge = 30 * 60 * 1000; // 30 minutes\n      \n      // Remove very old events\n      this.events = this.events.filter(event => {\n        return (now - event.timestamp) < maxAge;\n      });\n      \n      // If still too many, keep only the most recent\n      if (this.events.length > this.config.maxEvents) {\n        this.events = this.events.slice(-this.config.maxEvents);\n      }\n    }\n\n    updateEvent(eventData) {\n      const index = this.events.findIndex(e => e.id === eventData.id);\n      if (index !== -1) {\n        this.events[index] = { ...this.events[index], ...eventData };\n        this.saveState();\n      }\n    }\n\n    // 🆕 Collect interaction data for session download\n    collectInteractionForDownload(eventData) {\n      if (!this.downloadData) {\n        this.downloadData = {\n          session: {\n            sessionId: this.sessionId,\n            startTime: this.startTime,\n            url: window.location.href,\n            userAgent: navigator.userAgent\n          },\n          interactions: [],\n          summary: {\n            totalInteractions: 0,\n            priceInteractions: 0,\n            productInteractions: 0,\n            totalPricesFound: 0\n          }\n        };\n      }\n\n      // Add interaction to download collection\n      this.downloadData.interactions.push({\n        timestamp: eventData.timestamp,\n        type: eventData.type,\n        element: {\n          tag: eventData.element?.tagName,\n          text: eventData.element?.text,\n          selector: eventData.selectors?.primary\n        },\n        priceData: eventData.priceData,\n        nearbyElements: eventData.contextData?.nearestClickable,\n        fullData: eventData // Include complete data for detailed analysis\n      });\n\n      // Update summary\n      this.downloadData.summary.totalInteractions++;\n      if (eventData.priceData) {\n        this.downloadData.summary.priceInteractions++;\n        this.downloadData.summary.totalPricesFound += \n          (eventData.priceData.clickedElementPrices?.length || 0) + \n          (eventData.priceData.nearbyPrices?.length || 0);\n      }\n      if (eventData.priceData?.productInfo?.name) {\n        this.downloadData.summary.productInteractions++;\n      }\n    }\n\n    // 🆕 Download all session data when tracking stops\n    async downloadSessionData() {\n      try {\n        if (!this.downloadData || this.downloadData.interactions.length === 0) {\n          console.log('📥 No interaction data to download');\n          return;\n        }\n\n        // Finalize session data\n        this.downloadData.session.endTime = Date.now();\n        this.downloadData.session.duration = this.downloadData.session.endTime - this.downloadData.session.startTime;\n        this.downloadData.session.finalUrl = window.location.href;\n\n        // Create comprehensive download package\n        const downloadPackage = {\n          metadata: {\n            extensionVersion: '2.0.0',\n            downloadTime: new Date().toISOString(),\n            phaseEnhancements: ['Phase 1: Expanded nearby elements', 'Phase 2: Price data extraction']\n          },\n          ...this.downloadData,\n          analytics: this.generateSessionAnalytics()\n        };\n\n        // Create and download the file\n        const blob = new Blob([JSON.stringify(downloadPackage, null, 2)], { type: 'application/json' });\n        const url = URL.createObjectURL(blob);\n        \n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `codesight-session-${this.sessionId}-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n\n        console.log('📥 DOWNLOADED SESSION DATA:', {\n          filename: a.download,\n          totalInteractions: this.downloadData.summary.totalInteractions,\n          priceInteractions: this.downloadData.summary.priceInteractions,\n          productInteractions: this.downloadData.summary.productInteractions,\n          totalPricesFound: this.downloadData.summary.totalPricesFound,\n          fileSize: `${Math.round(blob.size / 1024)}KB`\n        });\n\n        // Clear download data\n        this.downloadData = null;\n\n      } catch (error) {\n        console.error('Failed to download session data:', error);\n      }\n    }\n\n    // Generate analytics summary for the session\n    generateSessionAnalytics() {\n      if (!this.downloadData) return {};\n\n      const interactions = this.downloadData.interactions;\n      \n      return {\n        clicksWithPrices: interactions.filter(i => i.type === 'CLICK' && i.priceData?.clickedElementPrices?.length > 0).length,\n        averageNearbyElements: Math.round(\n          interactions.reduce((sum, i) => sum + (i.nearbyElements?.length || 0), 0) / interactions.length\n        ),\n        productPagesVisited: new Set(\n          interactions\n            .filter(i => i.priceData?.context?.pageType === 'product')\n            .map(i => i.priceData?.productInfo?.name)\n            .filter(Boolean)\n        ).size,\n        currenciesFound: new Set(\n          interactions\n            .flatMap(i => i.priceData?.clickedElementPrices || [])\n            .map(p => p.currency)\n            .filter(Boolean)\n        ),\n        topElements: interactions\n          .filter(i => i.nearbyElements?.length > 0)\n          .map(i => i.nearbyElements.filter(el => el.qualityScore?.score > 70))\n          .flat()\n          .slice(0, 5)\n          .map(el => ({\n            text: el.text?.substring(0, 30),\n            score: el.qualityScore?.score,\n            category: el.elementCategory?.type\n          }))\n      };\n    }\n\n    async sendEventToBackground(eventData) {\n      try {\n        console.log('Unified: Sending event to background:', eventData.type);\n        const response = await chrome.runtime.sendMessage({\n          action: 'SEND_DATA',\n          data: eventData\n        });\n        console.log('Unified: Background response:', response);\n      } catch (error) {\n        console.error('Unified: Failed to send event to background:', error);\n        \n        // If background script is not ready, try to wake it up\n        if (error.message.includes('Could not establish connection')) {\n          console.log('Unified: Background script disconnected, attempting to reconnect...');\n          setTimeout(() => {\n            this.sendEventToBackground(eventData);\n          }, 1000);\n        }\n      }\n    }\n\n    async startBackendSession() {\n      try {\n        console.log('Unified: Starting backend session:', this.sessionId);\n        const response = await chrome.runtime.sendMessage({\n          action: 'START_BACKEND_SESSION',\n          sessionId: this.sessionId,\n          generatedTask: this.currentTask,\n          config: {\n            type: 'AUTOMATED',\n            url: window.location.href,\n            userAgent: navigator.userAgent,\n            timestamp: Date.now()\n          }\n        });\n        console.log('Unified: Backend session started:', response);\n      } catch (error) {\n        console.error('Unified: Failed to start backend session:', error);\n      }\n    }\n\n    async stopBackendSession() {\n      try {\n        console.log('Unified: Stopping backend session:', this.sessionId);\n        const response = await chrome.runtime.sendMessage({\n          action: 'STOP_BACKEND_SESSION',\n          sessionId: this.sessionId\n        });\n        console.log('Unified: Backend session stopped:', response);\n      } catch (error) {\n        console.error('Unified: Failed to stop backend session:', error);\n      }\n    }\n\n    // Page state capture\n    capturePageState() {\n      return {\n        url: window.location.href,\n        title: document.title,\n        scrollPosition: {\n          x: window.scrollX,\n          y: window.scrollY\n        },\n        viewport: this.getViewportInfo(),\n        activeElement: this.getActiveElementInfo(),\n        visibleElements: this.getVisibleElementsCount(),\n        timestamp: Date.now()\n      };\n    }\n\n    detectStateChanges(stateBefore, stateAfter) {\n      const changes = {};\n      \n      // Enhanced URL change detection (matching reference model)\n      if (stateBefore.url !== stateAfter.url) {\n        changes.urlChanged = {\n          from: stateBefore.url,\n          to: stateAfter.url,\n          type: this.detectNavigationType(stateBefore.url, stateAfter.url)\n        };\n        // Backward compatibility\n        changes.newUrl = stateAfter.url;\n      }\n      \n      // Enhanced title change detection  \n      if (stateBefore.title !== stateAfter.title) {\n        changes.titleChanged = {\n          from: stateBefore.title,\n          to: stateAfter.title\n        };\n        // Backward compatibility\n        changes.newTitle = stateAfter.title;\n      }\n      \n      // Enhanced scroll change detection (matching reference model)  \n      const scrollDiff = {\n        x: Math.abs(stateAfter.scrollPosition.x - stateBefore.scrollPosition.x),\n        y: Math.abs(stateAfter.scrollPosition.y - stateBefore.scrollPosition.y)\n      };\n      \n      if (scrollDiff.x > 10 || scrollDiff.y > 10) {\n        changes.scrollChanged = {\n          from: stateBefore.scrollPosition.y,\n          to: stateAfter.scrollPosition.y,\n          delta: stateAfter.scrollPosition.y - stateBefore.scrollPosition.y,\n          direction: stateAfter.scrollPosition.y > stateBefore.scrollPosition.y ? 'down' : 'up'\n        };\n        // Backward compatibility\n        changes.scrollDiff = scrollDiff;\n      }\n      \n      if (stateBefore.visibleElements !== stateAfter.visibleElements) {\n        changes.elementsChanged = true;\n        changes.elementDiff = stateAfter.visibleElements - stateBefore.visibleElements;\n      }\n      \n      return changes;\n    }\n\n    getActiveElementInfo() {\n      const activeElement = document.activeElement;\n      if (!activeElement || activeElement === document.body) {\n        return null;\n      }\n      \n      return {\n        tagName: activeElement.tagName.toLowerCase(),\n        id: activeElement.id || null,\n        className: activeElement.className || null,\n        selector: this.generateMultipleSelectors(activeElement).primary\n      };\n    }\n\n    getVisibleElementsCount() {\n      const elements = document.querySelectorAll('*');\n      let visibleCount = 0;\n      \n      for (const element of elements) {\n        if (this.isElementVisible(element)) {\n          visibleCount++;\n        }\n      }\n      \n      return visibleCount;\n    }\n\n    // Utility methods\n    getViewportInfo() {\n      return {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        scrollX: window.scrollX,\n        scrollY: window.scrollY,\n        devicePixelRatio: window.devicePixelRatio || 1\n      };\n    }\n\n    getBoundingBox(element) {\n      const rect = element.getBoundingClientRect();\n      return {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left\n      };\n    }\n\n    isElementVisible(element) {\n      if (!element) return false;\n      \n      const rect = element.getBoundingClientRect();\n      if (rect.width === 0 || rect.height === 0) return false;\n      \n      const style = window.getComputedStyle(element);\n      if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {\n        return false;\n      }\n      \n      return true;\n    }\n\n    isElementInViewport(element) {\n      const rect = element.getBoundingClientRect();\n      return (\n        rect.top >= 0 &&\n        rect.left >= 0 &&\n        rect.bottom <= window.innerHeight &&\n        rect.right <= window.innerWidth\n      );\n    }\n\n    isInteractiveElement(element) {\n      const interactiveTags = ['a', 'button', 'input', 'select', 'textarea'];\n      const interactiveRoles = ['button', 'link', 'menuitem', 'tab'];\n      \n      if (interactiveTags.includes(element.tagName.toLowerCase())) {\n        return true;\n      }\n      \n      const role = element.getAttribute('role');\n      if (role && interactiveRoles.includes(role.toLowerCase())) {\n        return true;\n      }\n      \n      if (element.hasAttribute('onclick') || element.hasAttribute('tabindex')) {\n        return true;\n      }\n      \n      return false;\n    }\n\n    inferElementRole(element) {\n      const tagName = element.tagName.toLowerCase();\n      \n      const roleMap = {\n        'a': 'link',\n        'button': 'button',\n        'input': 'textbox',\n        'select': 'combobox',\n        'textarea': 'textbox',\n        'img': 'image',\n        'nav': 'navigation',\n        'main': 'main',\n        'header': 'banner',\n        'footer': 'contentinfo',\n        'aside': 'complementary'\n      };\n      \n      return roleMap[tagName] || 'generic';\n    }\n\n    getElementText(element) {\n      if (!element) return '';\n      \n      // For input elements, get placeholder or value\n      if (element.tagName.toLowerCase() === 'input') {\n        return element.placeholder || element.value || '';\n      }\n      \n      // Get text content, but limit length\n      const text = element.textContent || element.innerText || '';\n      return text.trim().substring(0, 200);\n    }\n\n    getStableClasses(element) {\n      if (!element.className || typeof element.className !== 'string') {\n        return '';\n      }\n      \n      return element.className.split(' ')\n        .filter(c => c.trim() && !this.isUnstableClass(c))\n        .join(' ');\n    }\n\n    getRelativeDirection(center1, center2) {\n      const dx = center2.x - center1.x;\n      const dy = center2.y - center1.y;\n      \n      if (Math.abs(dx) > Math.abs(dy)) {\n        return dx > 0 ? 'right' : 'left';\n      } else {\n        return dy > 0 ? 'below' : 'above';\n      }\n    }\n\n    // State management\n    saveState() {\n      if (!this.sessionId) return;\n      \n      const state = {\n        sessionId: this.sessionId,\n        isTracking: this.isTracking,\n        startTime: this.startTime,\n        eventCount: this.events.length,\n        screenshotCount: this.screenshots.length,\n        currentTask: this.currentTask,\n        taskProgress: this.taskProgress,\n        lastSaved: Date.now()\n      };\n      \n      try {\n        localStorage.setItem('unified_codesight_state', JSON.stringify(state));\n      } catch (error) {\n        console.error('Unified: Failed to save state:', error);\n      }\n    }\n\n    restoreState() {\n      try {\n        const stateStr = localStorage.getItem('unified_codesight_state');\n        if (!stateStr) return;\n        \n        const state = JSON.parse(stateStr);\n        \n        // Only restore if recent (within 1 hour)\n        if (Date.now() - state.lastSaved < 60 * 60 * 1000) {\n          this.sessionId = state.sessionId;\n          this.isTracking = state.isTracking;\n          this.startTime = state.startTime;\n          this.currentTask = state.currentTask;\n          this.taskProgress = state.taskProgress || { currentStep: 0, completedSteps: [] };\n          \n          // Initialize arrays if not already initialized\n          if (!this.events) this.events = [];\n          if (!this.screenshots) this.screenshots = [];\n          \n          // Restore approximate counts (actual events are sent to backend)\n          this.restoredEventCount = state.eventCount || 0;\n          this.restoredScreenshotCount = state.screenshotCount || 0;\n          \n          if (this.isTracking) {\n            console.log('Unified: Restored tracking state for session:', this.sessionId);\n            \n            // Re-initialize tracking components after state restoration\n            this.bindEventListeners();\n            this.showTrackingIndicator();\n            \n            // Re-establish backend connection if needed\n            this.sendEventToBackground({\n              type: 'navigation_restored',\n              sessionId: this.sessionId,\n              url: window.location.href,\n              timestamp: Date.now()\n            });\n            \n            // Start periodic validation to ensure connection remains active\n            this.startPeriodicValidation();\n          }\n        }\n      } catch (error) {\n        console.error('Unified: Failed to restore state:', error);\n      }\n    }\n\n    clearState() {\n      try {\n        localStorage.removeItem('unified_codesight_state');\n      } catch (error) {\n        console.error('Unified: Failed to clear state:', error);\n      }\n    }\n\n    setupPeriodicStateSaving() {\n      // Save state every 2 seconds when tracking to handle navigation\n      this.stateSaveInterval = setInterval(() => {\n        if (this.isTracking) {\n          this.saveState();\n        }\n      }, 2000);\n    }\n\n    // Session data preparation\n    async prepareSessionData() {\n      const sessionData = {\n        sessionId: this.sessionId,\n        startTime: this.startTime,\n        endTime: Date.now(),\n        duration: Date.now() - this.startTime,\n        \n        // Event data\n        events: this.events,\n        eventCount: this.events.length,\n        \n        // Screenshot data\n        screenshots: this.screenshots,\n        screenshotCount: this.screenshots.length,\n        \n        // Page data\n        initialUrl: this.currentUrl,\n        finalUrl: window.location.href,\n        pageStructure: this.pageStructure,\n        \n        // Browser data\n        userAgent: navigator.userAgent,\n        viewport: this.getViewportInfo(),\n        \n        // Quality metrics\n        qualityScore: this.calculateQualityScore(),\n        completeness: this.calculateCompleteness()\n      };\n      \n      return sessionData;\n    }\n\n    calculateQualityScore() {\n      let score = 0;\n      \n      // Base score for having events\n      if (this.events.length > 0) score += 20;\n      \n      // Bonus for variety of event types\n      const eventTypes = new Set(this.events.map(e => e.type));\n      score += Math.min(eventTypes.size * 10, 30);\n      \n      // Bonus for screenshots\n      if (this.screenshots.length > 0) score += 20;\n      \n      // Bonus for session duration (sweet spot: 30s - 5min)\n      const duration = Date.now() - this.startTime;\n      const durationMinutes = duration / (1000 * 60);\n      if (durationMinutes >= 0.5 && durationMinutes <= 5) {\n        score += 20;\n      } else if (durationMinutes > 5) {\n        score += 10;\n      }\n      \n      // Bonus for interaction variety\n      const clickEvents = this.events.filter(e => e.type === 'CLICK').length;\n      const inputEvents = this.events.filter(e => e.type === 'INPUT').length;\n      const navEvents = this.events.filter(e => e.type === 'NAVIGATION').length;\n      \n      if (clickEvents > 0 && inputEvents > 0) score += 10;\n      if (navEvents > 0) score += 10;\n      \n      return Math.min(score, 100);\n    }\n\n    calculateCompleteness() {\n      let completeness = 0;\n      \n      // Check for essential data\n      if (this.events.length > 0) completeness += 25;\n      if (this.screenshots.length > 0) completeness += 25;\n      if (this.pageStructure) completeness += 25;\n      \n      // Check for interaction completeness\n      const hasClicks = this.events.some(e => e.type === 'CLICK');\n      const hasNavigation = this.events.some(e => e.type === 'NAVIGATION');\n      \n      if (hasClicks) completeness += 12.5;\n      if (hasNavigation) completeness += 12.5;\n      \n      return Math.min(completeness, 100);\n    }\n\n    // Data Quality Validation System\n    validateSessionData() {\n      const validation = {\n        isValid: true,\n        score: 100,\n        errors: [],\n        warnings: [],\n        suggestions: [],\n        metrics: {}\n      };\n\n      // Validate basic session data\n      this.validateBasicSessionData(validation);\n      \n      // Validate events\n      this.validateEvents(validation);\n      \n      // Validate screenshots\n      this.validateScreenshots(validation);\n      \n      // Validate interaction patterns\n      this.validateInteractionPatterns(validation);\n      \n      // Validate data completeness\n      this.validateDataCompleteness(validation);\n      \n      // Calculate final validation score\n      validation.score = Math.max(0, validation.score - (validation.errors.length * 10) - (validation.warnings.length * 5));\n      validation.isValid = validation.score >= 60 && validation.errors.length === 0;\n      \n      return validation;\n    }\n\n    validateBasicSessionData(validation) {\n      // Check session ID\n      if (!this.sessionId) {\n        validation.errors.push('Missing session ID');\n        validation.score -= 20;\n      }\n\n      // Check session duration\n      const duration = Date.now() - this.startTime;\n      if (duration < 10000) { // Less than 10 seconds\n        validation.warnings.push('Session duration is very short (< 10s)');\n        validation.suggestions.push('Consider longer interaction sessions for better training data');\n      } else if (duration > 30 * 60 * 1000) { // More than 30 minutes\n        validation.warnings.push('Session duration is very long (> 30min)');\n        validation.suggestions.push('Consider breaking long sessions into smaller chunks');\n      }\n\n      validation.metrics.sessionDuration = duration;\n      validation.metrics.sessionDurationMinutes = Math.round(duration / 60000);\n    }\n\n    validateEvents(validation) {\n      if (this.events.length === 0) {\n        validation.errors.push('No interaction events captured');\n        validation.score -= 30;\n        return;\n      }\n\n      let validEvents = 0;\n      let invalidEvents = 0;\n      const eventTypes = new Set();\n      const missingSelectors = [];\n      const missingTimestamps = [];\n\n      this.events.forEach((event, index) => {\n        let eventValid = true;\n\n        // Check required fields\n        if (!event.type) {\n          validation.errors.push(`Event ${index}: Missing event type`);\n          eventValid = false;\n        } else {\n          eventTypes.add(event.type);\n        }\n\n        if (!event.timestamp) {\n          validation.errors.push(`Event ${index}: Missing timestamp`);\n          missingTimestamps.push(index);\n          eventValid = false;\n        }\n\n        // Validate selectors for click events\n        if (event.type === 'CLICK') {\n          if (!event.selectors || !event.selectors.primary) {\n            validation.warnings.push(`Click event ${index}: Missing primary selector`);\n            missingSelectors.push(index);\n          } else {\n            // Test selector reliability\n            const reliability = this.testSelectorReliability(event.selectors.primary);\n            if (reliability < 0.5) {\n              validation.warnings.push(`Click event ${index}: Low selector reliability (${Math.round(reliability * 100)}%)`);\n            }\n          }\n\n          // Check for coordinates\n          if (!event.coordinates) {\n            validation.warnings.push(`Click event ${index}: Missing click coordinates`);\n          }\n        }\n\n        // Validate URL\n        if (!event.url) {\n          validation.warnings.push(`Event ${index}: Missing URL`);\n        }\n\n        if (eventValid) {\n          validEvents++;\n        } else {\n          invalidEvents++;\n        }\n      });\n\n      // Event diversity check\n      if (eventTypes.size < 2) {\n        validation.warnings.push('Low event type diversity - consider capturing more interaction types');\n        validation.suggestions.push('Try to include clicks, inputs, navigation, and scrolling');\n      }\n\n      // Check for suspicious patterns\n      this.detectSuspiciousPatterns(validation);\n\n      validation.metrics.totalEvents = this.events.length;\n      validation.metrics.validEvents = validEvents;\n      validation.metrics.invalidEvents = invalidEvents;\n      validation.metrics.eventTypes = Array.from(eventTypes);\n      validation.metrics.eventTypeCount = eventTypes.size;\n      validation.metrics.missingSelectors = missingSelectors.length;\n      validation.metrics.missingTimestamps = missingTimestamps.length;\n    }\n\n    validateScreenshots(validation) {\n      if (this.screenshots.length === 0) {\n        validation.warnings.push('No screenshots captured');\n        validation.suggestions.push('Screenshots provide valuable visual context for training');\n        validation.score -= 10;\n      } else {\n        let validScreenshots = 0;\n        let corruptedScreenshots = 0;\n\n        this.screenshots.forEach((screenshot, index) => {\n          if (!screenshot.dataUrl || !screenshot.dataUrl.startsWith('data:image/')) {\n            validation.errors.push(`Screenshot ${index}: Invalid or missing image data`);\n            corruptedScreenshots++;\n          } else {\n            validScreenshots++;\n          }\n\n          if (!screenshot.timestamp) {\n            validation.warnings.push(`Screenshot ${index}: Missing timestamp`);\n          }\n\n          if (!screenshot.trigger) {\n            validation.warnings.push(`Screenshot ${index}: Missing trigger information`);\n          }\n        });\n\n        // Check screenshot frequency\n        const duration = Date.now() - this.startTime;\n        const screenshotRate = this.screenshots.length / (duration / 1000);\n        \n        if (screenshotRate > 2) { // More than 2 per second\n          validation.warnings.push('Very high screenshot capture rate - may impact performance');\n        } else if (screenshotRate < 0.1) { // Less than 1 per 10 seconds\n          validation.warnings.push('Low screenshot capture rate - may miss important visual changes');\n        }\n\n        validation.metrics.totalScreenshots = this.screenshots.length;\n        validation.metrics.validScreenshots = validScreenshots;\n        validation.metrics.corruptedScreenshots = corruptedScreenshots;\n        validation.metrics.screenshotRate = screenshotRate;\n      }\n    }\n\n    validateInteractionPatterns(validation) {\n      const clickEvents = this.events.filter(e => e.type === 'CLICK');\n      const inputEvents = this.events.filter(e => e.type === 'INPUT');\n      const navEvents = this.events.filter(e => e.type === 'NAVIGATION');\n      const scrollEvents = this.events.filter(e => e.type === 'SCROLL');\n\n      // Check for realistic interaction patterns\n      if (clickEvents.length === 0) {\n        validation.warnings.push('No click interactions captured');\n        validation.suggestions.push('Click interactions are essential for shopping behavior training');\n      }\n\n      // Check interaction timing\n      if (clickEvents.length > 1) {\n        const intervals = [];\n        for (let i = 1; i < clickEvents.length; i++) {\n          intervals.push(clickEvents[i].timestamp - clickEvents[i-1].timestamp);\n        }\n        \n        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;\n        const minInterval = Math.min(...intervals);\n        \n        if (minInterval < 100) { // Less than 100ms between clicks\n          validation.warnings.push('Suspiciously fast clicking detected - may indicate automated behavior');\n        }\n        \n        if (avgInterval < 500) { // Average less than 500ms\n          validation.warnings.push('Very rapid clicking pattern - may not represent natural human behavior');\n        }\n\n        validation.metrics.averageClickInterval = avgInterval;\n        validation.metrics.minimumClickInterval = minInterval;\n      }\n\n      // Check for shopping-specific patterns\n      this.validateShoppingPatterns(validation);\n\n      validation.metrics.clickCount = clickEvents.length;\n      validation.metrics.inputCount = inputEvents.length;\n      validation.metrics.navigationCount = navEvents.length;\n      validation.metrics.scrollCount = scrollEvents.length;\n    }\n\n    validateShoppingPatterns(validation) {\n      const urls = this.events.map(e => e.url).filter(Boolean);\n      const uniqueUrls = new Set(urls);\n      \n      // Check for shopping-related URLs\n      const shoppingKeywords = ['product', 'item', 'cart', 'checkout', 'buy', 'shop', 'category', 'search'];\n      const hasShoppingUrls = urls.some(url => \n        shoppingKeywords.some(keyword => url.toLowerCase().includes(keyword))\n      );\n\n      if (!hasShoppingUrls) {\n        validation.warnings.push('No shopping-related URLs detected');\n        validation.suggestions.push('Ensure interactions occur on e-commerce pages for relevant training data');\n      }\n\n      // Check for product interaction patterns\n      const productViews = this.events.filter(e => \n        e.url && e.url.toLowerCase().includes('product')\n      ).length;\n\n      const cartActions = this.events.filter(e => \n        e.elementText && e.elementText.toLowerCase().includes('cart')\n      ).length;\n\n      if (productViews === 0) {\n        validation.warnings.push('No product page interactions detected');\n      }\n\n      if (cartActions === 0) {\n        validation.suggestions.push('Consider including cart interactions for complete shopping behavior');\n      }\n\n      validation.metrics.uniqueUrls = uniqueUrls.size;\n      validation.metrics.productViews = productViews;\n      validation.metrics.cartActions = cartActions;\n      validation.metrics.hasShoppingUrls = hasShoppingUrls;\n    }\n\n    validateDataCompleteness(validation) {\n      const completeness = this.calculateCompleteness();\n      \n      if (completeness < 50) {\n        validation.errors.push('Data completeness is too low for quality training');\n        validation.score -= 20;\n      } else if (completeness < 75) {\n        validation.warnings.push('Data completeness could be improved');\n        validation.suggestions.push('Try to capture more diverse interactions and screenshots');\n      }\n\n      // Check for missing critical data\n      const criticalMissing = [];\n      \n      if (this.events.length === 0) criticalMissing.push('interaction events');\n      if (this.screenshots.length === 0) criticalMissing.push('screenshots');\n      if (!this.pageStructure) criticalMissing.push('page structure analysis');\n\n      if (criticalMissing.length > 0) {\n        validation.errors.push(`Missing critical data: ${criticalMissing.join(', ')}`);\n      }\n\n      validation.metrics.completeness = completeness;\n      validation.metrics.criticalMissing = criticalMissing;\n    }\n\n    detectSuspiciousPatterns(validation) {\n      // Check for bot-like behavior patterns\n      const clickEvents = this.events.filter(e => e.type === 'CLICK');\n      \n      if (clickEvents.length > 0) {\n        // Check for identical coordinates (bot-like)\n        const coordinates = clickEvents.map(e => `${e.coordinates?.clientX},${e.coordinates?.clientY}`);\n        const uniqueCoordinates = new Set(coordinates);\n        \n        if (coordinates.length > 3 && uniqueCoordinates.size === 1) {\n          validation.warnings.push('Identical click coordinates detected - may indicate automated behavior');\n        }\n\n        // Check for perfect timing patterns\n        const intervals = [];\n        for (let i = 1; i < clickEvents.length; i++) {\n          intervals.push(clickEvents[i].timestamp - clickEvents[i-1].timestamp);\n        }\n        \n        if (intervals.length > 2) {\n          const variance = this.calculateVariance(intervals);\n          if (variance < 100) { // Very low variance in timing\n            validation.warnings.push('Suspiciously consistent timing pattern detected');\n          }\n        }\n      }\n\n      // Check for missing human-like variations\n      const hasScrolling = this.events.some(e => e.type === 'SCROLL');\n      const hasMouseMovement = this.events.some(e => e.coordinates);\n      \n      if (!hasScrolling && this.events.length > 5) {\n        validation.suggestions.push('Consider including scrolling behavior for more natural interaction patterns');\n      }\n    }\n\n    testSelectorReliability(selector) {\n      try {\n        const elements = document.querySelectorAll(selector);\n        if (elements.length === 0) return 0; // Selector doesn't match anything\n        if (elements.length === 1) return 1; // Perfect match\n        if (elements.length <= 3) return 0.8; // Good match\n        if (elements.length <= 10) return 0.6; // Okay match\n        return 0.3; // Poor match (too many elements)\n      } catch (error) {\n        return 0; // Invalid selector\n      }\n    }\n\n    calculateVariance(numbers) {\n      const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;\n      const squaredDiffs = numbers.map(n => Math.pow(n - mean, 2));\n      return squaredDiffs.reduce((a, b) => a + b, 0) / numbers.length;\n    }\n\n    // Real-time validation feedback\n    showValidationFeedback(validation) {\n      // Remove existing feedback\n      const existingFeedback = document.getElementById('unified-validation-feedback');\n      if (existingFeedback) {\n        existingFeedback.remove();\n      }\n\n      // Only show if there are issues\n      if (validation.errors.length === 0 && validation.warnings.length === 0) {\n        return;\n      }\n\n      const feedback = document.createElement('div');\n      feedback.id = 'unified-validation-feedback';\n      feedback.innerHTML = `\n        <div style=\"\n          position: fixed;\n          top: 50px;\n          right: 10px;\n          background: ${validation.errors.length > 0 ? '#f44336' : '#ff9800'};\n          color: white;\n          padding: 12px;\n          border-radius: 4px;\n          font-family: Arial, sans-serif;\n          font-size: 12px;\n          z-index: 999998;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n          max-width: 300px;\n          cursor: pointer;\n        \" onclick=\"this.style.display='none'\">\n          <div style=\"font-weight: bold; margin-bottom: 8px;\">\n            Data Quality: ${validation.score}/100\n          </div>\n          ${validation.errors.length > 0 ? `\n            <div style=\"margin-bottom: 4px;\">\n              <strong>Errors:</strong> ${validation.errors.length}\n            </div>\n          ` : ''}\n          ${validation.warnings.length > 0 ? `\n            <div style=\"margin-bottom: 4px;\">\n              <strong>Warnings:</strong> ${validation.warnings.length}\n            </div>\n          ` : ''}\n          <div style=\"font-size: 10px; opacity: 0.8;\">\n            Click to dismiss\n          </div>\n        </div>\n      `;\n      \n      document.body.appendChild(feedback);\n\n      // Auto-hide after 10 seconds\n      setTimeout(() => {\n        if (feedback.parentNode) {\n          feedback.remove();\n        }\n      }, 10000);\n    }\n\n    // Periodic validation during session\n    startPeriodicValidation() {\n      if (this.validationInterval) {\n        clearInterval(this.validationInterval);\n      }\n\n      this.validationInterval = setInterval(() => {\n        if (this.isTracking && this.events.length > 0) {\n          const validation = this.validateSessionData();\n          \n          // Show feedback for significant issues\n          if (validation.errors.length > 0 || validation.warnings.length > 2) {\n            this.showValidationFeedback(validation);\n          }\n\n          // Send validation metrics to background\n          chrome.runtime.sendMessage({\n            action: 'VALIDATION_UPDATE',\n            sessionId: this.sessionId,\n            validation: {\n              score: validation.score,\n              isValid: validation.isValid,\n              errorCount: validation.errors.length,\n              warningCount: validation.warnings.length,\n              metrics: validation.metrics\n            }\n          }).catch(() => {\n            // Ignore errors - background script might not be ready\n          });\n        }\n      }, 30000); // Every 30 seconds\n    }\n\n    stopPeriodicValidation() {\n      if (this.validationInterval) {\n        clearInterval(this.validationInterval);\n        this.validationInterval = null;\n      }\n    }\n\n    // UI feedback\n    showTrackingIndicator() {\n      if (document.getElementById('unified-tracking-indicator')) return;\n      \n      const indicator = document.createElement('div');\n      indicator.id = 'unified-tracking-indicator';\n      indicator.innerHTML = `\n        <div style=\"\n          position: fixed;\n          top: 10px;\n          right: 10px;\n          background: #4CAF50;\n          color: white;\n          padding: 8px 12px;\n          border-radius: 4px;\n          font-family: Arial, sans-serif;\n          font-size: 12px;\n          z-index: 999999;\n          box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n        \">\n          🔴 CodeSight Recording\n        </div>\n      `;\n      \n      document.body.appendChild(indicator);\n    }\n\n    hideTrackingIndicator() {\n      const indicator = document.getElementById('unified-tracking-indicator');\n      if (indicator) {\n        indicator.remove();\n      }\n    }\n\n    // Task overlay methods\n    async fetchAndDisplayTask() {\n      console.log('Unified: fetchAndDisplayTask() called'); // Debug log\n      try {\n        console.log('Unified: Fetching task for session:', this.sessionId);\n        \n        // Request task from background script to avoid CORS issues\n        const response = await chrome.runtime.sendMessage({\n          action: 'FETCH_TASK',\n          sessionId: this.sessionId,\n          difficulty: 'beginner'\n        });\n        \n        if (response && response.success && response.task) {\n          this.currentTask = response.task;\n          // this.showTaskOverlay(); // Disabled per user request\n          console.log('Unified: Task loaded:', this.currentTask.title);\n        } else {\n          throw new Error('Failed to fetch task: ' + (response?.error || 'Unknown error'));\n        }\n      } catch (error) {\n        console.error('Unified: Failed to fetch task:', error);\n        // Show fallback task\n        this.currentTask = {\n          title: \"Explore this website\",\n          description: \"Browse around and interact with different elements to help train our AI system\",\n          website: window.location.href,\n          difficulty: \"BEGINNER\"\n        };\n        // this.showTaskOverlay(); // Disabled per user request\n      }\n    }\n\n    showTaskOverlay() {\n      if (document.getElementById('unified-task-overlay')) return;\n      if (!this.currentTask) return;\n      \n      const overlay = document.createElement('div');\n      overlay.id = 'unified-task-overlay';\n      \n      // Get website URL for display\n      const targetWebsite = this.currentTask.website || 'the target website';\n      const websiteDomain = targetWebsite.includes('://') ? new URL(targetWebsite).hostname : targetWebsite;\n      \n      overlay.innerHTML = `\n        <div style=\"\n          position: fixed;\n          top: 50px;\n          right: 10px;\n          width: 320px;\n          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n          color: white;\n          padding: 18px;\n          border-radius: 12px;\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\n          font-size: 14px;\n          z-index: 999998;\n          box-shadow: 0 4px 20px rgba(0,0,0,0.25);\n          border: 1px solid rgba(255,255,255,0.2);\n        \">\n          <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px;\">\n            <h4 style=\"margin: 0; font-size: 18px; color: #fff; display: flex; align-items: center;\">\n              🎯 <span style=\"margin-left: 8px;\">Your Task</span>\n            </h4>\n            <button onclick=\"document.getElementById('unified-task-overlay').style.display='none'\" \n                    style=\"background: none; border: none; color: white; font-size: 20px; cursor: pointer; opacity: 0.8; padding: 4px;\">×</button>\n          </div>\n          \n          <div style=\"margin-bottom: 16px;\">\n            <div style=\"font-weight: 600; margin-bottom: 6px; font-size: 15px;\">${this.currentTask.title}</div>\n            <div style=\"font-size: 13px; opacity: 0.9; line-height: 1.4;\">${this.currentTask.description}</div>\n          </div>\n          \n          <div style=\"\n            background: rgba(255,255,255,0.15);\n            border-radius: 8px;\n            padding: 12px;\n            margin-bottom: 12px;\n          \">\n            <div style=\"font-size: 12px; font-weight: 600; margin-bottom: 6px; opacity: 0.9;\">🌐 Target Website:</div>\n            <div style=\"font-size: 13px; font-weight: 500; color: #e8f4fd;\">${websiteDomain}</div>\n          </div>\n          \n          <div style=\"font-size: 11px; opacity: 0.8; text-align: center; font-style: italic;\">\n            Navigate to the website and complete your task naturally\n          </div>\n        </div>\n      `;\n      \n      document.body.appendChild(overlay);\n      this.taskOverlay = overlay;\n    }\n\n    hideTaskOverlay() {\n      const overlay = document.getElementById('unified-task-overlay');\n      if (overlay) {\n        overlay.remove();\n      }\n      this.taskOverlay = null;\n    }\n\n    // Task progress is no longer automatically tracked - let users complete tasks naturally\n\n    // Task completion is now handled naturally by user behavior, not automated step tracking\n\n    restoreTaskOverlay() {\n      // Check if we're tracking and have a current task\n      if (this.isTracking && this.currentTask) {\n        console.log('Unified: Restoring task overlay after navigation for task:', this.currentTask.title);\n        \n        // Small delay to ensure DOM is ready and tracking indicator is shown\n        setTimeout(() => {\n          // this.showTaskOverlay(); // Disabled per user request\n        }, 100);\n      } else if (this.isTracking && !this.currentTask) {\n        // If we're tracking but lost the task, try to fetch it again\n        console.log('Unified: Tracking active but no current task - attempting to fetch task');\n        setTimeout(() => {\n          // this.fetchAndDisplayTask(); // Disabled per user request\n        }, 500);\n      }\n      \n      // Check if current domain matches task website domain  \n      if (this.isTracking && this.currentTask && this.currentTask.website) {\n        const currentDomain = window.location.hostname;\n        const taskDomain = new URL(this.currentTask.website).hostname;\n        \n        if (currentDomain === taskDomain || currentDomain.includes(taskDomain)) {\n          console.log('Unified: Now on task target website!', currentDomain);\n          // Highlight that we've reached the task website\n          this.showTaskCompletionHint();\n        }\n      }\n    }\n\n    showTaskCompletionHint() {\n      // Remove any existing hints\n      const existingHint = document.getElementById('unified-task-completion-hint');\n      if (existingHint) existingHint.remove();\n      \n      const hint = document.createElement('div');\n      hint.id = 'unified-task-completion-hint';\n      hint.innerHTML = `\n        <div style=\"\n          position: fixed;\n          bottom: 20px;\n          right: 20px;\n          background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);\n          color: white;\n          padding: 16px 20px;\n          border-radius: 8px;\n          font-family: Arial, sans-serif;\n          font-size: 14px;\n          z-index: 999999;\n          box-shadow: 0 4px 12px rgba(0,0,0,0.3);\n          max-width: 300px;\n          animation: slideIn 0.3s ease-out;\n        \">\n          <div style=\"font-size: 18px; margin-bottom: 8px;\">🎯 Task Website Reached!</div>\n          <div style=\"font-weight: bold; margin-bottom: 4px;\">You're now on the target website</div>\n          <div style=\"font-size: 12px; opacity: 0.9;\">Start completing your task objectives</div>\n        </div>\n        <style>\n          @keyframes slideIn {\n            from { transform: translateX(100%); opacity: 0; }\n            to { transform: translateX(0); opacity: 1; }\n          }\n        </style>\n      `;\n      \n      document.body.appendChild(hint);\n      \n      // Auto remove after 4 seconds\n      setTimeout(() => {\n        if (hint.parentNode) {\n          hint.remove();\n        }\n      }, 4000);\n    }\n\n    // Status methods\n    getStatus() {\n      // Use restored counts if available, otherwise use current array lengths\n      const eventCount = this.events.length + (this.restoredEventCount || 0);\n      const screenshotCount = this.screenshots.length + (this.restoredScreenshotCount || 0);\n      \n      return {\n        isTracking: this.isTracking,\n        sessionId: this.sessionId,\n        startTime: this.startTime,\n        duration: this.isTracking ? Date.now() - this.startTime : 0,\n        eventCount: eventCount,\n        screenshotCount: screenshotCount,\n        currentUrl: window.location.href,\n        qualityScore: this.calculateQualityScore(),\n        completeness: this.calculateCompleteness(),\n        currentTask: this.currentTask,\n        taskProgress: this.taskProgress\n      };\n    }\n\n    async getSessionData() {\n      if (!this.isTracking) {\n        return null;\n      }\n      \n      return await this.prepareSessionData();\n    }\n\n    updateConfig(newConfig) {\n      this.config = { ...this.config, ...newConfig };\n      console.log('Unified: Config updated:', newConfig);\n    }\n\n    // Utility methods\n    throttle(func, limit) {\n      let inThrottle;\n      return function() {\n        const args = arguments;\n        const context = this;\n        if (!inThrottle) {\n          func.apply(context, args);\n          inThrottle = true;\n          setTimeout(() => inThrottle = false, limit);\n        }\n      };\n    }\n\n    generateId() {\n      return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n\n    setupStatePreservation() {\n      // Save state before page unloads\n      const saveBeforeUnload = () => {\n        if (this.isTracking) {\n          console.log('Unified: Saving state before navigation');\n          this.saveState();\n        }\n      };\n\n      // Multiple event listeners to catch all navigation scenarios\n      window.addEventListener('beforeunload', saveBeforeUnload);\n      window.addEventListener('pagehide', saveBeforeUnload);\n      // Note: unload event removed due to permissions policy violation\n      \n      // Also save state periodically during tracking\n      if (this.statePreservationInterval) {\n        clearInterval(this.statePreservationInterval);\n      }\n      \n      this.statePreservationInterval = setInterval(() => {\n        if (this.isTracking) {\n          this.saveState();\n        }\n      }, 5000); // Save every 5 seconds\n    }\n\n    cleanupStatePreservation() {\n      if (this.statePreservationInterval) {\n        clearInterval(this.statePreservationInterval);\n        this.statePreservationInterval = null;\n      }\n    }\n\n    // Enhanced data collection methods per ChatGPT specification\n    \n    getPrunedDOMSnapshot(targetElement) {\n      // Get a focused DOM snapshot around the target element (5 levels up/down)\n      let container = targetElement;\n      for (let i = 0; i < 5 && container.parentElement; i++) {\n        container = container.parentElement;\n      }\n      \n      return this.serializeElementTree(container, 5);\n    }\n    \n    serializeElementTree(element, maxDepth) {\n      if (maxDepth <= 0) return null;\n      \n      const result = {\n        tag: element.tagName.toLowerCase(),\n        attributes: {},\n        children: []\n      };\n      \n      // Copy important attributes\n      for (const attr of element.attributes) {\n        if (['id', 'class', 'data-testid', 'role', 'type'].includes(attr.name)) {\n          result.attributes[attr.name] = attr.value;\n        }\n      }\n      \n      // Add text content for text nodes\n      if (element.childNodes.length === 1 && element.childNodes[0].nodeType === Node.TEXT_NODE) {\n        result.text = element.textContent.trim().substring(0, 100);\n      }\n      \n      // Recursively serialize children (but limit to avoid huge payloads)\n      for (let i = 0; i < Math.min(element.children.length, 10); i++) {\n        const child = this.serializeElementTree(element.children[i], maxDepth - 1);\n        if (child) result.children.push(child);\n      }\n      \n      return result;\n    }\n    \n    generatePageHash() {\n      // Simple hash of page structure for duplicate detection\n      const content = document.title + window.location.pathname + document.body.innerHTML.substring(0, 1000);\n      let hash = 0;\n      for (let i = 0; i < content.length; i++) {\n        const char = content.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash; // Convert to 32-bit integer\n      }\n      return `sha256-${Math.abs(hash).toString(16)}`;\n    }\n    \n    getRecentNetworkRequests() {\n      // This would require additional setup to capture network requests\n      // For now, return placeholder\n      return [];\n    }\n    \n    getElementAttributes(element) {\n      const attrs = {};\n      for (const attr of element.attributes) {\n        attrs[attr.name] = attr.value;\n      }\n      return attrs;\n    }\n    \n    generateCSSSelector(element) {\n      const path = [];\n      let current = element;\n      \n      while (current && current !== document.body) {\n        let selector = current.tagName.toLowerCase();\n        \n        if (current.id) {\n          selector += `#${current.id}`;\n          path.unshift(selector);\n          break;\n        }\n        \n        if (current.className) {\n          // Handle both regular HTML elements (string) and SVG elements (object)\n          const classValue = typeof current.className === 'string' \n            ? current.className \n            : current.className.baseVal || current.className.toString();\n            \n          if (classValue && typeof classValue === 'string') {\n            const classes = classValue.split(' ').filter(c => c.trim());\n            if (classes.length > 0) {\n              selector += `.${classes.join('.')}`;\n            }\n          }\n        }\n        \n        // Add nth-child if needed for uniqueness\n        const parent = current.parentElement;\n        if (parent) {\n          const siblings = Array.from(parent.children).filter(s => s.tagName === current.tagName);\n          if (siblings.length > 1) {\n            const index = siblings.indexOf(current) + 1;\n            selector += `:nth-child(${index})`;\n          }\n        }\n        \n        path.unshift(selector);\n        current = current.parentElement;\n      }\n      \n      return path.join(' > ');\n    }\n    \n    generateXPath(element) {\n      const path = [];\n      let current = element;\n      \n      while (current && current !== document.documentElement) {\n        let selector = current.tagName.toLowerCase();\n        \n        if (current.id) {\n          selector = `${selector}[@id='${current.id}']`;\n          path.unshift(selector);\n          break;\n        }\n        \n        // Add position among siblings\n        const parent = current.parentElement;\n        if (parent) {\n          const siblings = Array.from(parent.children).filter(s => s.tagName === current.tagName);\n          if (siblings.length > 1) {\n            const index = siblings.indexOf(current) + 1;\n            selector += `[${index}]`;\n          }\n        }\n        \n        path.unshift(selector);\n        current = current.parentElement;\n      }\n      \n      return '//' + path.join('/');\n    }\n    \n    getElementBoundingBox(element) {\n      const rect = element.getBoundingClientRect();\n      return {\n        x: Math.round(rect.left),\n        y: Math.round(rect.top),\n        width: Math.round(rect.width),\n        height: Math.round(rect.height)\n      };\n    }\n    \n    getRelevantComputedStyle(element) {\n      const computed = window.getComputedStyle(element);\n      return {\n        visibility: computed.visibility,\n        display: computed.display,\n        cursor: computed.cursor,\n        z_index: computed.zIndex,\n        position: computed.position\n      };\n    }\n    \n    getParentElementInfo(element) {\n      const parent = element.parentElement;\n      if (!parent) return null;\n      \n      // Handle both HTML and SVG className properly\n      const classValue = typeof parent.className === 'string' \n        ? parent.className \n        : parent.className.baseVal || parent.className.toString();\n      \n      return {\n        tag: parent.tagName.toLowerCase(),\n        classes: classValue ? classValue.split(' ').filter(c => c.trim()) : [],\n        id: parent.id || null,\n        css_selector: this.generateCSSSelector(parent)\n      };\n    }\n    \n    getAncestorChain(element) {\n      const ancestors = [];\n      let current = element.parentElement;\n      \n      while (current && current !== document.body && ancestors.length < 10) {\n        // Handle both HTML and SVG className properly\n        const classValue = typeof current.className === 'string' \n          ? current.className \n          : current.className.baseVal || current.className.toString();\n        \n        ancestors.push({\n          tag: current.tagName.toLowerCase(),\n          classes: classValue ? classValue.split(' ').filter(c => c.trim()) : [],\n          id: current.id || null,\n          css_selector: this.generateCSSSelector(current)\n        });\n        current = current.parentElement;\n      }\n      \n      return ancestors;\n    }\n    \n    getSiblingElements(element) {\n      const parent = element.parentElement;\n      if (!parent) return [];\n      \n      const siblings = [];\n      const children = Array.from(parent.children);\n      const elementIndex = children.indexOf(element);\n      \n      // Get 2 siblings on each side\n      for (let i = Math.max(0, elementIndex - 2); i <= Math.min(children.length - 1, elementIndex + 2); i++) {\n        if (i !== elementIndex) {\n          const sibling = children[i];\n          siblings.push({\n            position: i < elementIndex ? 'before' : 'after',\n            tag: sibling.tagName.toLowerCase(),\n            text: this.getElementText(sibling).substring(0, 50),\n            css_selector: this.generateCSSSelector(sibling)\n          });\n        }\n      }\n      \n      return siblings;\n    }\n    \n    findNearbyClickableElements(targetElement, radius = 300) {\n      const nearby = [];\n      const targetRect = targetElement.getBoundingClientRect();\n      const targetCenter = {\n        x: targetRect.left + targetRect.width / 2,\n        y: targetRect.top + targetRect.height / 2\n      };\n      \n      const clickableSelectors = 'a, button, input, select, textarea, [role=\"button\"], [onclick], [tabindex]';\n      const candidates = document.querySelectorAll(clickableSelectors);\n      \n      candidates.forEach(element => {\n        if (element === targetElement) return;\n        \n        const rect = element.getBoundingClientRect();\n        if (rect.width === 0 || rect.height === 0) return;\n        \n        const center = {\n          x: rect.left + rect.width / 2,\n          y: rect.top + rect.height / 2\n        };\n        \n        const distance = Math.sqrt(\n          Math.pow(center.x - targetCenter.x, 2) + \n          Math.pow(center.y - targetCenter.y, 2)\n        );\n        \n        if (distance <= radius) {\n          nearby.push({\n            tag: element.tagName.toLowerCase(),\n            text: this.getElementText(element).substring(0, 50),\n            css_selector: this.generateCSSSelector(element),\n            distance: Math.round(distance)\n          });\n        }\n      });\n      \n      return nearby.sort((a, b) => a.distance - b.distance).slice(0, 5);\n    }\n\n    // 🆕 PHASE 1: Expanded nearby elements collection (per Extension Expansion Plan)\n    // Collects ALL nearby elements (not just clickable) including price/product information\n    findNearbyElementsExpanded(targetElement, radius = 300) {\n      const nearby = [];\n      const targetRect = targetElement.getBoundingClientRect();\n      const targetCenter = {\n        x: targetRect.left + targetRect.width / 2,\n        y: targetRect.top + targetRect.height / 2\n      };\n\n      // Comprehensive selectors for ALL relevant elements (not just clickable)\n      const comprehensiveSelectors = [\n        // Interactive elements\n        'a', 'button', 'input', 'select', 'textarea', '[role=\"button\"]', '[onclick]', '[tabindex]',\n        // Price and product elements\n        '[class*=\"price\"]', '[data-price]', '[class*=\"cost\"]', '[class*=\"money\"]',\n        '[class*=\"product\"]', '[data-product]', '[class*=\"item\"]',\n        // Shopping specific\n        '[class*=\"cart\"]', '[data-cart]', '[class*=\"add-to\"]', '[class*=\"buy\"]',\n        '[class*=\"variant\"]', '[class*=\"size\"]', '[class*=\"color\"]', '[class*=\"option\"]',\n        // Content elements with potential value\n        'span', 'div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n        // Images and media\n        'img', 'picture', 'video'\n      ].join(', ');\n\n      const candidates = document.querySelectorAll(comprehensiveSelectors);\n      \n      candidates.forEach(element => {\n        if (element === targetElement) return;\n        \n        const rect = element.getBoundingClientRect();\n        if (rect.width === 0 || rect.height === 0) return;\n        \n        const center = {\n          x: rect.left + rect.width / 2,\n          y: rect.top + rect.height / 2\n        };\n        \n        const distance = Math.sqrt(\n          Math.pow(center.x - targetCenter.x, 2) + \n          Math.pow(center.y - targetCenter.y, 2)\n        );\n        \n        if (distance <= radius) {\n          const elementText = this.getElementText(element);\n          \n          // 🎯 Multi-layered detection with confidence scoring\n          const elementCategory = this.categorizeElement(element);\n          const priceAnalysis = this.containsPricePattern(elementText, element);\n          const productAnalysis = this.containsProductPattern(elementText, element);\n          \n          const elementData = {\n            tag: element.tagName.toLowerCase(),\n            text: elementText.substring(0, 100), // Increased from 50 to capture more context\n            css_selector: this.generateCSSSelector(element),\n            distance: Math.round(distance),\n            direction: this.getRelativeDirection(targetCenter, center),\n            isVisible: this.isElementVisible(element),\n            isInteractive: this.isInteractiveElement(element),\n            \n            // 🆕 Enhanced multi-signal categorization per Extension Expansion Plan\n            elementType: elementCategory.type,\n            elementConfidence: elementCategory.confidence,\n            elementSignals: elementCategory.signals,\n            \n            // 🆕 Rich price analysis\n            hasPrice: priceAnalysis.hasPrice,\n            priceConfidence: priceAnalysis.confidence,\n            priceSignals: priceAnalysis.signals,\n            priceInfo: priceAnalysis.extractedPrices,\n            \n            // 🆕 Rich product analysis\n            hasProduct: productAnalysis.hasProduct,\n            productConfidence: productAnalysis.confidence,\n            productSignals: productAnalysis.signals,\n            productInfo: productAnalysis.extractedProduct,\n            \n            // Enhanced attributes and context\n            attributes: this.getRelevantAttributes(element),\n            boundingBox: {\n              x: Math.round(rect.left),\n              y: Math.round(rect.top),\n              width: Math.round(rect.width),\n              height: Math.round(rect.height)\n            },\n            \n            // 🆕 Overall quality score for backend filtering\n            qualityScore: this.calculateElementQuality(elementCategory, priceAnalysis, productAnalysis, elementText)\n          };\n\n          nearby.push(elementData);\n        }\n      });\n      \n      // Sort by distance and return closest 25 (expanded from 10 per plan)\n      return nearby.sort((a, b) => a.distance - b.distance).slice(0, 25);\n    }\n\n    // 🎯 Multi-signal element categorization with confidence scoring\n    categorizeElement(element) {\n      const tag = element.tagName.toLowerCase();\n      const classes = element.className || '';\n      const text = (element.textContent || '').trim();\n      const attributes = this.getElementAttributes(element);\n      \n      // Layer 1: Explicit high-confidence indicators\n      const explicitCategory = this.getExplicitCategory(element, classes, attributes);\n      if (explicitCategory.confidence > 0.8) {\n        return explicitCategory;\n      }\n      \n      // Layer 2: Contextual pattern analysis\n      const contextualCategory = this.getContextualCategory(element, text, classes);\n      if (contextualCategory.confidence > 0.6) {\n        return contextualCategory;\n      }\n      \n      // Layer 3: Heuristic detection\n      const heuristicCategory = this.getHeuristicCategory(element, tag, text);\n      if (heuristicCategory.confidence > 0.4) {\n        return heuristicCategory;\n      }\n      \n      // Layer 4: Fallback categorization\n      return this.getFallbackCategory(element, tag);\n    }\n\n    // Layer 1: High-confidence explicit indicators\n    getExplicitCategory(element, classes, attributes) {\n      let signals = [];\n      let confidence = 0;\n      \n      // Data attributes (highest confidence)\n      if (attributes['data-price'] || attributes['data-cost']) {\n        return { type: 'price', confidence: 0.95, signals: ['data-price-attribute'] };\n      }\n      if (attributes['data-product'] || attributes['data-sku']) {\n        return { type: 'product', confidence: 0.95, signals: ['data-product-attribute'] };\n      }\n      if (attributes['data-cart'] || attributes['data-add-to-cart']) {\n        return { type: 'shopping-action', confidence: 0.95, signals: ['data-cart-attribute'] };\n      }\n      \n      // Class-based indicators (high confidence)\n      const priceClasses = ['price', 'cost', 'money', 'amount', 'total', 'subtotal'];\n      const productClasses = ['product', 'item', 'listing', 'card'];\n      const cartClasses = ['cart', 'add-to-cart', 'buy-now', 'purchase'];\n      \n      const matchedPriceClasses = priceClasses.filter(cls => classes.toLowerCase().includes(cls));\n      if (matchedPriceClasses.length > 0) {\n        confidence = 0.85;\n        signals = [`price-class-${matchedPriceClasses.join('-')}`];\n        return { type: 'price', confidence, signals };\n      }\n      \n      const matchedProductClasses = productClasses.filter(cls => classes.toLowerCase().includes(cls));\n      if (matchedProductClasses.length > 0) {\n        confidence = 0.85;\n        signals = [`product-class-${matchedProductClasses.join('-')}`];\n        return { type: 'product', confidence, signals };\n      }\n      \n      const matchedCartClasses = cartClasses.filter(cls => classes.toLowerCase().includes(cls));\n      if (matchedCartClasses.length > 0) {\n        confidence = 0.85;\n        signals = [`cart-class-${matchedCartClasses.join('-')}`];\n        return { type: 'shopping-action', confidence, signals };\n      }\n      \n      return { type: null, confidence: 0, signals: [] };\n    }\n\n    // Layer 2: Contextual pattern analysis\n    getContextualCategory(element, text, classes) {\n      let signals = [];\n      let confidence = 0;\n      \n      // Context from parent/ancestor elements\n      const priceContainer = element.closest('[class*=\"price\"], [class*=\"cost\"], [data-price]');\n      const productContainer = element.closest('[class*=\"product\"], [class*=\"item\"], [data-product]');\n      const cartContainer = element.closest('[class*=\"cart\"], [class*=\"checkout\"], [data-cart]');\n      \n      if (priceContainer && this.containsCurrencyOrNumbers(text)) {\n        confidence = 0.75;\n        signals.push('price-container-context');\n        return { type: 'price', confidence, signals };\n      }\n      \n      if (productContainer && text.length > 5 && text.length < 200) {\n        confidence = 0.65;\n        signals.push('product-container-context');\n        return { type: 'product', confidence, signals };\n      }\n      \n      if (cartContainer && /\\b(add|buy|purchase|cart)\\b/i.test(text)) {\n        confidence = 0.7;\n        signals.push('cart-container-context');\n        return { type: 'shopping-action', confidence, signals };\n      }\n      \n      // Sibling element context\n      const siblings = Array.from(element.parentElement?.children || []);\n      const hasPriceSiblings = siblings.some(sib => this.containsCurrencyOrNumbers(sib.textContent || ''));\n      const hasProductSiblings = siblings.some(sib => sib.querySelector('img') || /\\b(size|color|variant)\\b/i.test(sib.textContent || ''));\n      \n      if (hasPriceSiblings && this.containsCurrencyOrNumbers(text)) {\n        confidence = 0.6;\n        signals.push('price-sibling-context');\n        return { type: 'price', confidence, signals };\n      }\n      \n      if (hasProductSiblings && text.length > 10) {\n        confidence = 0.55;\n        signals.push('product-sibling-context');\n        return { type: 'product', confidence, signals };\n      }\n      \n      return { type: null, confidence: 0, signals: [] };\n    }\n\n    // Layer 3: Heuristic detection\n    getHeuristicCategory(element, tag, text) {\n      let signals = [];\n      let confidence = 0;\n      \n      // Text-based heuristics\n      if (this.containsCurrencyOrNumbers(text)) {\n        confidence = 0.5;\n        signals.push('currency-text-pattern');\n        return { type: 'price', confidence, signals };\n      }\n      \n      // Product name heuristics (flexible patterns)\n      if (this.looksLikeProductName(text)) {\n        confidence = 0.45;\n        signals.push('product-name-pattern');\n        return { type: 'product', confidence, signals };\n      }\n      \n      // Shopping action heuristics\n      if (/\\b(add to cart|buy now|purchase|checkout|add to bag)\\b/i.test(text)) {\n        confidence = 0.6;\n        signals.push('shopping-action-text');\n        return { type: 'shopping-action', confidence, signals };\n      }\n      \n      // Variant/option heuristics\n      if (/\\b(size|color|variant|option|select|choose)\\b/i.test(text) && text.length < 50) {\n        confidence = 0.5;\n        signals.push('variant-text-pattern');\n        return { type: 'product-variant', confidence, signals };\n      }\n      \n      return { type: null, confidence: 0, signals: [] };\n    }\n\n    // Layer 4: Fallback categorization\n    getFallbackCategory(element, tag) {\n      // Interactive elements\n      if (['button', 'a', 'input'].includes(tag) || element.onclick || element.tabIndex >= 0) {\n        return { type: 'interactive', confidence: 0.9, signals: ['tag-based'] };\n      }\n      \n      // Content elements\n      if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)) {\n        return { type: 'heading', confidence: 0.9, signals: ['tag-based'] };\n      }\n      \n      if (['img', 'picture', 'video'].includes(tag)) {\n        return { type: 'media', confidence: 0.9, signals: ['tag-based'] };\n      }\n      \n      return { type: 'content', confidence: 0.3, signals: ['fallback'] };\n    }\n\n    // 🎯 Multi-signal price detection with confidence scoring\n    containsPricePattern(text, element) {\n      if (!text) return { hasPrice: false, confidence: 0, signals: [] };\n      \n      let confidence = 0;\n      let signals = [];\n      \n      // Signal 1: Currency symbols (broad international support)\n      const currencyPattern = /[\\$€£¥₹₽¢₩₪₴₨₡₦₵₸KčDkr₨]/;\n      if (currencyPattern.test(text)) {\n        confidence += 0.4;\n        signals.push('currency-symbol');\n      }\n      \n      // Signal 2: Price format patterns (flexible)\n      const priceFormats = [\n        /\\d+[,.]\\d{2}(?!\\d)/,  // XX.XX or XX,XX (not followed by more digits)\n        /\\d{1,3}[,\\s]\\d{3}[,.]\\d{2}/,  // 1,234.56 or 1 234,56\n        /\\d+[,.]\\d{1}(?!\\d)/,   // XX.X (sometimes used)\n        /\\d+(?:\\s*[kmb])?(?=\\s*[\\$€£¥₹₽])/i  // 5k, 2.5m followed by currency\n      ];\n      \n      if (priceFormats.some(pattern => pattern.test(text))) {\n        confidence += 0.3;\n        signals.push('price-format');\n      }\n      \n      // Signal 3: Context clues from element or ancestors\n      if (element && element.closest('[class*=\"price\"], [class*=\"cost\"], [data-price]')) {\n        confidence += 0.2;\n        signals.push('price-context');\n      }\n      \n      // Signal 4: Monetary formatting indicators\n      if (element && this.hasMonetaryFormatting(element)) {\n        confidence += 0.1;\n        signals.push('monetary-formatting');\n      }\n      \n      // Signal 5: Text patterns that suggest pricing\n      const priceIndicators = /\\b(price|cost|total|subtotal|tax|shipping|discount|sale|was|now|save)\\b/i;\n      if (priceIndicators.test(text)) {\n        confidence += 0.1;\n        signals.push('price-indicators');\n      }\n      \n      return {\n        hasPrice: confidence > 0.5,\n        confidence: Math.min(confidence, 1.0),\n        signals,\n        extractedPrices: confidence > 0.5 ? this.extractPriceFromText(text) : null\n      };\n    }\n\n    // 🎯 Multi-signal product detection with confidence scoring  \n    containsProductPattern(text, element) {\n      if (!text) return { hasProduct: false, confidence: 0, signals: [] };\n      \n      let confidence = 0;\n      let signals = [];\n      \n      // Signal 1: In product-like container\n      if (element && element.closest('[class*=\"product\"], [class*=\"item\"], [data-product], [class*=\"card\"]')) {\n        confidence += 0.3;\n        signals.push('product-container');\n      }\n      \n      // Signal 2: Has product-like attributes or child elements\n      if (element && (element.querySelector('img') || element.hasAttribute('data-sku') || element.hasAttribute('data-product-id'))) {\n        confidence += 0.2;\n        signals.push('product-attributes');\n      }\n      \n      // Signal 3: Text patterns suggesting product descriptors (broader than hard-coded lists)\n      const productDescriptors = /\\b\\w+\\s*(?:size|color|variant|model|brand|style|type|material|fabric|finish)\\b/i;\n      if (productDescriptors.test(text)) {\n        confidence += 0.2;\n        signals.push('product-descriptors');\n      }\n      \n      // Signal 4: Length and structure suggests product name (not too short, not too long)\n      if (text.length >= 8 && text.length <= 150 && !/\\b(click|buy|add|cart|login|signup|menu|search)\\b/i.test(text)) {\n        confidence += 0.1;\n        signals.push('product-text-length');\n      }\n      \n      // Signal 5: Contains alphanumeric patterns that look like model numbers/SKUs\n      if (/\\b[A-Z0-9]{3,}-?[A-Z0-9]{2,}\\b/.test(text)) {\n        confidence += 0.15;\n        signals.push('model-number-pattern');\n      }\n      \n      // Signal 6: Sibling elements suggest product context\n      if (element && this.hasProductSiblings(element)) {\n        confidence += 0.1;\n        signals.push('product-siblings');\n      }\n      \n      return {\n        hasProduct: confidence > 0.4,\n        confidence: Math.min(confidence, 1.0),\n        signals,\n        extractedProduct: confidence > 0.4 ? this.extractProductFromText(text) : null\n      };\n    }\n\n    // Helper: Check if element has monetary-style formatting\n    hasMonetaryFormatting(element) {\n      try {\n        const style = window.getComputedStyle(element);\n        // Common price styling patterns\n        return (\n          style.fontWeight === 'bold' ||\n          style.fontSize.includes('larger') ||\n          style.textAlign === 'right' ||\n          style.color === 'red' ||\n          style.color.includes('rgb(255') // Red-ish colors often used for prices\n        );\n      } catch {\n        return false;\n      }\n    }\n\n    // Helper: Check for product-related sibling elements\n    hasProductSiblings(element) {\n      try {\n        const siblings = Array.from(element.parentElement?.children || []);\n        return siblings.some(sib => \n          sib.querySelector('img') || \n          /\\b(size|color|variant|price|buy|add to cart)\\b/i.test(sib.textContent || '') ||\n          sib.className.toLowerCase().includes('price') ||\n          sib.className.toLowerCase().includes('product')\n        );\n      } catch {\n        return false;\n      }\n    }\n\n    // Helper: Flexible currency and number detection\n    containsCurrencyOrNumbers(text) {\n      if (!text) return false;\n      const currencyOrNumber = /[\\$€£¥₹₽¢₩₪₴₨₡₦₵₸]|\\d+[,.]\\d+|\\b\\d{2,}\\b/;\n      return currencyOrNumber.test(text);\n    }\n\n    // Helper: Heuristic to identify product names\n    looksLikeProductName(text) {\n      if (!text || text.length < 5 || text.length > 200) return false;\n      \n      // Exclude common UI text\n      const uiPatterns = /\\b(click|select|choose|buy|add|cart|menu|login|signup|search|filter|sort|view|more|less|show|hide)\\b/i;\n      if (uiPatterns.test(text)) return false;\n      \n      // Look for product-like patterns\n      const productPatterns = [\n        /\\b\\w+\\s+(for|with|in|by)\\s+\\w+/i,  // \"Shirt for Men\", \"Phone with Case\"\n        /\\b\\w+\\s*[-–]\\s*\\w+/,               // \"Nike - Air Max\"\n        /\\b[A-Z][a-z]+\\s+[A-Z][a-z]+/,      // \"Brand Name\" pattern\n        /\\d+[a-z]*\\s*(inch|gb|ml|oz|cm|mm)/i // Size/capacity indicators\n      ];\n      \n      return productPatterns.some(pattern => pattern.test(text));\n    }\n\n    // Helper method to extract price information from text\n    extractPriceFromText(text) {\n      const pricePattern = /([\\$€£¥₹₽])\\s*(\\d+([,.]\\d{2})?)|(\\d+([,.]\\d{2})?\\s*([\\$€£¥₹₽]))/g;\n      const matches = text.match(pricePattern);\n      return matches ? matches.map(match => match.trim()) : [];\n    }\n\n    // Helper method to extract product information from text\n    extractProductFromText(text) {\n      const words = text.split(/\\s+/).filter(word => word.length > 2);\n      return {\n        fullText: text.substring(0, 200),\n        keywords: words.slice(0, 10)\n      };\n    }\n\n    // Helper method to get relevant attributes for context\n    getRelevantAttributes(element) {\n      const relevantAttrs = {};\n      const attrs = ['class', 'id', 'data-product', 'data-price', 'data-sku', 'data-variant', 'aria-label', 'title', 'alt'];\n      \n      attrs.forEach(attr => {\n        const value = element.getAttribute(attr);\n        if (value) {\n          relevantAttrs[attr] = value;\n        }\n      });\n      \n      return relevantAttrs;\n    }\n\n    // 🆕 Calculate overall element quality score for backend filtering\n    calculateElementQuality(elementCategory, priceAnalysis, productAnalysis, elementText) {\n      let qualityScore = 0;\n      let confidence = 0;\n      let signals = [];\n\n      // Base score from element categorization\n      if (elementCategory.confidence > 0) {\n        qualityScore += elementCategory.confidence * 40; // Up to 40 points\n        confidence = Math.max(confidence, elementCategory.confidence);\n        signals = signals.concat(elementCategory.signals);\n      }\n\n      // Price analysis contribution\n      if (priceAnalysis.confidence > 0) {\n        qualityScore += priceAnalysis.confidence * 30; // Up to 30 points\n        confidence = Math.max(confidence, priceAnalysis.confidence);\n        signals = signals.concat(priceAnalysis.signals);\n      }\n\n      // Product analysis contribution  \n      if (productAnalysis.confidence > 0) {\n        qualityScore += productAnalysis.confidence * 20; // Up to 20 points\n        confidence = Math.max(confidence, productAnalysis.confidence);\n        signals = signals.concat(productAnalysis.signals);\n      }\n\n      // Text quality bonus (up to 10 points)\n      const textLength = elementText.length;\n      if (textLength > 5 && textLength < 200) {\n        qualityScore += 5;\n        signals.push('appropriate-text-length');\n      }\n      if (textLength > 20 && textLength < 100) {\n        qualityScore += 5; // Sweet spot for descriptive text\n        signals.push('optimal-text-length');\n      }\n\n      // Remove duplicate signals\n      signals = [...new Set(signals)];\n\n      return {\n        score: Math.min(100, Math.round(qualityScore)), // Cap at 100\n        confidence: Math.round(confidence * 100) / 100, // Round to 2 decimals\n        signals: signals,\n        breakdown: {\n          elementCategory: elementCategory.confidence * 40,\n          priceAnalysis: priceAnalysis.confidence * 30,\n          productAnalysis: productAnalysis.confidence * 20,\n          textQuality: qualityScore - (elementCategory.confidence * 40) - (priceAnalysis.confidence * 30) - (productAnalysis.confidence * 20)\n        }\n      };\n    }\n\n    // 🆕 Phase 2: Extract comprehensive price data from clicked elements\n    extractPriceData(clickedElement) {\n      const priceData = {\n        clickedElementPrices: [],\n        nearbyPrices: [],\n        productInfo: {},\n        variants: {},\n        discounts: {},\n        context: {}\n      };\n\n      // Extract prices from the clicked element itself\n      priceData.clickedElementPrices = this.findPricesInElement(clickedElement);\n\n      // Extract prices from nearby elements (within 200px radius)\n      const nearbyElements = this.findNearbyElementsExpanded(clickedElement, 200);\n      nearbyElements.forEach(elementData => {\n        if (elementData.priceAnalysis && elementData.priceAnalysis.confidence > 0.3) {\n          priceData.nearbyPrices.push({\n            price: elementData.priceAnalysis.extractedPrice,\n            confidence: elementData.priceAnalysis.confidence,\n            signals: elementData.priceAnalysis.signals,\n            element: {\n              text: elementData.text,\n              selector: elementData.selector,\n              distance: elementData.distance\n            }\n          });\n        }\n      });\n\n      // Extract product information\n      priceData.productInfo = this.extractProductInfo(clickedElement);\n\n      // Extract variant information (size, color, etc.)\n      priceData.variants = this.extractVariantInfo(clickedElement);\n\n      // Detect discount/sale information\n      priceData.discounts = this.extractDiscountInfo(clickedElement);\n\n      // Add contextual information\n      priceData.context = {\n        pageType: this.detectPageType(),\n        isProductPage: this.isProductPage(),\n        isCartPage: this.isCartPage(),\n        timestamp: Date.now()\n      };\n\n      return priceData;\n    }\n\n    // Helper: Find all prices within an element\n    findPricesInElement(element) {\n      const prices = [];\n      const text = this.getElementText(element);\n      \n      // Enhanced price patterns supporting multiple currencies and formats\n      const pricePatterns = [\n        // Standard formats: $12.99, €15,50, £20.00\n        /([\\$€£¥₹₽¢])\\s*(\\d{1,3}(?:[,.]\\d{3})*(?:[,.]\\d{2})?)/g,\n        // Reverse formats: 12.99$, 15,50€, 20.00£\n        /(\\d{1,3}(?:[,.]\\d{3})*(?:[,.]\\d{2})?)\\s*([\\$€£¥₹₽¢])/g,\n        // USD/EUR format: 12.99 USD, 15,50 EUR\n        /(\\d{1,3}(?:[,.]\\d{3})*(?:[,.]\\d{2})?)\\s+(USD|EUR|GBP|JPY|CAD|AUD)/gi,\n        // Decimal only in price context: 12.99 (when near price-related terms)\n        /(\\d{1,3}(?:[,.]\\d{3})*[,.]\\d{2})/g\n      ];\n\n      pricePatterns.forEach(pattern => {\n        let match;\n        while ((match = pattern.exec(text)) !== null) {\n          const fullMatch = match[0];\n          const currency = match[1] || match[2] || match[3] || 'USD';\n          const amount = match[2] || match[1] || match[1];\n          \n          prices.push({\n            raw: fullMatch,\n            currency: currency,\n            amount: amount,\n            normalized: this.normalizePrice(fullMatch),\n            context: this.getPriceContext(element, fullMatch)\n          });\n        }\n      });\n\n      return prices;\n    }\n\n    // Helper: Extract product information from clicked element\n    extractProductInfo(element) {\n      const productInfo = {\n        name: null,\n        brand: null,\n        sku: null,\n        category: null,\n        description: null\n      };\n\n      // Look for product name in various places\n      productInfo.name = this.findProductName(element);\n      productInfo.brand = this.findBrandInfo(element);\n      productInfo.sku = this.findSKU(element);\n      productInfo.category = this.findCategory(element);\n      productInfo.description = this.findDescription(element);\n\n      return productInfo;\n    }\n\n    // Helper: Extract variant information (size, color, style)\n    extractVariantInfo(element) {\n      const variants = {\n        size: null,\n        color: null,\n        style: null,\n        options: []\n      };\n\n      // Look for size information\n      variants.size = this.findVariantInfo(element, ['size', 'sz']);\n      variants.color = this.findVariantInfo(element, ['color', 'colour', 'clr']);\n      variants.style = this.findVariantInfo(element, ['style', 'variant', 'type']);\n\n      // Find all variant options in nearby selectors\n      const variantSelectors = element.closest('form, .product, .item')?.querySelectorAll('select, [class*=\"size\"], [class*=\"color\"], [class*=\"variant\"]');\n      if (variantSelectors) {\n        variantSelectors.forEach(selector => {\n          const option = this.extractSelectorOption(selector);\n          if (option) {\n            variants.options.push(option);\n          }\n        });\n      }\n\n      return variants;\n    }\n\n    // Helper: Extract discount/sale information\n    extractDiscountInfo(element) {\n      const discounts = {\n        isOnSale: false,\n        originalPrice: null,\n        salePrice: null,\n        discount: null,\n        discountType: null\n      };\n\n      const text = this.getElementText(element);\n      const container = element.closest('.price, .product, .item') || element;\n\n      // Look for sale indicators\n      const salePatterns = /\\b(sale|discount|off|save|was|orig\\.?|regular|msrp)\\b/i;\n      discounts.isOnSale = salePatterns.test(text);\n\n      if (discounts.isOnSale) {\n        // Try to find original and sale prices\n        const priceElements = container.querySelectorAll('[class*=\"price\"], [data-price]');\n        const prices = Array.from(priceElements).map(el => this.findPricesInElement(el)).flat();\n        \n        if (prices.length >= 2) {\n          // Assume highest price is original, lowest is sale\n          prices.sort((a, b) => parseFloat(b.normalized) - parseFloat(a.normalized));\n          discounts.originalPrice = prices[0];\n          discounts.salePrice = prices[prices.length - 1];\n          \n          const originalAmount = parseFloat(discounts.originalPrice.normalized);\n          const saleAmount = parseFloat(discounts.salePrice.normalized);\n          discounts.discount = originalAmount - saleAmount;\n          discounts.discountType = discounts.discount > 0 ? 'amount' : 'percentage';\n        }\n      }\n\n      return discounts;\n    }\n\n    // Helper: Normalize price for comparison\n    normalizePrice(priceString) {\n      return priceString.replace(/[^\\d.,]/g, '').replace(',', '.');\n    }\n\n    // Helper: Get price context (crossed out, bold, etc.)\n    getPriceContext(element, priceText) {\n      const computedStyle = window.getComputedStyle(element);\n      return {\n        isStrikethrough: computedStyle.textDecoration.includes('line-through'),\n        isBold: computedStyle.fontWeight === 'bold' || parseInt(computedStyle.fontWeight) >= 700,\n        color: computedStyle.color,\n        fontSize: computedStyle.fontSize\n      };\n    }\n\n    // Helper methods for product information extraction\n    findProductName(element) {\n      // Look in order of preference: data attributes, headings, alt text, aria-label, text content\n      const productName = element.getAttribute('data-product-name') ||\n                         element.getAttribute('data-title') ||\n                         element.closest('[data-product-name]')?.getAttribute('data-product-name') ||\n                         element.querySelector('h1, h2, h3, .title, .name')?.textContent?.trim() ||\n                         element.querySelector('img')?.alt ||\n                         element.getAttribute('aria-label');\n      \n      return productName && productName.length > 5 ? productName.substring(0, 200) : null;\n    }\n\n    findBrandInfo(element) {\n      const brand = element.getAttribute('data-brand') ||\n                   element.closest('[data-brand]')?.getAttribute('data-brand') ||\n                   element.querySelector('.brand, [class*=\"brand\"]')?.textContent?.trim();\n      \n      return brand && brand.length > 1 ? brand.substring(0, 50) : null;\n    }\n\n    findSKU(element) {\n      const sku = element.getAttribute('data-sku') ||\n                 element.getAttribute('data-product-id') ||\n                 element.closest('[data-sku], [data-product-id]')?.getAttribute('data-sku') ||\n                 element.closest('[data-sku], [data-product-id]')?.getAttribute('data-product-id');\n      \n      return sku || null;\n    }\n\n    findCategory(element) {\n      const category = element.getAttribute('data-category') ||\n                      element.closest('[data-category]')?.getAttribute('data-category') ||\n                      element.querySelector('.category, [class*=\"category\"]')?.textContent?.trim();\n      \n      return category && category.length > 2 ? category.substring(0, 100) : null;\n    }\n\n    findDescription(element) {\n      const description = element.getAttribute('data-description') ||\n                         element.querySelector('.description, [class*=\"description\"], .details')?.textContent?.trim();\n      \n      return description && description.length > 10 ? description.substring(0, 500) : null;\n    }\n\n    findVariantInfo(element, keywords) {\n      for (const keyword of keywords) {\n        // Check data attributes first\n        const dataAttr = element.getAttribute(`data-${keyword}`) ||\n                        element.closest(`[data-${keyword}]`)?.getAttribute(`data-${keyword}`);\n        if (dataAttr) return dataAttr;\n\n        // Check selected options in nearby selectors\n        const selector = element.querySelector(`select[class*=\"${keyword}\"], [class*=\"${keyword}\"] select`) ||\n                        element.closest('form, .product')?.querySelector(`select[class*=\"${keyword}\"], [class*=\"${keyword}\"] select`);\n        if (selector?.selectedOptions?.length > 0) {\n          return selector.selectedOptions[0].textContent.trim();\n        }\n\n        // Check class-based elements with keyword\n        const keywordElement = element.querySelector(`[class*=\"${keyword}\"]`) ||\n                              element.closest(`.product, .item`)?.querySelector(`[class*=\"${keyword}\"]`);\n        if (keywordElement) {\n          const text = keywordElement.textContent?.trim();\n          if (text && text.length < 50) return text;\n        }\n      }\n      return null;\n    }\n\n    extractSelectorOption(selector) {\n      if (selector.tagName.toLowerCase() === 'select' && selector.selectedOptions?.length > 0) {\n        return {\n          type: this.getSelecterType(selector),\n          value: selector.selectedOptions[0].value,\n          text: selector.selectedOptions[0].textContent.trim(),\n          allOptions: Array.from(selector.options).map(opt => ({\n            value: opt.value,\n            text: opt.textContent.trim(),\n            selected: opt.selected\n          }))\n        };\n      }\n      return null;\n    }\n\n    getSelecterType(selector) {\n      const className = selector.className.toLowerCase();\n      if (className.includes('size')) return 'size';\n      if (className.includes('color') || className.includes('colour')) return 'color';\n      if (className.includes('variant') || className.includes('style')) return 'variant';\n      return 'option';\n    }\n\n    detectPageType() {\n      const url = window.location.href.toLowerCase();\n      const bodyClasses = document.body.className.toLowerCase();\n      \n      if (url.includes('/product/') || url.includes('/item/') || bodyClasses.includes('product')) {\n        return 'product';\n      }\n      if (url.includes('/cart') || url.includes('/bag') || bodyClasses.includes('cart')) {\n        return 'cart';\n      }\n      if (url.includes('/checkout') || bodyClasses.includes('checkout')) {\n        return 'checkout';\n      }\n      if (url.includes('/category/') || url.includes('/shop/') || bodyClasses.includes('category')) {\n        return 'category';\n      }\n      return 'other';\n    }\n\n    isProductPage() {\n      return this.detectPageType() === 'product';\n    }\n\n    isCartPage() {\n      return this.detectPageType() === 'cart';\n    }\n    \n    detectActiveOverlays() {\n      const overlays = [];\n      \n      // Common modal/overlay selectors\n      const overlaySelectors = [\n        '.modal:not([style*=\"display: none\"])',\n        '.overlay:not([style*=\"display: none\"])',\n        '.popup:not([style*=\"display: none\"])',\n        '.dialog:not([style*=\"display: none\"])',\n        '[role=\"dialog\"]:not([style*=\"display: none\"])',\n        '.cookie-banner:not([style*=\"display: none\"])',\n        '.cookie-consent:not([style*=\"display: none\"])'\n      ];\n      \n      overlaySelectors.forEach(selector => {\n        const elements = document.querySelectorAll(selector);\n        elements.forEach(element => {\n          const computed = window.getComputedStyle(element);\n          if (computed.display !== 'none' && computed.visibility !== 'hidden') {\n            const closeButton = element.querySelector('button[class*=\"close\"], .close, [aria-label*=\"close\"]');\n            overlays.push({\n              id: element.id || `overlay-${overlays.length}`,\n              css_selector: this.generateCSSSelector(element),\n              bounding_box: this.getElementBoundingBox(element),\n              close_button: closeButton ? {\n                css_selector: this.generateCSSSelector(closeButton)\n              } : null\n            });\n          }\n        });\n      });\n      \n      return overlays;\n    }\n\n    // Check if element is in viewport\n    isElementInViewport(element) {\n      const rect = element.getBoundingClientRect();\n      return (\n        rect.top >= 0 &&\n        rect.left >= 0 &&\n        rect.bottom <= window.innerHeight &&\n        rect.right <= window.innerWidth\n      );\n    }\n\n    // Test selector reliability (simplified)\n    testSelectorReliability(selector) {\n      try {\n        const elements = document.querySelectorAll(selector);\n        return elements.length === 1 ? 1.0 : Math.max(0.1, 1.0 / elements.length);\n      } catch (e) {\n        return 0.1;\n      }\n    }\n\n    // Get viewport information\n    getViewportInfo() {\n      return {\n        width: window.innerWidth,\n        height: window.innerHeight,\n        scrollX: window.scrollX,\n        scrollY: window.scrollY,\n        devicePixelRatio: window.devicePixelRatio || 1\n      };\n    }\n\n    // Update existing event and send to background\n    updateEvent(eventData) {\n      const idx = this.events.findIndex(e => e.id === eventData.id);\n      if (idx !== -1) {\n        this.events[idx] = { ...this.events[idx], ...eventData };\n        this.saveState();\n        // **New**: push updated event to background\n        chrome.runtime.sendMessage({\n          action: 'SEND_DATA',\n          data: this.events[idx]\n        });\n      }\n    }\n\n    // Get complete session data for download\n    getSessionData() {\n      const duration = this.isTracking ? Date.now() - this.startTime : 0;\n      \n      const sessionData = {\n        sessionId: this.sessionId,\n        isTracking: this.isTracking,\n        startTime: this.startTime,\n        duration: duration,\n        currentUrl: window.location.href,\n        \n        // Enhanced interaction data\n        events: this.events,\n        eventCount: this.events.length,\n        \n        // Screenshots\n        screenshots: this.screenshots,\n        screenshotCount: this.screenshots.length,\n        \n        // Session metadata\n        config: this.config,\n        \n        // Quality metrics\n        quality: this.calculateQualityScore(),\n        \n        // Page context\n        pageContext: {\n          title: document.title,\n          url: window.location.href,\n          timestamp: Date.now(),\n          viewport: this.getViewportInfo(),\n          userAgent: navigator.userAgent\n        },\n        \n        // Data structure info\n        dataStructure: {\n          enhancedDataGroups: 6,\n          version: '2.0',\n          features: [\n            'multi-selector-generation',\n            'enhanced-element-analysis', \n            'visual-context-collection',\n            'dom-hierarchy-mapping',\n            'state-change-detection',\n            'detailed-interaction-metadata'\n          ]\n        }\n      };\n      \n      // Apply comprehensive PII sanitization to entire session data\n      return this.sanitizeData(sessionData);\n    }\n\n    // Calculate session quality score\n    calculateQualityScore() {\n      if (this.events.length === 0) return 0;\n      \n      let score = 0;\n      let totalChecks = 0;\n      \n      // Check for enhanced data completeness\n      this.events.forEach(event => {\n        totalChecks++;\n        \n        // Check for selector data\n        if (event.selectors && event.selectors.primary) score += 20;\n        \n        // Check for element analysis\n        if (event.element && event.element.tag) score += 20;\n        \n        // Check for visual context\n        if (event.visual && event.visual.boundingBox) score += 20;\n        \n        // Check for DOM context\n        if (event.context && event.context.parentElements) score += 20;\n        \n        // Check for interaction metadata\n        if (event.interaction && event.interaction.coordinates) score += 20;\n      });\n      \n      return totalChecks > 0 ? Math.round(score / totalChecks) : 0;\n    }\n\n    // Get current tracking status\n    getStatus() {\n      return {\n        isTracking: this.isTracking,\n        sessionId: this.sessionId,\n        eventCount: this.events.length,\n        screenshotCount: this.screenshots.length,\n        duration: this.isTracking ? Date.now() - this.startTime : 0,\n        quality: this.calculateQualityScore()\n      };\n    }\n  }\n\n  // Initialize the tracker\n  window.UnifiedCodeSightTracker = new UnifiedCodeSightTracker();\n  \n  // 🔍 TEST: Immediate console log to verify script loading\n  console.log('🚀 CodeSight Enhanced Tracker Loaded!', new Date().toISOString());\n\n})();"],"names":[],"sourceRoot":""}