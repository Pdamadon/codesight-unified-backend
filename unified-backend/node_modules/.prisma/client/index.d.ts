
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UnifiedSession
 * 
 */
export type UnifiedSession = $Result.DefaultSelection<Prisma.$UnifiedSessionPayload>
/**
 * Model Interaction
 * 
 */
export type Interaction = $Result.DefaultSelection<Prisma.$InteractionPayload>
/**
 * Model Screenshot
 * 
 */
export type Screenshot = $Result.DefaultSelection<Prisma.$ScreenshotPayload>
/**
 * Model SessionArchive
 * 
 */
export type SessionArchive = $Result.DefaultSelection<Prisma.$SessionArchivePayload>
/**
 * Model TrainingData
 * 
 */
export type TrainingData = $Result.DefaultSelection<Prisma.$TrainingDataPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model QualityReport
 * 
 */
export type QualityReport = $Result.DefaultSelection<Prisma.$QualityReportPayload>
/**
 * Model PsychologyProfile
 * 
 */
export type PsychologyProfile = $Result.DefaultSelection<Prisma.$PsychologyProfilePayload>
/**
 * Model ContextEnhancement
 * 
 */
export type ContextEnhancement = $Result.DefaultSelection<Prisma.$ContextEnhancementPayload>
/**
 * Model VisionAnalysisCache
 * 
 */
export type VisionAnalysisCache = $Result.DefaultSelection<Prisma.$VisionAnalysisCachePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SessionType: {
  HUMAN: 'HUMAN',
  AUTOMATED: 'AUTOMATED',
  HYBRID: 'HYBRID'
};

export type SessionType = (typeof SessionType)[keyof typeof SessionType]


export const SessionStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
  PROCESSING: 'PROCESSING',
  ARCHIVED: 'ARCHIVED',
  FAILED: 'FAILED'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const ProcessingStatus: {
  PENDING: 'PENDING',
  VALIDATING: 'VALIDATING',
  ENHANCING: 'ENHANCING',
  PSYCHOLOGY_ANALYSIS: 'PSYCHOLOGY_ANALYSIS',
  TRAINING: 'TRAINING',
  ARCHIVING: 'ARCHIVING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type ProcessingStatus = (typeof ProcessingStatus)[keyof typeof ProcessingStatus]


export const PersonalityType: {
  ANALYTICAL: 'ANALYTICAL',
  IMPULSIVE: 'IMPULSIVE',
  CAUTIOUS: 'CAUTIOUS',
  SOCIAL: 'SOCIAL',
  PRACTICAL: 'PRACTICAL'
};

export type PersonalityType = (typeof PersonalityType)[keyof typeof PersonalityType]


export const EmotionalState: {
  EXCITED: 'EXCITED',
  FRUSTRATED: 'FRUSTRATED',
  CONFIDENT: 'CONFIDENT',
  UNCERTAIN: 'UNCERTAIN',
  NEUTRAL: 'NEUTRAL'
};

export type EmotionalState = (typeof EmotionalState)[keyof typeof EmotionalState]


export const DecisionMakingStyle: {
  QUICK: 'QUICK',
  DELIBERATE: 'DELIBERATE',
  COMPARISON_HEAVY: 'COMPARISON_HEAVY',
  RESEARCH_DRIVEN: 'RESEARCH_DRIVEN'
};

export type DecisionMakingStyle = (typeof DecisionMakingStyle)[keyof typeof DecisionMakingStyle]


export const InteractionType: {
  CLICK: 'CLICK',
  INPUT: 'INPUT',
  SCROLL: 'SCROLL',
  NAVIGATION: 'NAVIGATION',
  HOVER: 'HOVER',
  FOCUS: 'FOCUS',
  BLUR: 'BLUR',
  FORM_SUBMIT: 'FORM_SUBMIT',
  KEY_PRESS: 'KEY_PRESS',
  DRAG: 'DRAG',
  DROP: 'DROP',
  TOUCH: 'TOUCH'
};

export type InteractionType = (typeof InteractionType)[keyof typeof InteractionType]


export const ArchiveStatus: {
  CREATING: 'CREATING',
  UPLOADING: 'UPLOADING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type ArchiveStatus = (typeof ArchiveStatus)[keyof typeof ArchiveStatus]


export const TrainingStatus: {
  PENDING: 'PENDING',
  GENERATING: 'GENERATING',
  UPLOADING: 'UPLOADING',
  TRAINING: 'TRAINING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type TrainingStatus = (typeof TrainingStatus)[keyof typeof TrainingStatus]

}

export type SessionType = $Enums.SessionType

export const SessionType: typeof $Enums.SessionType

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type ProcessingStatus = $Enums.ProcessingStatus

export const ProcessingStatus: typeof $Enums.ProcessingStatus

export type PersonalityType = $Enums.PersonalityType

export const PersonalityType: typeof $Enums.PersonalityType

export type EmotionalState = $Enums.EmotionalState

export const EmotionalState: typeof $Enums.EmotionalState

export type DecisionMakingStyle = $Enums.DecisionMakingStyle

export const DecisionMakingStyle: typeof $Enums.DecisionMakingStyle

export type InteractionType = $Enums.InteractionType

export const InteractionType: typeof $Enums.InteractionType

export type ArchiveStatus = $Enums.ArchiveStatus

export const ArchiveStatus: typeof $Enums.ArchiveStatus

export type TrainingStatus = $Enums.TrainingStatus

export const TrainingStatus: typeof $Enums.TrainingStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UnifiedSessions
 * const unifiedSessions = await prisma.unifiedSession.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UnifiedSessions
   * const unifiedSessions = await prisma.unifiedSession.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.unifiedSession`: Exposes CRUD operations for the **UnifiedSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnifiedSessions
    * const unifiedSessions = await prisma.unifiedSession.findMany()
    * ```
    */
  get unifiedSession(): Prisma.UnifiedSessionDelegate<ExtArgs>;

  /**
   * `prisma.interaction`: Exposes CRUD operations for the **Interaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interactions
    * const interactions = await prisma.interaction.findMany()
    * ```
    */
  get interaction(): Prisma.InteractionDelegate<ExtArgs>;

  /**
   * `prisma.screenshot`: Exposes CRUD operations for the **Screenshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Screenshots
    * const screenshots = await prisma.screenshot.findMany()
    * ```
    */
  get screenshot(): Prisma.ScreenshotDelegate<ExtArgs>;

  /**
   * `prisma.sessionArchive`: Exposes CRUD operations for the **SessionArchive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionArchives
    * const sessionArchives = await prisma.sessionArchive.findMany()
    * ```
    */
  get sessionArchive(): Prisma.SessionArchiveDelegate<ExtArgs>;

  /**
   * `prisma.trainingData`: Exposes CRUD operations for the **TrainingData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingData
    * const trainingData = await prisma.trainingData.findMany()
    * ```
    */
  get trainingData(): Prisma.TrainingDataDelegate<ExtArgs>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs>;

  /**
   * `prisma.qualityReport`: Exposes CRUD operations for the **QualityReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QualityReports
    * const qualityReports = await prisma.qualityReport.findMany()
    * ```
    */
  get qualityReport(): Prisma.QualityReportDelegate<ExtArgs>;

  /**
   * `prisma.psychologyProfile`: Exposes CRUD operations for the **PsychologyProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PsychologyProfiles
    * const psychologyProfiles = await prisma.psychologyProfile.findMany()
    * ```
    */
  get psychologyProfile(): Prisma.PsychologyProfileDelegate<ExtArgs>;

  /**
   * `prisma.contextEnhancement`: Exposes CRUD operations for the **ContextEnhancement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextEnhancements
    * const contextEnhancements = await prisma.contextEnhancement.findMany()
    * ```
    */
  get contextEnhancement(): Prisma.ContextEnhancementDelegate<ExtArgs>;

  /**
   * `prisma.visionAnalysisCache`: Exposes CRUD operations for the **VisionAnalysisCache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisionAnalysisCaches
    * const visionAnalysisCaches = await prisma.visionAnalysisCache.findMany()
    * ```
    */
  get visionAnalysisCache(): Prisma.VisionAnalysisCacheDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UnifiedSession: 'UnifiedSession',
    Interaction: 'Interaction',
    Screenshot: 'Screenshot',
    SessionArchive: 'SessionArchive',
    TrainingData: 'TrainingData',
    SystemConfig: 'SystemConfig',
    QualityReport: 'QualityReport',
    PsychologyProfile: 'PsychologyProfile',
    ContextEnhancement: 'ContextEnhancement',
    VisionAnalysisCache: 'VisionAnalysisCache'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "unifiedSession" | "interaction" | "screenshot" | "sessionArchive" | "trainingData" | "systemConfig" | "qualityReport" | "psychologyProfile" | "contextEnhancement" | "visionAnalysisCache"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UnifiedSession: {
        payload: Prisma.$UnifiedSessionPayload<ExtArgs>
        fields: Prisma.UnifiedSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnifiedSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnifiedSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedSessionPayload>
          }
          findFirst: {
            args: Prisma.UnifiedSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnifiedSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedSessionPayload>
          }
          findMany: {
            args: Prisma.UnifiedSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedSessionPayload>[]
          }
          create: {
            args: Prisma.UnifiedSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedSessionPayload>
          }
          createMany: {
            args: Prisma.UnifiedSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnifiedSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedSessionPayload>[]
          }
          delete: {
            args: Prisma.UnifiedSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedSessionPayload>
          }
          update: {
            args: Prisma.UnifiedSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedSessionPayload>
          }
          deleteMany: {
            args: Prisma.UnifiedSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnifiedSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UnifiedSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnifiedSessionPayload>
          }
          aggregate: {
            args: Prisma.UnifiedSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnifiedSession>
          }
          groupBy: {
            args: Prisma.UnifiedSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnifiedSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnifiedSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UnifiedSessionCountAggregateOutputType> | number
          }
        }
      }
      Interaction: {
        payload: Prisma.$InteractionPayload<ExtArgs>
        fields: Prisma.InteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findFirst: {
            args: Prisma.InteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findMany: {
            args: Prisma.InteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          create: {
            args: Prisma.InteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          createMany: {
            args: Prisma.InteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          delete: {
            args: Prisma.InteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          update: {
            args: Prisma.InteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          deleteMany: {
            args: Prisma.InteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          aggregate: {
            args: Prisma.InteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteraction>
          }
          groupBy: {
            args: Prisma.InteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractionCountArgs<ExtArgs>
            result: $Utils.Optional<InteractionCountAggregateOutputType> | number
          }
        }
      }
      Screenshot: {
        payload: Prisma.$ScreenshotPayload<ExtArgs>
        fields: Prisma.ScreenshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScreenshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScreenshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          findFirst: {
            args: Prisma.ScreenshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScreenshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          findMany: {
            args: Prisma.ScreenshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>[]
          }
          create: {
            args: Prisma.ScreenshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          createMany: {
            args: Prisma.ScreenshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScreenshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>[]
          }
          delete: {
            args: Prisma.ScreenshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          update: {
            args: Prisma.ScreenshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          deleteMany: {
            args: Prisma.ScreenshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScreenshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScreenshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          aggregate: {
            args: Prisma.ScreenshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScreenshot>
          }
          groupBy: {
            args: Prisma.ScreenshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScreenshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScreenshotCountArgs<ExtArgs>
            result: $Utils.Optional<ScreenshotCountAggregateOutputType> | number
          }
        }
      }
      SessionArchive: {
        payload: Prisma.$SessionArchivePayload<ExtArgs>
        fields: Prisma.SessionArchiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionArchiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionArchivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionArchiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionArchivePayload>
          }
          findFirst: {
            args: Prisma.SessionArchiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionArchivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionArchiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionArchivePayload>
          }
          findMany: {
            args: Prisma.SessionArchiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionArchivePayload>[]
          }
          create: {
            args: Prisma.SessionArchiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionArchivePayload>
          }
          createMany: {
            args: Prisma.SessionArchiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionArchiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionArchivePayload>[]
          }
          delete: {
            args: Prisma.SessionArchiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionArchivePayload>
          }
          update: {
            args: Prisma.SessionArchiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionArchivePayload>
          }
          deleteMany: {
            args: Prisma.SessionArchiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionArchiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionArchiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionArchivePayload>
          }
          aggregate: {
            args: Prisma.SessionArchiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionArchive>
          }
          groupBy: {
            args: Prisma.SessionArchiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionArchiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionArchiveCountArgs<ExtArgs>
            result: $Utils.Optional<SessionArchiveCountAggregateOutputType> | number
          }
        }
      }
      TrainingData: {
        payload: Prisma.$TrainingDataPayload<ExtArgs>
        fields: Prisma.TrainingDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDataPayload>
          }
          findFirst: {
            args: Prisma.TrainingDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDataPayload>
          }
          findMany: {
            args: Prisma.TrainingDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDataPayload>[]
          }
          create: {
            args: Prisma.TrainingDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDataPayload>
          }
          createMany: {
            args: Prisma.TrainingDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDataPayload>[]
          }
          delete: {
            args: Prisma.TrainingDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDataPayload>
          }
          update: {
            args: Prisma.TrainingDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDataPayload>
          }
          deleteMany: {
            args: Prisma.TrainingDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingDataPayload>
          }
          aggregate: {
            args: Prisma.TrainingDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingData>
          }
          groupBy: {
            args: Prisma.TrainingDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingDataCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingDataCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      QualityReport: {
        payload: Prisma.$QualityReportPayload<ExtArgs>
        fields: Prisma.QualityReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QualityReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QualityReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityReportPayload>
          }
          findFirst: {
            args: Prisma.QualityReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QualityReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityReportPayload>
          }
          findMany: {
            args: Prisma.QualityReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityReportPayload>[]
          }
          create: {
            args: Prisma.QualityReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityReportPayload>
          }
          createMany: {
            args: Prisma.QualityReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QualityReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityReportPayload>[]
          }
          delete: {
            args: Prisma.QualityReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityReportPayload>
          }
          update: {
            args: Prisma.QualityReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityReportPayload>
          }
          deleteMany: {
            args: Prisma.QualityReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QualityReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QualityReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QualityReportPayload>
          }
          aggregate: {
            args: Prisma.QualityReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQualityReport>
          }
          groupBy: {
            args: Prisma.QualityReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<QualityReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.QualityReportCountArgs<ExtArgs>
            result: $Utils.Optional<QualityReportCountAggregateOutputType> | number
          }
        }
      }
      PsychologyProfile: {
        payload: Prisma.$PsychologyProfilePayload<ExtArgs>
        fields: Prisma.PsychologyProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PsychologyProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PsychologyProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PsychologyProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PsychologyProfilePayload>
          }
          findFirst: {
            args: Prisma.PsychologyProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PsychologyProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PsychologyProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PsychologyProfilePayload>
          }
          findMany: {
            args: Prisma.PsychologyProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PsychologyProfilePayload>[]
          }
          create: {
            args: Prisma.PsychologyProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PsychologyProfilePayload>
          }
          createMany: {
            args: Prisma.PsychologyProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PsychologyProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PsychologyProfilePayload>[]
          }
          delete: {
            args: Prisma.PsychologyProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PsychologyProfilePayload>
          }
          update: {
            args: Prisma.PsychologyProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PsychologyProfilePayload>
          }
          deleteMany: {
            args: Prisma.PsychologyProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PsychologyProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PsychologyProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PsychologyProfilePayload>
          }
          aggregate: {
            args: Prisma.PsychologyProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePsychologyProfile>
          }
          groupBy: {
            args: Prisma.PsychologyProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<PsychologyProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.PsychologyProfileCountArgs<ExtArgs>
            result: $Utils.Optional<PsychologyProfileCountAggregateOutputType> | number
          }
        }
      }
      ContextEnhancement: {
        payload: Prisma.$ContextEnhancementPayload<ExtArgs>
        fields: Prisma.ContextEnhancementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextEnhancementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextEnhancementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextEnhancementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextEnhancementPayload>
          }
          findFirst: {
            args: Prisma.ContextEnhancementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextEnhancementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextEnhancementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextEnhancementPayload>
          }
          findMany: {
            args: Prisma.ContextEnhancementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextEnhancementPayload>[]
          }
          create: {
            args: Prisma.ContextEnhancementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextEnhancementPayload>
          }
          createMany: {
            args: Prisma.ContextEnhancementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContextEnhancementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextEnhancementPayload>[]
          }
          delete: {
            args: Prisma.ContextEnhancementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextEnhancementPayload>
          }
          update: {
            args: Prisma.ContextEnhancementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextEnhancementPayload>
          }
          deleteMany: {
            args: Prisma.ContextEnhancementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContextEnhancementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContextEnhancementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContextEnhancementPayload>
          }
          aggregate: {
            args: Prisma.ContextEnhancementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContextEnhancement>
          }
          groupBy: {
            args: Prisma.ContextEnhancementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContextEnhancementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextEnhancementCountArgs<ExtArgs>
            result: $Utils.Optional<ContextEnhancementCountAggregateOutputType> | number
          }
        }
      }
      VisionAnalysisCache: {
        payload: Prisma.$VisionAnalysisCachePayload<ExtArgs>
        fields: Prisma.VisionAnalysisCacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisionAnalysisCacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionAnalysisCachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisionAnalysisCacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionAnalysisCachePayload>
          }
          findFirst: {
            args: Prisma.VisionAnalysisCacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionAnalysisCachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisionAnalysisCacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionAnalysisCachePayload>
          }
          findMany: {
            args: Prisma.VisionAnalysisCacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionAnalysisCachePayload>[]
          }
          create: {
            args: Prisma.VisionAnalysisCacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionAnalysisCachePayload>
          }
          createMany: {
            args: Prisma.VisionAnalysisCacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VisionAnalysisCacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionAnalysisCachePayload>[]
          }
          delete: {
            args: Prisma.VisionAnalysisCacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionAnalysisCachePayload>
          }
          update: {
            args: Prisma.VisionAnalysisCacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionAnalysisCachePayload>
          }
          deleteMany: {
            args: Prisma.VisionAnalysisCacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisionAnalysisCacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisionAnalysisCacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisionAnalysisCachePayload>
          }
          aggregate: {
            args: Prisma.VisionAnalysisCacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisionAnalysisCache>
          }
          groupBy: {
            args: Prisma.VisionAnalysisCacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisionAnalysisCacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisionAnalysisCacheCountArgs<ExtArgs>
            result: $Utils.Optional<VisionAnalysisCacheCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UnifiedSessionCountOutputType
   */

  export type UnifiedSessionCountOutputType = {
    interactions: number
    screenshots: number
    archives: number
  }

  export type UnifiedSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interactions?: boolean | UnifiedSessionCountOutputTypeCountInteractionsArgs
    screenshots?: boolean | UnifiedSessionCountOutputTypeCountScreenshotsArgs
    archives?: boolean | UnifiedSessionCountOutputTypeCountArchivesArgs
  }

  // Custom InputTypes
  /**
   * UnifiedSessionCountOutputType without action
   */
  export type UnifiedSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSessionCountOutputType
     */
    select?: UnifiedSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnifiedSessionCountOutputType without action
   */
  export type UnifiedSessionCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
  }

  /**
   * UnifiedSessionCountOutputType without action
   */
  export type UnifiedSessionCountOutputTypeCountScreenshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenshotWhereInput
  }

  /**
   * UnifiedSessionCountOutputType without action
   */
  export type UnifiedSessionCountOutputTypeCountArchivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionArchiveWhereInput
  }


  /**
   * Count Type InteractionCountOutputType
   */

  export type InteractionCountOutputType = {
    relatedScreenshots: number
  }

  export type InteractionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedScreenshots?: boolean | InteractionCountOutputTypeCountRelatedScreenshotsArgs
  }

  // Custom InputTypes
  /**
   * InteractionCountOutputType without action
   */
  export type InteractionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InteractionCountOutputType
     */
    select?: InteractionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InteractionCountOutputType without action
   */
  export type InteractionCountOutputTypeCountRelatedScreenshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenshotWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UnifiedSession
   */

  export type AggregateUnifiedSession = {
    _count: UnifiedSessionCountAggregateOutputType | null
    _avg: UnifiedSessionAvgAggregateOutputType | null
    _sum: UnifiedSessionSumAggregateOutputType | null
    _min: UnifiedSessionMinAggregateOutputType | null
    _max: UnifiedSessionMaxAggregateOutputType | null
  }

  export type UnifiedSessionAvgAggregateOutputType = {
    duration: number | null
    qualityScore: number | null
    completeness: number | null
    reliability: number | null
    trainingValue: number | null
    trustLevel: number | null
    urgencyLevel: number | null
    priceSensitivity: number | null
    socialInfluence: number | null
    psychologyConfidence: number | null
    purchaseReadiness: number | null
    navigationEfficiency: number | null
  }

  export type UnifiedSessionSumAggregateOutputType = {
    duration: number | null
    qualityScore: number | null
    completeness: number | null
    reliability: number | null
    trainingValue: number | null
    trustLevel: number | null
    urgencyLevel: number | null
    priceSensitivity: number | null
    socialInfluence: number | null
    psychologyConfidence: number | null
    purchaseReadiness: number | null
    navigationEfficiency: number | null
  }

  export type UnifiedSessionMinAggregateOutputType = {
    id: string | null
    type: $Enums.SessionType | null
    status: $Enums.SessionStatus | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    archiveUrl: string | null
    trainingFileId: string | null
    modelId: string | null
    qualityScore: number | null
    completeness: number | null
    reliability: number | null
    trainingValue: number | null
    processingStatus: $Enums.ProcessingStatus | null
    workerId: string | null
    userAgent: string | null
    ipAddress: string | null
    dominantPersonality: $Enums.PersonalityType | null
    emotionalState: $Enums.EmotionalState | null
    decisionMakingStyle: $Enums.DecisionMakingStyle | null
    trustLevel: number | null
    urgencyLevel: number | null
    priceSensitivity: number | null
    socialInfluence: number | null
    psychologyConfidence: number | null
    pageType: string | null
    userIntent: string | null
    shoppingStage: string | null
    behaviorType: string | null
    purchaseReadiness: number | null
    navigationEfficiency: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnifiedSessionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.SessionType | null
    status: $Enums.SessionStatus | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    archiveUrl: string | null
    trainingFileId: string | null
    modelId: string | null
    qualityScore: number | null
    completeness: number | null
    reliability: number | null
    trainingValue: number | null
    processingStatus: $Enums.ProcessingStatus | null
    workerId: string | null
    userAgent: string | null
    ipAddress: string | null
    dominantPersonality: $Enums.PersonalityType | null
    emotionalState: $Enums.EmotionalState | null
    decisionMakingStyle: $Enums.DecisionMakingStyle | null
    trustLevel: number | null
    urgencyLevel: number | null
    priceSensitivity: number | null
    socialInfluence: number | null
    psychologyConfidence: number | null
    pageType: string | null
    userIntent: string | null
    shoppingStage: string | null
    behaviorType: string | null
    purchaseReadiness: number | null
    navigationEfficiency: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnifiedSessionCountAggregateOutputType = {
    id: number
    type: number
    status: number
    startTime: number
    endTime: number
    duration: number
    archiveUrl: number
    trainingFileId: number
    modelId: number
    qualityScore: number
    completeness: number
    reliability: number
    trainingValue: number
    processingStatus: number
    processingSteps: number
    processingErrors: number
    config: number
    workerId: number
    userAgent: number
    ipAddress: number
    trainingMetrics: number
    modelPerformance: number
    dominantPersonality: number
    emotionalState: number
    decisionMakingStyle: number
    trustLevel: number
    urgencyLevel: number
    priceSensitivity: number
    socialInfluence: number
    psychologyConfidence: number
    pageType: number
    userIntent: number
    shoppingStage: number
    behaviorType: number
    purchaseReadiness: number
    navigationEfficiency: number
    contextualInsights: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnifiedSessionAvgAggregateInputType = {
    duration?: true
    qualityScore?: true
    completeness?: true
    reliability?: true
    trainingValue?: true
    trustLevel?: true
    urgencyLevel?: true
    priceSensitivity?: true
    socialInfluence?: true
    psychologyConfidence?: true
    purchaseReadiness?: true
    navigationEfficiency?: true
  }

  export type UnifiedSessionSumAggregateInputType = {
    duration?: true
    qualityScore?: true
    completeness?: true
    reliability?: true
    trainingValue?: true
    trustLevel?: true
    urgencyLevel?: true
    priceSensitivity?: true
    socialInfluence?: true
    psychologyConfidence?: true
    purchaseReadiness?: true
    navigationEfficiency?: true
  }

  export type UnifiedSessionMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    startTime?: true
    endTime?: true
    duration?: true
    archiveUrl?: true
    trainingFileId?: true
    modelId?: true
    qualityScore?: true
    completeness?: true
    reliability?: true
    trainingValue?: true
    processingStatus?: true
    workerId?: true
    userAgent?: true
    ipAddress?: true
    dominantPersonality?: true
    emotionalState?: true
    decisionMakingStyle?: true
    trustLevel?: true
    urgencyLevel?: true
    priceSensitivity?: true
    socialInfluence?: true
    psychologyConfidence?: true
    pageType?: true
    userIntent?: true
    shoppingStage?: true
    behaviorType?: true
    purchaseReadiness?: true
    navigationEfficiency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnifiedSessionMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    startTime?: true
    endTime?: true
    duration?: true
    archiveUrl?: true
    trainingFileId?: true
    modelId?: true
    qualityScore?: true
    completeness?: true
    reliability?: true
    trainingValue?: true
    processingStatus?: true
    workerId?: true
    userAgent?: true
    ipAddress?: true
    dominantPersonality?: true
    emotionalState?: true
    decisionMakingStyle?: true
    trustLevel?: true
    urgencyLevel?: true
    priceSensitivity?: true
    socialInfluence?: true
    psychologyConfidence?: true
    pageType?: true
    userIntent?: true
    shoppingStage?: true
    behaviorType?: true
    purchaseReadiness?: true
    navigationEfficiency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnifiedSessionCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    startTime?: true
    endTime?: true
    duration?: true
    archiveUrl?: true
    trainingFileId?: true
    modelId?: true
    qualityScore?: true
    completeness?: true
    reliability?: true
    trainingValue?: true
    processingStatus?: true
    processingSteps?: true
    processingErrors?: true
    config?: true
    workerId?: true
    userAgent?: true
    ipAddress?: true
    trainingMetrics?: true
    modelPerformance?: true
    dominantPersonality?: true
    emotionalState?: true
    decisionMakingStyle?: true
    trustLevel?: true
    urgencyLevel?: true
    priceSensitivity?: true
    socialInfluence?: true
    psychologyConfidence?: true
    pageType?: true
    userIntent?: true
    shoppingStage?: true
    behaviorType?: true
    purchaseReadiness?: true
    navigationEfficiency?: true
    contextualInsights?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnifiedSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnifiedSession to aggregate.
     */
    where?: UnifiedSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedSessions to fetch.
     */
    orderBy?: UnifiedSessionOrderByWithRelationInput | UnifiedSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnifiedSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnifiedSessions
    **/
    _count?: true | UnifiedSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnifiedSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnifiedSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnifiedSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnifiedSessionMaxAggregateInputType
  }

  export type GetUnifiedSessionAggregateType<T extends UnifiedSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUnifiedSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnifiedSession[P]>
      : GetScalarType<T[P], AggregateUnifiedSession[P]>
  }




  export type UnifiedSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnifiedSessionWhereInput
    orderBy?: UnifiedSessionOrderByWithAggregationInput | UnifiedSessionOrderByWithAggregationInput[]
    by: UnifiedSessionScalarFieldEnum[] | UnifiedSessionScalarFieldEnum
    having?: UnifiedSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnifiedSessionCountAggregateInputType | true
    _avg?: UnifiedSessionAvgAggregateInputType
    _sum?: UnifiedSessionSumAggregateInputType
    _min?: UnifiedSessionMinAggregateInputType
    _max?: UnifiedSessionMaxAggregateInputType
  }

  export type UnifiedSessionGroupByOutputType = {
    id: string
    type: $Enums.SessionType
    status: $Enums.SessionStatus
    startTime: Date
    endTime: Date | null
    duration: number | null
    archiveUrl: string | null
    trainingFileId: string | null
    modelId: string | null
    qualityScore: number
    completeness: number
    reliability: number
    trainingValue: number
    processingStatus: $Enums.ProcessingStatus
    processingSteps: JsonValue
    processingErrors: JsonValue
    config: JsonValue
    workerId: string | null
    userAgent: string | null
    ipAddress: string | null
    trainingMetrics: JsonValue | null
    modelPerformance: JsonValue | null
    dominantPersonality: $Enums.PersonalityType | null
    emotionalState: $Enums.EmotionalState | null
    decisionMakingStyle: $Enums.DecisionMakingStyle | null
    trustLevel: number | null
    urgencyLevel: number | null
    priceSensitivity: number | null
    socialInfluence: number | null
    psychologyConfidence: number | null
    pageType: string | null
    userIntent: string | null
    shoppingStage: string | null
    behaviorType: string | null
    purchaseReadiness: number | null
    navigationEfficiency: number | null
    contextualInsights: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UnifiedSessionCountAggregateOutputType | null
    _avg: UnifiedSessionAvgAggregateOutputType | null
    _sum: UnifiedSessionSumAggregateOutputType | null
    _min: UnifiedSessionMinAggregateOutputType | null
    _max: UnifiedSessionMaxAggregateOutputType | null
  }

  type GetUnifiedSessionGroupByPayload<T extends UnifiedSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnifiedSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnifiedSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnifiedSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UnifiedSessionGroupByOutputType[P]>
        }
      >
    >


  export type UnifiedSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    archiveUrl?: boolean
    trainingFileId?: boolean
    modelId?: boolean
    qualityScore?: boolean
    completeness?: boolean
    reliability?: boolean
    trainingValue?: boolean
    processingStatus?: boolean
    processingSteps?: boolean
    processingErrors?: boolean
    config?: boolean
    workerId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    trainingMetrics?: boolean
    modelPerformance?: boolean
    dominantPersonality?: boolean
    emotionalState?: boolean
    decisionMakingStyle?: boolean
    trustLevel?: boolean
    urgencyLevel?: boolean
    priceSensitivity?: boolean
    socialInfluence?: boolean
    psychologyConfidence?: boolean
    pageType?: boolean
    userIntent?: boolean
    shoppingStage?: boolean
    behaviorType?: boolean
    purchaseReadiness?: boolean
    navigationEfficiency?: boolean
    contextualInsights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    interactions?: boolean | UnifiedSession$interactionsArgs<ExtArgs>
    screenshots?: boolean | UnifiedSession$screenshotsArgs<ExtArgs>
    archives?: boolean | UnifiedSession$archivesArgs<ExtArgs>
    _count?: boolean | UnifiedSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unifiedSession"]>

  export type UnifiedSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    archiveUrl?: boolean
    trainingFileId?: boolean
    modelId?: boolean
    qualityScore?: boolean
    completeness?: boolean
    reliability?: boolean
    trainingValue?: boolean
    processingStatus?: boolean
    processingSteps?: boolean
    processingErrors?: boolean
    config?: boolean
    workerId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    trainingMetrics?: boolean
    modelPerformance?: boolean
    dominantPersonality?: boolean
    emotionalState?: boolean
    decisionMakingStyle?: boolean
    trustLevel?: boolean
    urgencyLevel?: boolean
    priceSensitivity?: boolean
    socialInfluence?: boolean
    psychologyConfidence?: boolean
    pageType?: boolean
    userIntent?: boolean
    shoppingStage?: boolean
    behaviorType?: boolean
    purchaseReadiness?: boolean
    navigationEfficiency?: boolean
    contextualInsights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["unifiedSession"]>

  export type UnifiedSessionSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    archiveUrl?: boolean
    trainingFileId?: boolean
    modelId?: boolean
    qualityScore?: boolean
    completeness?: boolean
    reliability?: boolean
    trainingValue?: boolean
    processingStatus?: boolean
    processingSteps?: boolean
    processingErrors?: boolean
    config?: boolean
    workerId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    trainingMetrics?: boolean
    modelPerformance?: boolean
    dominantPersonality?: boolean
    emotionalState?: boolean
    decisionMakingStyle?: boolean
    trustLevel?: boolean
    urgencyLevel?: boolean
    priceSensitivity?: boolean
    socialInfluence?: boolean
    psychologyConfidence?: boolean
    pageType?: boolean
    userIntent?: boolean
    shoppingStage?: boolean
    behaviorType?: boolean
    purchaseReadiness?: boolean
    navigationEfficiency?: boolean
    contextualInsights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnifiedSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interactions?: boolean | UnifiedSession$interactionsArgs<ExtArgs>
    screenshots?: boolean | UnifiedSession$screenshotsArgs<ExtArgs>
    archives?: boolean | UnifiedSession$archivesArgs<ExtArgs>
    _count?: boolean | UnifiedSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnifiedSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UnifiedSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UnifiedSession"
    objects: {
      interactions: Prisma.$InteractionPayload<ExtArgs>[]
      screenshots: Prisma.$ScreenshotPayload<ExtArgs>[]
      archives: Prisma.$SessionArchivePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.SessionType
      status: $Enums.SessionStatus
      startTime: Date
      endTime: Date | null
      duration: number | null
      archiveUrl: string | null
      trainingFileId: string | null
      modelId: string | null
      qualityScore: number
      completeness: number
      reliability: number
      trainingValue: number
      processingStatus: $Enums.ProcessingStatus
      processingSteps: Prisma.JsonValue
      processingErrors: Prisma.JsonValue
      config: Prisma.JsonValue
      workerId: string | null
      userAgent: string | null
      ipAddress: string | null
      trainingMetrics: Prisma.JsonValue | null
      modelPerformance: Prisma.JsonValue | null
      dominantPersonality: $Enums.PersonalityType | null
      emotionalState: $Enums.EmotionalState | null
      decisionMakingStyle: $Enums.DecisionMakingStyle | null
      trustLevel: number | null
      urgencyLevel: number | null
      priceSensitivity: number | null
      socialInfluence: number | null
      psychologyConfidence: number | null
      pageType: string | null
      userIntent: string | null
      shoppingStage: string | null
      behaviorType: string | null
      purchaseReadiness: number | null
      navigationEfficiency: number | null
      contextualInsights: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["unifiedSession"]>
    composites: {}
  }

  type UnifiedSessionGetPayload<S extends boolean | null | undefined | UnifiedSessionDefaultArgs> = $Result.GetResult<Prisma.$UnifiedSessionPayload, S>

  type UnifiedSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnifiedSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnifiedSessionCountAggregateInputType | true
    }

  export interface UnifiedSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UnifiedSession'], meta: { name: 'UnifiedSession' } }
    /**
     * Find zero or one UnifiedSession that matches the filter.
     * @param {UnifiedSessionFindUniqueArgs} args - Arguments to find a UnifiedSession
     * @example
     * // Get one UnifiedSession
     * const unifiedSession = await prisma.unifiedSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnifiedSessionFindUniqueArgs>(args: SelectSubset<T, UnifiedSessionFindUniqueArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UnifiedSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UnifiedSessionFindUniqueOrThrowArgs} args - Arguments to find a UnifiedSession
     * @example
     * // Get one UnifiedSession
     * const unifiedSession = await prisma.unifiedSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnifiedSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UnifiedSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UnifiedSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedSessionFindFirstArgs} args - Arguments to find a UnifiedSession
     * @example
     * // Get one UnifiedSession
     * const unifiedSession = await prisma.unifiedSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnifiedSessionFindFirstArgs>(args?: SelectSubset<T, UnifiedSessionFindFirstArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UnifiedSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedSessionFindFirstOrThrowArgs} args - Arguments to find a UnifiedSession
     * @example
     * // Get one UnifiedSession
     * const unifiedSession = await prisma.unifiedSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnifiedSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UnifiedSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UnifiedSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnifiedSessions
     * const unifiedSessions = await prisma.unifiedSession.findMany()
     * 
     * // Get first 10 UnifiedSessions
     * const unifiedSessions = await prisma.unifiedSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unifiedSessionWithIdOnly = await prisma.unifiedSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UnifiedSessionFindManyArgs>(args?: SelectSubset<T, UnifiedSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UnifiedSession.
     * @param {UnifiedSessionCreateArgs} args - Arguments to create a UnifiedSession.
     * @example
     * // Create one UnifiedSession
     * const UnifiedSession = await prisma.unifiedSession.create({
     *   data: {
     *     // ... data to create a UnifiedSession
     *   }
     * })
     * 
     */
    create<T extends UnifiedSessionCreateArgs>(args: SelectSubset<T, UnifiedSessionCreateArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UnifiedSessions.
     * @param {UnifiedSessionCreateManyArgs} args - Arguments to create many UnifiedSessions.
     * @example
     * // Create many UnifiedSessions
     * const unifiedSession = await prisma.unifiedSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnifiedSessionCreateManyArgs>(args?: SelectSubset<T, UnifiedSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UnifiedSessions and returns the data saved in the database.
     * @param {UnifiedSessionCreateManyAndReturnArgs} args - Arguments to create many UnifiedSessions.
     * @example
     * // Create many UnifiedSessions
     * const unifiedSession = await prisma.unifiedSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UnifiedSessions and only return the `id`
     * const unifiedSessionWithIdOnly = await prisma.unifiedSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnifiedSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UnifiedSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UnifiedSession.
     * @param {UnifiedSessionDeleteArgs} args - Arguments to delete one UnifiedSession.
     * @example
     * // Delete one UnifiedSession
     * const UnifiedSession = await prisma.unifiedSession.delete({
     *   where: {
     *     // ... filter to delete one UnifiedSession
     *   }
     * })
     * 
     */
    delete<T extends UnifiedSessionDeleteArgs>(args: SelectSubset<T, UnifiedSessionDeleteArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UnifiedSession.
     * @param {UnifiedSessionUpdateArgs} args - Arguments to update one UnifiedSession.
     * @example
     * // Update one UnifiedSession
     * const unifiedSession = await prisma.unifiedSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnifiedSessionUpdateArgs>(args: SelectSubset<T, UnifiedSessionUpdateArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UnifiedSessions.
     * @param {UnifiedSessionDeleteManyArgs} args - Arguments to filter UnifiedSessions to delete.
     * @example
     * // Delete a few UnifiedSessions
     * const { count } = await prisma.unifiedSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnifiedSessionDeleteManyArgs>(args?: SelectSubset<T, UnifiedSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnifiedSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnifiedSessions
     * const unifiedSession = await prisma.unifiedSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnifiedSessionUpdateManyArgs>(args: SelectSubset<T, UnifiedSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnifiedSession.
     * @param {UnifiedSessionUpsertArgs} args - Arguments to update or create a UnifiedSession.
     * @example
     * // Update or create a UnifiedSession
     * const unifiedSession = await prisma.unifiedSession.upsert({
     *   create: {
     *     // ... data to create a UnifiedSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnifiedSession we want to update
     *   }
     * })
     */
    upsert<T extends UnifiedSessionUpsertArgs>(args: SelectSubset<T, UnifiedSessionUpsertArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UnifiedSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedSessionCountArgs} args - Arguments to filter UnifiedSessions to count.
     * @example
     * // Count the number of UnifiedSessions
     * const count = await prisma.unifiedSession.count({
     *   where: {
     *     // ... the filter for the UnifiedSessions we want to count
     *   }
     * })
    **/
    count<T extends UnifiedSessionCountArgs>(
      args?: Subset<T, UnifiedSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnifiedSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnifiedSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnifiedSessionAggregateArgs>(args: Subset<T, UnifiedSessionAggregateArgs>): Prisma.PrismaPromise<GetUnifiedSessionAggregateType<T>>

    /**
     * Group by UnifiedSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnifiedSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnifiedSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnifiedSessionGroupByArgs['orderBy'] }
        : { orderBy?: UnifiedSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnifiedSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnifiedSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UnifiedSession model
   */
  readonly fields: UnifiedSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UnifiedSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnifiedSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interactions<T extends UnifiedSession$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, UnifiedSession$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany"> | Null>
    screenshots<T extends UnifiedSession$screenshotsArgs<ExtArgs> = {}>(args?: Subset<T, UnifiedSession$screenshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findMany"> | Null>
    archives<T extends UnifiedSession$archivesArgs<ExtArgs> = {}>(args?: Subset<T, UnifiedSession$archivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UnifiedSession model
   */ 
  interface UnifiedSessionFieldRefs {
    readonly id: FieldRef<"UnifiedSession", 'String'>
    readonly type: FieldRef<"UnifiedSession", 'SessionType'>
    readonly status: FieldRef<"UnifiedSession", 'SessionStatus'>
    readonly startTime: FieldRef<"UnifiedSession", 'DateTime'>
    readonly endTime: FieldRef<"UnifiedSession", 'DateTime'>
    readonly duration: FieldRef<"UnifiedSession", 'Int'>
    readonly archiveUrl: FieldRef<"UnifiedSession", 'String'>
    readonly trainingFileId: FieldRef<"UnifiedSession", 'String'>
    readonly modelId: FieldRef<"UnifiedSession", 'String'>
    readonly qualityScore: FieldRef<"UnifiedSession", 'Float'>
    readonly completeness: FieldRef<"UnifiedSession", 'Float'>
    readonly reliability: FieldRef<"UnifiedSession", 'Float'>
    readonly trainingValue: FieldRef<"UnifiedSession", 'Float'>
    readonly processingStatus: FieldRef<"UnifiedSession", 'ProcessingStatus'>
    readonly processingSteps: FieldRef<"UnifiedSession", 'Json'>
    readonly processingErrors: FieldRef<"UnifiedSession", 'Json'>
    readonly config: FieldRef<"UnifiedSession", 'Json'>
    readonly workerId: FieldRef<"UnifiedSession", 'String'>
    readonly userAgent: FieldRef<"UnifiedSession", 'String'>
    readonly ipAddress: FieldRef<"UnifiedSession", 'String'>
    readonly trainingMetrics: FieldRef<"UnifiedSession", 'Json'>
    readonly modelPerformance: FieldRef<"UnifiedSession", 'Json'>
    readonly dominantPersonality: FieldRef<"UnifiedSession", 'PersonalityType'>
    readonly emotionalState: FieldRef<"UnifiedSession", 'EmotionalState'>
    readonly decisionMakingStyle: FieldRef<"UnifiedSession", 'DecisionMakingStyle'>
    readonly trustLevel: FieldRef<"UnifiedSession", 'Float'>
    readonly urgencyLevel: FieldRef<"UnifiedSession", 'Float'>
    readonly priceSensitivity: FieldRef<"UnifiedSession", 'Float'>
    readonly socialInfluence: FieldRef<"UnifiedSession", 'Float'>
    readonly psychologyConfidence: FieldRef<"UnifiedSession", 'Float'>
    readonly pageType: FieldRef<"UnifiedSession", 'String'>
    readonly userIntent: FieldRef<"UnifiedSession", 'String'>
    readonly shoppingStage: FieldRef<"UnifiedSession", 'String'>
    readonly behaviorType: FieldRef<"UnifiedSession", 'String'>
    readonly purchaseReadiness: FieldRef<"UnifiedSession", 'Float'>
    readonly navigationEfficiency: FieldRef<"UnifiedSession", 'Float'>
    readonly contextualInsights: FieldRef<"UnifiedSession", 'Json'>
    readonly createdAt: FieldRef<"UnifiedSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UnifiedSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UnifiedSession findUnique
   */
  export type UnifiedSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedSessionInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedSession to fetch.
     */
    where: UnifiedSessionWhereUniqueInput
  }

  /**
   * UnifiedSession findUniqueOrThrow
   */
  export type UnifiedSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedSessionInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedSession to fetch.
     */
    where: UnifiedSessionWhereUniqueInput
  }

  /**
   * UnifiedSession findFirst
   */
  export type UnifiedSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedSessionInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedSession to fetch.
     */
    where?: UnifiedSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedSessions to fetch.
     */
    orderBy?: UnifiedSessionOrderByWithRelationInput | UnifiedSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnifiedSessions.
     */
    cursor?: UnifiedSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnifiedSessions.
     */
    distinct?: UnifiedSessionScalarFieldEnum | UnifiedSessionScalarFieldEnum[]
  }

  /**
   * UnifiedSession findFirstOrThrow
   */
  export type UnifiedSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedSessionInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedSession to fetch.
     */
    where?: UnifiedSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedSessions to fetch.
     */
    orderBy?: UnifiedSessionOrderByWithRelationInput | UnifiedSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnifiedSessions.
     */
    cursor?: UnifiedSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnifiedSessions.
     */
    distinct?: UnifiedSessionScalarFieldEnum | UnifiedSessionScalarFieldEnum[]
  }

  /**
   * UnifiedSession findMany
   */
  export type UnifiedSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedSessionInclude<ExtArgs> | null
    /**
     * Filter, which UnifiedSessions to fetch.
     */
    where?: UnifiedSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnifiedSessions to fetch.
     */
    orderBy?: UnifiedSessionOrderByWithRelationInput | UnifiedSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnifiedSessions.
     */
    cursor?: UnifiedSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnifiedSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnifiedSessions.
     */
    skip?: number
    distinct?: UnifiedSessionScalarFieldEnum | UnifiedSessionScalarFieldEnum[]
  }

  /**
   * UnifiedSession create
   */
  export type UnifiedSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UnifiedSession.
     */
    data: XOR<UnifiedSessionCreateInput, UnifiedSessionUncheckedCreateInput>
  }

  /**
   * UnifiedSession createMany
   */
  export type UnifiedSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UnifiedSessions.
     */
    data: UnifiedSessionCreateManyInput | UnifiedSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnifiedSession createManyAndReturn
   */
  export type UnifiedSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UnifiedSessions.
     */
    data: UnifiedSessionCreateManyInput | UnifiedSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UnifiedSession update
   */
  export type UnifiedSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UnifiedSession.
     */
    data: XOR<UnifiedSessionUpdateInput, UnifiedSessionUncheckedUpdateInput>
    /**
     * Choose, which UnifiedSession to update.
     */
    where: UnifiedSessionWhereUniqueInput
  }

  /**
   * UnifiedSession updateMany
   */
  export type UnifiedSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UnifiedSessions.
     */
    data: XOR<UnifiedSessionUpdateManyMutationInput, UnifiedSessionUncheckedUpdateManyInput>
    /**
     * Filter which UnifiedSessions to update
     */
    where?: UnifiedSessionWhereInput
  }

  /**
   * UnifiedSession upsert
   */
  export type UnifiedSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UnifiedSession to update in case it exists.
     */
    where: UnifiedSessionWhereUniqueInput
    /**
     * In case the UnifiedSession found by the `where` argument doesn't exist, create a new UnifiedSession with this data.
     */
    create: XOR<UnifiedSessionCreateInput, UnifiedSessionUncheckedCreateInput>
    /**
     * In case the UnifiedSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnifiedSessionUpdateInput, UnifiedSessionUncheckedUpdateInput>
  }

  /**
   * UnifiedSession delete
   */
  export type UnifiedSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedSessionInclude<ExtArgs> | null
    /**
     * Filter which UnifiedSession to delete.
     */
    where: UnifiedSessionWhereUniqueInput
  }

  /**
   * UnifiedSession deleteMany
   */
  export type UnifiedSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UnifiedSessions to delete
     */
    where?: UnifiedSessionWhereInput
  }

  /**
   * UnifiedSession.interactions
   */
  export type UnifiedSession$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    cursor?: InteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * UnifiedSession.screenshots
   */
  export type UnifiedSession$screenshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    where?: ScreenshotWhereInput
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    cursor?: ScreenshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * UnifiedSession.archives
   */
  export type UnifiedSession$archivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
    where?: SessionArchiveWhereInput
    orderBy?: SessionArchiveOrderByWithRelationInput | SessionArchiveOrderByWithRelationInput[]
    cursor?: SessionArchiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionArchiveScalarFieldEnum | SessionArchiveScalarFieldEnum[]
  }

  /**
   * UnifiedSession without action
   */
  export type UnifiedSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnifiedSession
     */
    select?: UnifiedSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnifiedSessionInclude<ExtArgs> | null
  }


  /**
   * Model Interaction
   */

  export type AggregateInteraction = {
    _count: InteractionCountAggregateOutputType | null
    _avg: InteractionAvgAggregateOutputType | null
    _sum: InteractionSumAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  export type InteractionAvgAggregateOutputType = {
    timestamp: number | null
    sessionTime: number | null
    clientX: number | null
    clientY: number | null
    pageX: number | null
    pageY: number | null
    percentVisible: number | null
    confidence: number | null
  }

  export type InteractionSumAggregateOutputType = {
    timestamp: bigint | null
    sessionTime: number | null
    clientX: number | null
    clientY: number | null
    pageX: number | null
    pageY: number | null
    percentVisible: number | null
    confidence: number | null
  }

  export type InteractionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    type: $Enums.InteractionType | null
    timestamp: bigint | null
    sessionTime: number | null
    primarySelector: string | null
    xpath: string | null
    cssPath: string | null
    elementTag: string | null
    elementText: string | null
    elementValue: string | null
    clientX: number | null
    clientY: number | null
    pageX: number | null
    pageY: number | null
    isInViewport: boolean | null
    percentVisible: number | null
    url: string | null
    pageTitle: string | null
    confidence: number | null
    userIntent: string | null
    userReasoning: string | null
  }

  export type InteractionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    type: $Enums.InteractionType | null
    timestamp: bigint | null
    sessionTime: number | null
    primarySelector: string | null
    xpath: string | null
    cssPath: string | null
    elementTag: string | null
    elementText: string | null
    elementValue: string | null
    clientX: number | null
    clientY: number | null
    pageX: number | null
    pageY: number | null
    isInViewport: boolean | null
    percentVisible: number | null
    url: string | null
    pageTitle: string | null
    confidence: number | null
    userIntent: string | null
    userReasoning: string | null
  }

  export type InteractionCountAggregateOutputType = {
    id: number
    sessionId: number
    type: number
    timestamp: number
    sessionTime: number
    primarySelector: number
    selectorAlternatives: number
    xpath: number
    cssPath: number
    elementTag: number
    elementText: number
    elementValue: number
    elementAttributes: number
    clientX: number
    clientY: number
    pageX: number
    pageY: number
    boundingBox: number
    viewport: number
    isInViewport: number
    percentVisible: number
    url: number
    pageTitle: number
    pageStructure: number
    parentElements: number
    siblingElements: number
    nearbyElements: number
    stateBefore: number
    stateAfter: number
    stateChanges: number
    confidence: number
    selectorReliability: number
    userIntent: number
    userReasoning: number
    visualCues: number
    _all: number
  }


  export type InteractionAvgAggregateInputType = {
    timestamp?: true
    sessionTime?: true
    clientX?: true
    clientY?: true
    pageX?: true
    pageY?: true
    percentVisible?: true
    confidence?: true
  }

  export type InteractionSumAggregateInputType = {
    timestamp?: true
    sessionTime?: true
    clientX?: true
    clientY?: true
    pageX?: true
    pageY?: true
    percentVisible?: true
    confidence?: true
  }

  export type InteractionMinAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    timestamp?: true
    sessionTime?: true
    primarySelector?: true
    xpath?: true
    cssPath?: true
    elementTag?: true
    elementText?: true
    elementValue?: true
    clientX?: true
    clientY?: true
    pageX?: true
    pageY?: true
    isInViewport?: true
    percentVisible?: true
    url?: true
    pageTitle?: true
    confidence?: true
    userIntent?: true
    userReasoning?: true
  }

  export type InteractionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    timestamp?: true
    sessionTime?: true
    primarySelector?: true
    xpath?: true
    cssPath?: true
    elementTag?: true
    elementText?: true
    elementValue?: true
    clientX?: true
    clientY?: true
    pageX?: true
    pageY?: true
    isInViewport?: true
    percentVisible?: true
    url?: true
    pageTitle?: true
    confidence?: true
    userIntent?: true
    userReasoning?: true
  }

  export type InteractionCountAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    timestamp?: true
    sessionTime?: true
    primarySelector?: true
    selectorAlternatives?: true
    xpath?: true
    cssPath?: true
    elementTag?: true
    elementText?: true
    elementValue?: true
    elementAttributes?: true
    clientX?: true
    clientY?: true
    pageX?: true
    pageY?: true
    boundingBox?: true
    viewport?: true
    isInViewport?: true
    percentVisible?: true
    url?: true
    pageTitle?: true
    pageStructure?: true
    parentElements?: true
    siblingElements?: true
    nearbyElements?: true
    stateBefore?: true
    stateAfter?: true
    stateChanges?: true
    confidence?: true
    selectorReliability?: true
    userIntent?: true
    userReasoning?: true
    visualCues?: true
    _all?: true
  }

  export type InteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interaction to aggregate.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interactions
    **/
    _count?: true | InteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InteractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InteractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractionMaxAggregateInputType
  }

  export type GetInteractionAggregateType<T extends InteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteraction[P]>
      : GetScalarType<T[P], AggregateInteraction[P]>
  }




  export type InteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithAggregationInput | InteractionOrderByWithAggregationInput[]
    by: InteractionScalarFieldEnum[] | InteractionScalarFieldEnum
    having?: InteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractionCountAggregateInputType | true
    _avg?: InteractionAvgAggregateInputType
    _sum?: InteractionSumAggregateInputType
    _min?: InteractionMinAggregateInputType
    _max?: InteractionMaxAggregateInputType
  }

  export type InteractionGroupByOutputType = {
    id: string
    sessionId: string
    type: $Enums.InteractionType
    timestamp: bigint
    sessionTime: number
    primarySelector: string
    selectorAlternatives: JsonValue
    xpath: string | null
    cssPath: string | null
    elementTag: string
    elementText: string | null
    elementValue: string | null
    elementAttributes: JsonValue
    clientX: number | null
    clientY: number | null
    pageX: number | null
    pageY: number | null
    boundingBox: JsonValue
    viewport: JsonValue
    isInViewport: boolean
    percentVisible: number
    url: string
    pageTitle: string
    pageStructure: JsonValue
    parentElements: JsonValue
    siblingElements: JsonValue
    nearbyElements: JsonValue
    stateBefore: JsonValue
    stateAfter: JsonValue | null
    stateChanges: JsonValue
    confidence: number
    selectorReliability: JsonValue
    userIntent: string | null
    userReasoning: string | null
    visualCues: JsonValue
    _count: InteractionCountAggregateOutputType | null
    _avg: InteractionAvgAggregateOutputType | null
    _sum: InteractionSumAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  type GetInteractionGroupByPayload<T extends InteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractionGroupByOutputType[P]>
            : GetScalarType<T[P], InteractionGroupByOutputType[P]>
        }
      >
    >


  export type InteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    timestamp?: boolean
    sessionTime?: boolean
    primarySelector?: boolean
    selectorAlternatives?: boolean
    xpath?: boolean
    cssPath?: boolean
    elementTag?: boolean
    elementText?: boolean
    elementValue?: boolean
    elementAttributes?: boolean
    clientX?: boolean
    clientY?: boolean
    pageX?: boolean
    pageY?: boolean
    boundingBox?: boolean
    viewport?: boolean
    isInViewport?: boolean
    percentVisible?: boolean
    url?: boolean
    pageTitle?: boolean
    pageStructure?: boolean
    parentElements?: boolean
    siblingElements?: boolean
    nearbyElements?: boolean
    stateBefore?: boolean
    stateAfter?: boolean
    stateChanges?: boolean
    confidence?: boolean
    selectorReliability?: boolean
    userIntent?: boolean
    userReasoning?: boolean
    visualCues?: boolean
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
    relatedScreenshots?: boolean | Interaction$relatedScreenshotsArgs<ExtArgs>
    _count?: boolean | InteractionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    timestamp?: boolean
    sessionTime?: boolean
    primarySelector?: boolean
    selectorAlternatives?: boolean
    xpath?: boolean
    cssPath?: boolean
    elementTag?: boolean
    elementText?: boolean
    elementValue?: boolean
    elementAttributes?: boolean
    clientX?: boolean
    clientY?: boolean
    pageX?: boolean
    pageY?: boolean
    boundingBox?: boolean
    viewport?: boolean
    isInViewport?: boolean
    percentVisible?: boolean
    url?: boolean
    pageTitle?: boolean
    pageStructure?: boolean
    parentElements?: boolean
    siblingElements?: boolean
    nearbyElements?: boolean
    stateBefore?: boolean
    stateAfter?: boolean
    stateChanges?: boolean
    confidence?: boolean
    selectorReliability?: boolean
    userIntent?: boolean
    userReasoning?: boolean
    visualCues?: boolean
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    type?: boolean
    timestamp?: boolean
    sessionTime?: boolean
    primarySelector?: boolean
    selectorAlternatives?: boolean
    xpath?: boolean
    cssPath?: boolean
    elementTag?: boolean
    elementText?: boolean
    elementValue?: boolean
    elementAttributes?: boolean
    clientX?: boolean
    clientY?: boolean
    pageX?: boolean
    pageY?: boolean
    boundingBox?: boolean
    viewport?: boolean
    isInViewport?: boolean
    percentVisible?: boolean
    url?: boolean
    pageTitle?: boolean
    pageStructure?: boolean
    parentElements?: boolean
    siblingElements?: boolean
    nearbyElements?: boolean
    stateBefore?: boolean
    stateAfter?: boolean
    stateChanges?: boolean
    confidence?: boolean
    selectorReliability?: boolean
    userIntent?: boolean
    userReasoning?: boolean
    visualCues?: boolean
  }

  export type InteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
    relatedScreenshots?: boolean | Interaction$relatedScreenshotsArgs<ExtArgs>
    _count?: boolean | InteractionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
  }

  export type $InteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interaction"
    objects: {
      session: Prisma.$UnifiedSessionPayload<ExtArgs>
      relatedScreenshots: Prisma.$ScreenshotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      type: $Enums.InteractionType
      timestamp: bigint
      sessionTime: number
      primarySelector: string
      selectorAlternatives: Prisma.JsonValue
      xpath: string | null
      cssPath: string | null
      elementTag: string
      elementText: string | null
      elementValue: string | null
      elementAttributes: Prisma.JsonValue
      clientX: number | null
      clientY: number | null
      pageX: number | null
      pageY: number | null
      boundingBox: Prisma.JsonValue
      viewport: Prisma.JsonValue
      isInViewport: boolean
      percentVisible: number
      url: string
      pageTitle: string
      pageStructure: Prisma.JsonValue
      parentElements: Prisma.JsonValue
      siblingElements: Prisma.JsonValue
      nearbyElements: Prisma.JsonValue
      stateBefore: Prisma.JsonValue
      stateAfter: Prisma.JsonValue | null
      stateChanges: Prisma.JsonValue
      confidence: number
      selectorReliability: Prisma.JsonValue
      userIntent: string | null
      userReasoning: string | null
      visualCues: Prisma.JsonValue
    }, ExtArgs["result"]["interaction"]>
    composites: {}
  }

  type InteractionGetPayload<S extends boolean | null | undefined | InteractionDefaultArgs> = $Result.GetResult<Prisma.$InteractionPayload, S>

  type InteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InteractionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InteractionCountAggregateInputType | true
    }

  export interface InteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interaction'], meta: { name: 'Interaction' } }
    /**
     * Find zero or one Interaction that matches the filter.
     * @param {InteractionFindUniqueArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractionFindUniqueArgs>(args: SelectSubset<T, InteractionFindUniqueArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Interaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InteractionFindUniqueOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Interaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractionFindFirstArgs>(args?: SelectSubset<T, InteractionFindFirstArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Interaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Interactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interactions
     * const interactions = await prisma.interaction.findMany()
     * 
     * // Get first 10 Interactions
     * const interactions = await prisma.interaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interactionWithIdOnly = await prisma.interaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteractionFindManyArgs>(args?: SelectSubset<T, InteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Interaction.
     * @param {InteractionCreateArgs} args - Arguments to create a Interaction.
     * @example
     * // Create one Interaction
     * const Interaction = await prisma.interaction.create({
     *   data: {
     *     // ... data to create a Interaction
     *   }
     * })
     * 
     */
    create<T extends InteractionCreateArgs>(args: SelectSubset<T, InteractionCreateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Interactions.
     * @param {InteractionCreateManyArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractionCreateManyArgs>(args?: SelectSubset<T, InteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interactions and returns the data saved in the database.
     * @param {InteractionCreateManyAndReturnArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interactions and only return the `id`
     * const interactionWithIdOnly = await prisma.interaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Interaction.
     * @param {InteractionDeleteArgs} args - Arguments to delete one Interaction.
     * @example
     * // Delete one Interaction
     * const Interaction = await prisma.interaction.delete({
     *   where: {
     *     // ... filter to delete one Interaction
     *   }
     * })
     * 
     */
    delete<T extends InteractionDeleteArgs>(args: SelectSubset<T, InteractionDeleteArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Interaction.
     * @param {InteractionUpdateArgs} args - Arguments to update one Interaction.
     * @example
     * // Update one Interaction
     * const interaction = await prisma.interaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractionUpdateArgs>(args: SelectSubset<T, InteractionUpdateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Interactions.
     * @param {InteractionDeleteManyArgs} args - Arguments to filter Interactions to delete.
     * @example
     * // Delete a few Interactions
     * const { count } = await prisma.interaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractionDeleteManyArgs>(args?: SelectSubset<T, InteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interactions
     * const interaction = await prisma.interaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractionUpdateManyArgs>(args: SelectSubset<T, InteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Interaction.
     * @param {InteractionUpsertArgs} args - Arguments to update or create a Interaction.
     * @example
     * // Update or create a Interaction
     * const interaction = await prisma.interaction.upsert({
     *   create: {
     *     // ... data to create a Interaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interaction we want to update
     *   }
     * })
     */
    upsert<T extends InteractionUpsertArgs>(args: SelectSubset<T, InteractionUpsertArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionCountArgs} args - Arguments to filter Interactions to count.
     * @example
     * // Count the number of Interactions
     * const count = await prisma.interaction.count({
     *   where: {
     *     // ... the filter for the Interactions we want to count
     *   }
     * })
    **/
    count<T extends InteractionCountArgs>(
      args?: Subset<T, InteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractionAggregateArgs>(args: Subset<T, InteractionAggregateArgs>): Prisma.PrismaPromise<GetInteractionAggregateType<T>>

    /**
     * Group by Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractionGroupByArgs['orderBy'] }
        : { orderBy?: InteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interaction model
   */
  readonly fields: InteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends UnifiedSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnifiedSessionDefaultArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    relatedScreenshots<T extends Interaction$relatedScreenshotsArgs<ExtArgs> = {}>(args?: Subset<T, Interaction$relatedScreenshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interaction model
   */ 
  interface InteractionFieldRefs {
    readonly id: FieldRef<"Interaction", 'String'>
    readonly sessionId: FieldRef<"Interaction", 'String'>
    readonly type: FieldRef<"Interaction", 'InteractionType'>
    readonly timestamp: FieldRef<"Interaction", 'BigInt'>
    readonly sessionTime: FieldRef<"Interaction", 'Int'>
    readonly primarySelector: FieldRef<"Interaction", 'String'>
    readonly selectorAlternatives: FieldRef<"Interaction", 'Json'>
    readonly xpath: FieldRef<"Interaction", 'String'>
    readonly cssPath: FieldRef<"Interaction", 'String'>
    readonly elementTag: FieldRef<"Interaction", 'String'>
    readonly elementText: FieldRef<"Interaction", 'String'>
    readonly elementValue: FieldRef<"Interaction", 'String'>
    readonly elementAttributes: FieldRef<"Interaction", 'Json'>
    readonly clientX: FieldRef<"Interaction", 'Int'>
    readonly clientY: FieldRef<"Interaction", 'Int'>
    readonly pageX: FieldRef<"Interaction", 'Int'>
    readonly pageY: FieldRef<"Interaction", 'Int'>
    readonly boundingBox: FieldRef<"Interaction", 'Json'>
    readonly viewport: FieldRef<"Interaction", 'Json'>
    readonly isInViewport: FieldRef<"Interaction", 'Boolean'>
    readonly percentVisible: FieldRef<"Interaction", 'Float'>
    readonly url: FieldRef<"Interaction", 'String'>
    readonly pageTitle: FieldRef<"Interaction", 'String'>
    readonly pageStructure: FieldRef<"Interaction", 'Json'>
    readonly parentElements: FieldRef<"Interaction", 'Json'>
    readonly siblingElements: FieldRef<"Interaction", 'Json'>
    readonly nearbyElements: FieldRef<"Interaction", 'Json'>
    readonly stateBefore: FieldRef<"Interaction", 'Json'>
    readonly stateAfter: FieldRef<"Interaction", 'Json'>
    readonly stateChanges: FieldRef<"Interaction", 'Json'>
    readonly confidence: FieldRef<"Interaction", 'Float'>
    readonly selectorReliability: FieldRef<"Interaction", 'Json'>
    readonly userIntent: FieldRef<"Interaction", 'String'>
    readonly userReasoning: FieldRef<"Interaction", 'String'>
    readonly visualCues: FieldRef<"Interaction", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Interaction findUnique
   */
  export type InteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findUniqueOrThrow
   */
  export type InteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findFirst
   */
  export type InteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findFirstOrThrow
   */
  export type InteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findMany
   */
  export type InteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interactions to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction create
   */
  export type InteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a Interaction.
     */
    data: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
  }

  /**
   * Interaction createMany
   */
  export type InteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interaction createManyAndReturn
   */
  export type InteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interaction update
   */
  export type InteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a Interaction.
     */
    data: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
    /**
     * Choose, which Interaction to update.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction updateMany
   */
  export type InteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interactions.
     */
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyInput>
    /**
     * Filter which Interactions to update
     */
    where?: InteractionWhereInput
  }

  /**
   * Interaction upsert
   */
  export type InteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the Interaction to update in case it exists.
     */
    where: InteractionWhereUniqueInput
    /**
     * In case the Interaction found by the `where` argument doesn't exist, create a new Interaction with this data.
     */
    create: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
    /**
     * In case the Interaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
  }

  /**
   * Interaction delete
   */
  export type InteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter which Interaction to delete.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction deleteMany
   */
  export type InteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interactions to delete
     */
    where?: InteractionWhereInput
  }

  /**
   * Interaction.relatedScreenshots
   */
  export type Interaction$relatedScreenshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    where?: ScreenshotWhereInput
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    cursor?: ScreenshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * Interaction without action
   */
  export type InteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
  }


  /**
   * Model Screenshot
   */

  export type AggregateScreenshot = {
    _count: ScreenshotCountAggregateOutputType | null
    _avg: ScreenshotAvgAggregateOutputType | null
    _sum: ScreenshotSumAggregateOutputType | null
    _min: ScreenshotMinAggregateOutputType | null
    _max: ScreenshotMaxAggregateOutputType | null
  }

  export type ScreenshotAvgAggregateOutputType = {
    timestamp: number | null
    fileSize: number | null
    quality: number | null
  }

  export type ScreenshotSumAggregateOutputType = {
    timestamp: bigint | null
    fileSize: number | null
    quality: number | null
  }

  export type ScreenshotMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    interactionId: string | null
    timestamp: bigint | null
    eventType: string | null
    s3Key: string | null
    dataUrl: string | null
    compressed: boolean | null
    format: string | null
    fileSize: number | null
    quality: number | null
  }

  export type ScreenshotMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    interactionId: string | null
    timestamp: bigint | null
    eventType: string | null
    s3Key: string | null
    dataUrl: string | null
    compressed: boolean | null
    format: string | null
    fileSize: number | null
    quality: number | null
  }

  export type ScreenshotCountAggregateOutputType = {
    id: number
    sessionId: number
    interactionId: number
    timestamp: number
    eventType: number
    s3Key: number
    dataUrl: number
    compressed: number
    format: number
    fileSize: number
    viewport: number
    quality: number
    visionAnalysis: number
    userPsychology: number
    _all: number
  }


  export type ScreenshotAvgAggregateInputType = {
    timestamp?: true
    fileSize?: true
    quality?: true
  }

  export type ScreenshotSumAggregateInputType = {
    timestamp?: true
    fileSize?: true
    quality?: true
  }

  export type ScreenshotMinAggregateInputType = {
    id?: true
    sessionId?: true
    interactionId?: true
    timestamp?: true
    eventType?: true
    s3Key?: true
    dataUrl?: true
    compressed?: true
    format?: true
    fileSize?: true
    quality?: true
  }

  export type ScreenshotMaxAggregateInputType = {
    id?: true
    sessionId?: true
    interactionId?: true
    timestamp?: true
    eventType?: true
    s3Key?: true
    dataUrl?: true
    compressed?: true
    format?: true
    fileSize?: true
    quality?: true
  }

  export type ScreenshotCountAggregateInputType = {
    id?: true
    sessionId?: true
    interactionId?: true
    timestamp?: true
    eventType?: true
    s3Key?: true
    dataUrl?: true
    compressed?: true
    format?: true
    fileSize?: true
    viewport?: true
    quality?: true
    visionAnalysis?: true
    userPsychology?: true
    _all?: true
  }

  export type ScreenshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Screenshot to aggregate.
     */
    where?: ScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screenshots to fetch.
     */
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Screenshots
    **/
    _count?: true | ScreenshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScreenshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScreenshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScreenshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScreenshotMaxAggregateInputType
  }

  export type GetScreenshotAggregateType<T extends ScreenshotAggregateArgs> = {
        [P in keyof T & keyof AggregateScreenshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenshot[P]>
      : GetScalarType<T[P], AggregateScreenshot[P]>
  }




  export type ScreenshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenshotWhereInput
    orderBy?: ScreenshotOrderByWithAggregationInput | ScreenshotOrderByWithAggregationInput[]
    by: ScreenshotScalarFieldEnum[] | ScreenshotScalarFieldEnum
    having?: ScreenshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScreenshotCountAggregateInputType | true
    _avg?: ScreenshotAvgAggregateInputType
    _sum?: ScreenshotSumAggregateInputType
    _min?: ScreenshotMinAggregateInputType
    _max?: ScreenshotMaxAggregateInputType
  }

  export type ScreenshotGroupByOutputType = {
    id: string
    sessionId: string
    interactionId: string | null
    timestamp: bigint
    eventType: string
    s3Key: string | null
    dataUrl: string | null
    compressed: boolean
    format: string
    fileSize: number | null
    viewport: JsonValue
    quality: number
    visionAnalysis: JsonValue | null
    userPsychology: JsonValue | null
    _count: ScreenshotCountAggregateOutputType | null
    _avg: ScreenshotAvgAggregateOutputType | null
    _sum: ScreenshotSumAggregateOutputType | null
    _min: ScreenshotMinAggregateOutputType | null
    _max: ScreenshotMaxAggregateOutputType | null
  }

  type GetScreenshotGroupByPayload<T extends ScreenshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScreenshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScreenshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenshotGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenshotGroupByOutputType[P]>
        }
      >
    >


  export type ScreenshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    interactionId?: boolean
    timestamp?: boolean
    eventType?: boolean
    s3Key?: boolean
    dataUrl?: boolean
    compressed?: boolean
    format?: boolean
    fileSize?: boolean
    viewport?: boolean
    quality?: boolean
    visionAnalysis?: boolean
    userPsychology?: boolean
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
    interaction?: boolean | Screenshot$interactionArgs<ExtArgs>
  }, ExtArgs["result"]["screenshot"]>

  export type ScreenshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    interactionId?: boolean
    timestamp?: boolean
    eventType?: boolean
    s3Key?: boolean
    dataUrl?: boolean
    compressed?: boolean
    format?: boolean
    fileSize?: boolean
    viewport?: boolean
    quality?: boolean
    visionAnalysis?: boolean
    userPsychology?: boolean
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
    interaction?: boolean | Screenshot$interactionArgs<ExtArgs>
  }, ExtArgs["result"]["screenshot"]>

  export type ScreenshotSelectScalar = {
    id?: boolean
    sessionId?: boolean
    interactionId?: boolean
    timestamp?: boolean
    eventType?: boolean
    s3Key?: boolean
    dataUrl?: boolean
    compressed?: boolean
    format?: boolean
    fileSize?: boolean
    viewport?: boolean
    quality?: boolean
    visionAnalysis?: boolean
    userPsychology?: boolean
  }

  export type ScreenshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
    interaction?: boolean | Screenshot$interactionArgs<ExtArgs>
  }
  export type ScreenshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
    interaction?: boolean | Screenshot$interactionArgs<ExtArgs>
  }

  export type $ScreenshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Screenshot"
    objects: {
      session: Prisma.$UnifiedSessionPayload<ExtArgs>
      interaction: Prisma.$InteractionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      interactionId: string | null
      timestamp: bigint
      eventType: string
      s3Key: string | null
      dataUrl: string | null
      compressed: boolean
      format: string
      fileSize: number | null
      viewport: Prisma.JsonValue
      quality: number
      visionAnalysis: Prisma.JsonValue | null
      userPsychology: Prisma.JsonValue | null
    }, ExtArgs["result"]["screenshot"]>
    composites: {}
  }

  type ScreenshotGetPayload<S extends boolean | null | undefined | ScreenshotDefaultArgs> = $Result.GetResult<Prisma.$ScreenshotPayload, S>

  type ScreenshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScreenshotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScreenshotCountAggregateInputType | true
    }

  export interface ScreenshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Screenshot'], meta: { name: 'Screenshot' } }
    /**
     * Find zero or one Screenshot that matches the filter.
     * @param {ScreenshotFindUniqueArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScreenshotFindUniqueArgs>(args: SelectSubset<T, ScreenshotFindUniqueArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Screenshot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScreenshotFindUniqueOrThrowArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScreenshotFindUniqueOrThrowArgs>(args: SelectSubset<T, ScreenshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Screenshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotFindFirstArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScreenshotFindFirstArgs>(args?: SelectSubset<T, ScreenshotFindFirstArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Screenshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotFindFirstOrThrowArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScreenshotFindFirstOrThrowArgs>(args?: SelectSubset<T, ScreenshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Screenshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Screenshots
     * const screenshots = await prisma.screenshot.findMany()
     * 
     * // Get first 10 Screenshots
     * const screenshots = await prisma.screenshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const screenshotWithIdOnly = await prisma.screenshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScreenshotFindManyArgs>(args?: SelectSubset<T, ScreenshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Screenshot.
     * @param {ScreenshotCreateArgs} args - Arguments to create a Screenshot.
     * @example
     * // Create one Screenshot
     * const Screenshot = await prisma.screenshot.create({
     *   data: {
     *     // ... data to create a Screenshot
     *   }
     * })
     * 
     */
    create<T extends ScreenshotCreateArgs>(args: SelectSubset<T, ScreenshotCreateArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Screenshots.
     * @param {ScreenshotCreateManyArgs} args - Arguments to create many Screenshots.
     * @example
     * // Create many Screenshots
     * const screenshot = await prisma.screenshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScreenshotCreateManyArgs>(args?: SelectSubset<T, ScreenshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Screenshots and returns the data saved in the database.
     * @param {ScreenshotCreateManyAndReturnArgs} args - Arguments to create many Screenshots.
     * @example
     * // Create many Screenshots
     * const screenshot = await prisma.screenshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Screenshots and only return the `id`
     * const screenshotWithIdOnly = await prisma.screenshot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScreenshotCreateManyAndReturnArgs>(args?: SelectSubset<T, ScreenshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Screenshot.
     * @param {ScreenshotDeleteArgs} args - Arguments to delete one Screenshot.
     * @example
     * // Delete one Screenshot
     * const Screenshot = await prisma.screenshot.delete({
     *   where: {
     *     // ... filter to delete one Screenshot
     *   }
     * })
     * 
     */
    delete<T extends ScreenshotDeleteArgs>(args: SelectSubset<T, ScreenshotDeleteArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Screenshot.
     * @param {ScreenshotUpdateArgs} args - Arguments to update one Screenshot.
     * @example
     * // Update one Screenshot
     * const screenshot = await prisma.screenshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScreenshotUpdateArgs>(args: SelectSubset<T, ScreenshotUpdateArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Screenshots.
     * @param {ScreenshotDeleteManyArgs} args - Arguments to filter Screenshots to delete.
     * @example
     * // Delete a few Screenshots
     * const { count } = await prisma.screenshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScreenshotDeleteManyArgs>(args?: SelectSubset<T, ScreenshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Screenshots
     * const screenshot = await prisma.screenshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScreenshotUpdateManyArgs>(args: SelectSubset<T, ScreenshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Screenshot.
     * @param {ScreenshotUpsertArgs} args - Arguments to update or create a Screenshot.
     * @example
     * // Update or create a Screenshot
     * const screenshot = await prisma.screenshot.upsert({
     *   create: {
     *     // ... data to create a Screenshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Screenshot we want to update
     *   }
     * })
     */
    upsert<T extends ScreenshotUpsertArgs>(args: SelectSubset<T, ScreenshotUpsertArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotCountArgs} args - Arguments to filter Screenshots to count.
     * @example
     * // Count the number of Screenshots
     * const count = await prisma.screenshot.count({
     *   where: {
     *     // ... the filter for the Screenshots we want to count
     *   }
     * })
    **/
    count<T extends ScreenshotCountArgs>(
      args?: Subset<T, ScreenshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Screenshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenshotAggregateArgs>(args: Subset<T, ScreenshotAggregateArgs>): Prisma.PrismaPromise<GetScreenshotAggregateType<T>>

    /**
     * Group by Screenshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScreenshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenshotGroupByArgs['orderBy'] }
        : { orderBy?: ScreenshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScreenshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Screenshot model
   */
  readonly fields: ScreenshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Screenshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScreenshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends UnifiedSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnifiedSessionDefaultArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    interaction<T extends Screenshot$interactionArgs<ExtArgs> = {}>(args?: Subset<T, Screenshot$interactionArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Screenshot model
   */ 
  interface ScreenshotFieldRefs {
    readonly id: FieldRef<"Screenshot", 'String'>
    readonly sessionId: FieldRef<"Screenshot", 'String'>
    readonly interactionId: FieldRef<"Screenshot", 'String'>
    readonly timestamp: FieldRef<"Screenshot", 'BigInt'>
    readonly eventType: FieldRef<"Screenshot", 'String'>
    readonly s3Key: FieldRef<"Screenshot", 'String'>
    readonly dataUrl: FieldRef<"Screenshot", 'String'>
    readonly compressed: FieldRef<"Screenshot", 'Boolean'>
    readonly format: FieldRef<"Screenshot", 'String'>
    readonly fileSize: FieldRef<"Screenshot", 'Int'>
    readonly viewport: FieldRef<"Screenshot", 'Json'>
    readonly quality: FieldRef<"Screenshot", 'Float'>
    readonly visionAnalysis: FieldRef<"Screenshot", 'Json'>
    readonly userPsychology: FieldRef<"Screenshot", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Screenshot findUnique
   */
  export type ScreenshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which Screenshot to fetch.
     */
    where: ScreenshotWhereUniqueInput
  }

  /**
   * Screenshot findUniqueOrThrow
   */
  export type ScreenshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which Screenshot to fetch.
     */
    where: ScreenshotWhereUniqueInput
  }

  /**
   * Screenshot findFirst
   */
  export type ScreenshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which Screenshot to fetch.
     */
    where?: ScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screenshots to fetch.
     */
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Screenshots.
     */
    cursor?: ScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Screenshots.
     */
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * Screenshot findFirstOrThrow
   */
  export type ScreenshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which Screenshot to fetch.
     */
    where?: ScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screenshots to fetch.
     */
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Screenshots.
     */
    cursor?: ScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Screenshots.
     */
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * Screenshot findMany
   */
  export type ScreenshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which Screenshots to fetch.
     */
    where?: ScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screenshots to fetch.
     */
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Screenshots.
     */
    cursor?: ScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screenshots.
     */
    skip?: number
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * Screenshot create
   */
  export type ScreenshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * The data needed to create a Screenshot.
     */
    data: XOR<ScreenshotCreateInput, ScreenshotUncheckedCreateInput>
  }

  /**
   * Screenshot createMany
   */
  export type ScreenshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Screenshots.
     */
    data: ScreenshotCreateManyInput | ScreenshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Screenshot createManyAndReturn
   */
  export type ScreenshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Screenshots.
     */
    data: ScreenshotCreateManyInput | ScreenshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Screenshot update
   */
  export type ScreenshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * The data needed to update a Screenshot.
     */
    data: XOR<ScreenshotUpdateInput, ScreenshotUncheckedUpdateInput>
    /**
     * Choose, which Screenshot to update.
     */
    where: ScreenshotWhereUniqueInput
  }

  /**
   * Screenshot updateMany
   */
  export type ScreenshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Screenshots.
     */
    data: XOR<ScreenshotUpdateManyMutationInput, ScreenshotUncheckedUpdateManyInput>
    /**
     * Filter which Screenshots to update
     */
    where?: ScreenshotWhereInput
  }

  /**
   * Screenshot upsert
   */
  export type ScreenshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * The filter to search for the Screenshot to update in case it exists.
     */
    where: ScreenshotWhereUniqueInput
    /**
     * In case the Screenshot found by the `where` argument doesn't exist, create a new Screenshot with this data.
     */
    create: XOR<ScreenshotCreateInput, ScreenshotUncheckedCreateInput>
    /**
     * In case the Screenshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScreenshotUpdateInput, ScreenshotUncheckedUpdateInput>
  }

  /**
   * Screenshot delete
   */
  export type ScreenshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter which Screenshot to delete.
     */
    where: ScreenshotWhereUniqueInput
  }

  /**
   * Screenshot deleteMany
   */
  export type ScreenshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Screenshots to delete
     */
    where?: ScreenshotWhereInput
  }

  /**
   * Screenshot.interaction
   */
  export type Screenshot$interactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
  }

  /**
   * Screenshot without action
   */
  export type ScreenshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
  }


  /**
   * Model SessionArchive
   */

  export type AggregateSessionArchive = {
    _count: SessionArchiveCountAggregateOutputType | null
    _avg: SessionArchiveAvgAggregateOutputType | null
    _sum: SessionArchiveSumAggregateOutputType | null
    _min: SessionArchiveMinAggregateOutputType | null
    _max: SessionArchiveMaxAggregateOutputType | null
  }

  export type SessionArchiveAvgAggregateOutputType = {
    fileSize: number | null
    compressionRatio: number | null
  }

  export type SessionArchiveSumAggregateOutputType = {
    fileSize: bigint | null
    compressionRatio: number | null
  }

  export type SessionArchiveMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    version: string | null
    format: string | null
    s3Bucket: string | null
    s3Key: string | null
    fileSize: bigint | null
    checksum: string | null
    compressionRatio: number | null
    status: $Enums.ArchiveStatus | null
    createdAt: Date | null
  }

  export type SessionArchiveMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    version: string | null
    format: string | null
    s3Bucket: string | null
    s3Key: string | null
    fileSize: bigint | null
    checksum: string | null
    compressionRatio: number | null
    status: $Enums.ArchiveStatus | null
    createdAt: Date | null
  }

  export type SessionArchiveCountAggregateOutputType = {
    id: number
    sessionId: number
    version: number
    format: number
    s3Bucket: number
    s3Key: number
    fileSize: number
    checksum: number
    manifest: number
    compressionRatio: number
    status: number
    createdAt: number
    _all: number
  }


  export type SessionArchiveAvgAggregateInputType = {
    fileSize?: true
    compressionRatio?: true
  }

  export type SessionArchiveSumAggregateInputType = {
    fileSize?: true
    compressionRatio?: true
  }

  export type SessionArchiveMinAggregateInputType = {
    id?: true
    sessionId?: true
    version?: true
    format?: true
    s3Bucket?: true
    s3Key?: true
    fileSize?: true
    checksum?: true
    compressionRatio?: true
    status?: true
    createdAt?: true
  }

  export type SessionArchiveMaxAggregateInputType = {
    id?: true
    sessionId?: true
    version?: true
    format?: true
    s3Bucket?: true
    s3Key?: true
    fileSize?: true
    checksum?: true
    compressionRatio?: true
    status?: true
    createdAt?: true
  }

  export type SessionArchiveCountAggregateInputType = {
    id?: true
    sessionId?: true
    version?: true
    format?: true
    s3Bucket?: true
    s3Key?: true
    fileSize?: true
    checksum?: true
    manifest?: true
    compressionRatio?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type SessionArchiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionArchive to aggregate.
     */
    where?: SessionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionArchives to fetch.
     */
    orderBy?: SessionArchiveOrderByWithRelationInput | SessionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionArchives
    **/
    _count?: true | SessionArchiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionArchiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionArchiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionArchiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionArchiveMaxAggregateInputType
  }

  export type GetSessionArchiveAggregateType<T extends SessionArchiveAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionArchive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionArchive[P]>
      : GetScalarType<T[P], AggregateSessionArchive[P]>
  }




  export type SessionArchiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionArchiveWhereInput
    orderBy?: SessionArchiveOrderByWithAggregationInput | SessionArchiveOrderByWithAggregationInput[]
    by: SessionArchiveScalarFieldEnum[] | SessionArchiveScalarFieldEnum
    having?: SessionArchiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionArchiveCountAggregateInputType | true
    _avg?: SessionArchiveAvgAggregateInputType
    _sum?: SessionArchiveSumAggregateInputType
    _min?: SessionArchiveMinAggregateInputType
    _max?: SessionArchiveMaxAggregateInputType
  }

  export type SessionArchiveGroupByOutputType = {
    id: string
    sessionId: string
    version: string
    format: string
    s3Bucket: string
    s3Key: string
    fileSize: bigint
    checksum: string
    manifest: JsonValue
    compressionRatio: number | null
    status: $Enums.ArchiveStatus
    createdAt: Date
    _count: SessionArchiveCountAggregateOutputType | null
    _avg: SessionArchiveAvgAggregateOutputType | null
    _sum: SessionArchiveSumAggregateOutputType | null
    _min: SessionArchiveMinAggregateOutputType | null
    _max: SessionArchiveMaxAggregateOutputType | null
  }

  type GetSessionArchiveGroupByPayload<T extends SessionArchiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionArchiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionArchiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionArchiveGroupByOutputType[P]>
            : GetScalarType<T[P], SessionArchiveGroupByOutputType[P]>
        }
      >
    >


  export type SessionArchiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    version?: boolean
    format?: boolean
    s3Bucket?: boolean
    s3Key?: boolean
    fileSize?: boolean
    checksum?: boolean
    manifest?: boolean
    compressionRatio?: boolean
    status?: boolean
    createdAt?: boolean
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionArchive"]>

  export type SessionArchiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    version?: boolean
    format?: boolean
    s3Bucket?: boolean
    s3Key?: boolean
    fileSize?: boolean
    checksum?: boolean
    manifest?: boolean
    compressionRatio?: boolean
    status?: boolean
    createdAt?: boolean
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionArchive"]>

  export type SessionArchiveSelectScalar = {
    id?: boolean
    sessionId?: boolean
    version?: boolean
    format?: boolean
    s3Bucket?: boolean
    s3Key?: boolean
    fileSize?: boolean
    checksum?: boolean
    manifest?: boolean
    compressionRatio?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type SessionArchiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
  }
  export type SessionArchiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | UnifiedSessionDefaultArgs<ExtArgs>
  }

  export type $SessionArchivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionArchive"
    objects: {
      session: Prisma.$UnifiedSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      version: string
      format: string
      s3Bucket: string
      s3Key: string
      fileSize: bigint
      checksum: string
      manifest: Prisma.JsonValue
      compressionRatio: number | null
      status: $Enums.ArchiveStatus
      createdAt: Date
    }, ExtArgs["result"]["sessionArchive"]>
    composites: {}
  }

  type SessionArchiveGetPayload<S extends boolean | null | undefined | SessionArchiveDefaultArgs> = $Result.GetResult<Prisma.$SessionArchivePayload, S>

  type SessionArchiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionArchiveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionArchiveCountAggregateInputType | true
    }

  export interface SessionArchiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionArchive'], meta: { name: 'SessionArchive' } }
    /**
     * Find zero or one SessionArchive that matches the filter.
     * @param {SessionArchiveFindUniqueArgs} args - Arguments to find a SessionArchive
     * @example
     * // Get one SessionArchive
     * const sessionArchive = await prisma.sessionArchive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionArchiveFindUniqueArgs>(args: SelectSubset<T, SessionArchiveFindUniqueArgs<ExtArgs>>): Prisma__SessionArchiveClient<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SessionArchive that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionArchiveFindUniqueOrThrowArgs} args - Arguments to find a SessionArchive
     * @example
     * // Get one SessionArchive
     * const sessionArchive = await prisma.sessionArchive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionArchiveFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionArchiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionArchiveClient<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SessionArchive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionArchiveFindFirstArgs} args - Arguments to find a SessionArchive
     * @example
     * // Get one SessionArchive
     * const sessionArchive = await prisma.sessionArchive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionArchiveFindFirstArgs>(args?: SelectSubset<T, SessionArchiveFindFirstArgs<ExtArgs>>): Prisma__SessionArchiveClient<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SessionArchive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionArchiveFindFirstOrThrowArgs} args - Arguments to find a SessionArchive
     * @example
     * // Get one SessionArchive
     * const sessionArchive = await prisma.sessionArchive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionArchiveFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionArchiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionArchiveClient<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SessionArchives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionArchiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionArchives
     * const sessionArchives = await prisma.sessionArchive.findMany()
     * 
     * // Get first 10 SessionArchives
     * const sessionArchives = await prisma.sessionArchive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionArchiveWithIdOnly = await prisma.sessionArchive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionArchiveFindManyArgs>(args?: SelectSubset<T, SessionArchiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SessionArchive.
     * @param {SessionArchiveCreateArgs} args - Arguments to create a SessionArchive.
     * @example
     * // Create one SessionArchive
     * const SessionArchive = await prisma.sessionArchive.create({
     *   data: {
     *     // ... data to create a SessionArchive
     *   }
     * })
     * 
     */
    create<T extends SessionArchiveCreateArgs>(args: SelectSubset<T, SessionArchiveCreateArgs<ExtArgs>>): Prisma__SessionArchiveClient<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SessionArchives.
     * @param {SessionArchiveCreateManyArgs} args - Arguments to create many SessionArchives.
     * @example
     * // Create many SessionArchives
     * const sessionArchive = await prisma.sessionArchive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionArchiveCreateManyArgs>(args?: SelectSubset<T, SessionArchiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionArchives and returns the data saved in the database.
     * @param {SessionArchiveCreateManyAndReturnArgs} args - Arguments to create many SessionArchives.
     * @example
     * // Create many SessionArchives
     * const sessionArchive = await prisma.sessionArchive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionArchives and only return the `id`
     * const sessionArchiveWithIdOnly = await prisma.sessionArchive.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionArchiveCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionArchiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SessionArchive.
     * @param {SessionArchiveDeleteArgs} args - Arguments to delete one SessionArchive.
     * @example
     * // Delete one SessionArchive
     * const SessionArchive = await prisma.sessionArchive.delete({
     *   where: {
     *     // ... filter to delete one SessionArchive
     *   }
     * })
     * 
     */
    delete<T extends SessionArchiveDeleteArgs>(args: SelectSubset<T, SessionArchiveDeleteArgs<ExtArgs>>): Prisma__SessionArchiveClient<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SessionArchive.
     * @param {SessionArchiveUpdateArgs} args - Arguments to update one SessionArchive.
     * @example
     * // Update one SessionArchive
     * const sessionArchive = await prisma.sessionArchive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionArchiveUpdateArgs>(args: SelectSubset<T, SessionArchiveUpdateArgs<ExtArgs>>): Prisma__SessionArchiveClient<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SessionArchives.
     * @param {SessionArchiveDeleteManyArgs} args - Arguments to filter SessionArchives to delete.
     * @example
     * // Delete a few SessionArchives
     * const { count } = await prisma.sessionArchive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionArchiveDeleteManyArgs>(args?: SelectSubset<T, SessionArchiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionArchiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionArchives
     * const sessionArchive = await prisma.sessionArchive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionArchiveUpdateManyArgs>(args: SelectSubset<T, SessionArchiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionArchive.
     * @param {SessionArchiveUpsertArgs} args - Arguments to update or create a SessionArchive.
     * @example
     * // Update or create a SessionArchive
     * const sessionArchive = await prisma.sessionArchive.upsert({
     *   create: {
     *     // ... data to create a SessionArchive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionArchive we want to update
     *   }
     * })
     */
    upsert<T extends SessionArchiveUpsertArgs>(args: SelectSubset<T, SessionArchiveUpsertArgs<ExtArgs>>): Prisma__SessionArchiveClient<$Result.GetResult<Prisma.$SessionArchivePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SessionArchives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionArchiveCountArgs} args - Arguments to filter SessionArchives to count.
     * @example
     * // Count the number of SessionArchives
     * const count = await prisma.sessionArchive.count({
     *   where: {
     *     // ... the filter for the SessionArchives we want to count
     *   }
     * })
    **/
    count<T extends SessionArchiveCountArgs>(
      args?: Subset<T, SessionArchiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionArchiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionArchiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionArchiveAggregateArgs>(args: Subset<T, SessionArchiveAggregateArgs>): Prisma.PrismaPromise<GetSessionArchiveAggregateType<T>>

    /**
     * Group by SessionArchive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionArchiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionArchiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionArchiveGroupByArgs['orderBy'] }
        : { orderBy?: SessionArchiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionArchiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionArchiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionArchive model
   */
  readonly fields: SessionArchiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionArchive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionArchiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends UnifiedSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnifiedSessionDefaultArgs<ExtArgs>>): Prisma__UnifiedSessionClient<$Result.GetResult<Prisma.$UnifiedSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionArchive model
   */ 
  interface SessionArchiveFieldRefs {
    readonly id: FieldRef<"SessionArchive", 'String'>
    readonly sessionId: FieldRef<"SessionArchive", 'String'>
    readonly version: FieldRef<"SessionArchive", 'String'>
    readonly format: FieldRef<"SessionArchive", 'String'>
    readonly s3Bucket: FieldRef<"SessionArchive", 'String'>
    readonly s3Key: FieldRef<"SessionArchive", 'String'>
    readonly fileSize: FieldRef<"SessionArchive", 'BigInt'>
    readonly checksum: FieldRef<"SessionArchive", 'String'>
    readonly manifest: FieldRef<"SessionArchive", 'Json'>
    readonly compressionRatio: FieldRef<"SessionArchive", 'Float'>
    readonly status: FieldRef<"SessionArchive", 'ArchiveStatus'>
    readonly createdAt: FieldRef<"SessionArchive", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionArchive findUnique
   */
  export type SessionArchiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which SessionArchive to fetch.
     */
    where: SessionArchiveWhereUniqueInput
  }

  /**
   * SessionArchive findUniqueOrThrow
   */
  export type SessionArchiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which SessionArchive to fetch.
     */
    where: SessionArchiveWhereUniqueInput
  }

  /**
   * SessionArchive findFirst
   */
  export type SessionArchiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which SessionArchive to fetch.
     */
    where?: SessionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionArchives to fetch.
     */
    orderBy?: SessionArchiveOrderByWithRelationInput | SessionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionArchives.
     */
    cursor?: SessionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionArchives.
     */
    distinct?: SessionArchiveScalarFieldEnum | SessionArchiveScalarFieldEnum[]
  }

  /**
   * SessionArchive findFirstOrThrow
   */
  export type SessionArchiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which SessionArchive to fetch.
     */
    where?: SessionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionArchives to fetch.
     */
    orderBy?: SessionArchiveOrderByWithRelationInput | SessionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionArchives.
     */
    cursor?: SessionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionArchives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionArchives.
     */
    distinct?: SessionArchiveScalarFieldEnum | SessionArchiveScalarFieldEnum[]
  }

  /**
   * SessionArchive findMany
   */
  export type SessionArchiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
    /**
     * Filter, which SessionArchives to fetch.
     */
    where?: SessionArchiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionArchives to fetch.
     */
    orderBy?: SessionArchiveOrderByWithRelationInput | SessionArchiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionArchives.
     */
    cursor?: SessionArchiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionArchives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionArchives.
     */
    skip?: number
    distinct?: SessionArchiveScalarFieldEnum | SessionArchiveScalarFieldEnum[]
  }

  /**
   * SessionArchive create
   */
  export type SessionArchiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionArchive.
     */
    data: XOR<SessionArchiveCreateInput, SessionArchiveUncheckedCreateInput>
  }

  /**
   * SessionArchive createMany
   */
  export type SessionArchiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionArchives.
     */
    data: SessionArchiveCreateManyInput | SessionArchiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionArchive createManyAndReturn
   */
  export type SessionArchiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SessionArchives.
     */
    data: SessionArchiveCreateManyInput | SessionArchiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionArchive update
   */
  export type SessionArchiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionArchive.
     */
    data: XOR<SessionArchiveUpdateInput, SessionArchiveUncheckedUpdateInput>
    /**
     * Choose, which SessionArchive to update.
     */
    where: SessionArchiveWhereUniqueInput
  }

  /**
   * SessionArchive updateMany
   */
  export type SessionArchiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionArchives.
     */
    data: XOR<SessionArchiveUpdateManyMutationInput, SessionArchiveUncheckedUpdateManyInput>
    /**
     * Filter which SessionArchives to update
     */
    where?: SessionArchiveWhereInput
  }

  /**
   * SessionArchive upsert
   */
  export type SessionArchiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionArchive to update in case it exists.
     */
    where: SessionArchiveWhereUniqueInput
    /**
     * In case the SessionArchive found by the `where` argument doesn't exist, create a new SessionArchive with this data.
     */
    create: XOR<SessionArchiveCreateInput, SessionArchiveUncheckedCreateInput>
    /**
     * In case the SessionArchive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionArchiveUpdateInput, SessionArchiveUncheckedUpdateInput>
  }

  /**
   * SessionArchive delete
   */
  export type SessionArchiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
    /**
     * Filter which SessionArchive to delete.
     */
    where: SessionArchiveWhereUniqueInput
  }

  /**
   * SessionArchive deleteMany
   */
  export type SessionArchiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionArchives to delete
     */
    where?: SessionArchiveWhereInput
  }

  /**
   * SessionArchive without action
   */
  export type SessionArchiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionArchive
     */
    select?: SessionArchiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionArchiveInclude<ExtArgs> | null
  }


  /**
   * Model TrainingData
   */

  export type AggregateTrainingData = {
    _count: TrainingDataCountAggregateOutputType | null
    _avg: TrainingDataAvgAggregateOutputType | null
    _sum: TrainingDataSumAggregateOutputType | null
    _min: TrainingDataMinAggregateOutputType | null
    _max: TrainingDataMaxAggregateOutputType | null
  }

  export type TrainingDataAvgAggregateOutputType = {
    fileSize: number | null
    trainingQuality: number | null
    expectedPerformance: number | null
  }

  export type TrainingDataSumAggregateOutputType = {
    fileSize: number | null
    trainingQuality: number | null
    expectedPerformance: number | null
  }

  export type TrainingDataMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    openaiFileId: string | null
    jsonlData: string | null
    fileSize: number | null
    trainingJobId: string | null
    modelId: string | null
    trainingQuality: number | null
    expectedPerformance: number | null
    status: $Enums.TrainingStatus | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type TrainingDataMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    openaiFileId: string | null
    jsonlData: string | null
    fileSize: number | null
    trainingJobId: string | null
    modelId: string | null
    trainingQuality: number | null
    expectedPerformance: number | null
    status: $Enums.TrainingStatus | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type TrainingDataCountAggregateOutputType = {
    id: number
    sessionId: number
    openaiFileId: number
    jsonlData: number
    fileSize: number
    trainingJobId: number
    modelId: number
    hyperparameters: number
    trainingConfig: number
    trainingMetrics: number
    validationResults: number
    trainingQuality: number
    expectedPerformance: number
    status: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type TrainingDataAvgAggregateInputType = {
    fileSize?: true
    trainingQuality?: true
    expectedPerformance?: true
  }

  export type TrainingDataSumAggregateInputType = {
    fileSize?: true
    trainingQuality?: true
    expectedPerformance?: true
  }

  export type TrainingDataMinAggregateInputType = {
    id?: true
    sessionId?: true
    openaiFileId?: true
    jsonlData?: true
    fileSize?: true
    trainingJobId?: true
    modelId?: true
    trainingQuality?: true
    expectedPerformance?: true
    status?: true
    createdAt?: true
    completedAt?: true
  }

  export type TrainingDataMaxAggregateInputType = {
    id?: true
    sessionId?: true
    openaiFileId?: true
    jsonlData?: true
    fileSize?: true
    trainingJobId?: true
    modelId?: true
    trainingQuality?: true
    expectedPerformance?: true
    status?: true
    createdAt?: true
    completedAt?: true
  }

  export type TrainingDataCountAggregateInputType = {
    id?: true
    sessionId?: true
    openaiFileId?: true
    jsonlData?: true
    fileSize?: true
    trainingJobId?: true
    modelId?: true
    hyperparameters?: true
    trainingConfig?: true
    trainingMetrics?: true
    validationResults?: true
    trainingQuality?: true
    expectedPerformance?: true
    status?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type TrainingDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingData to aggregate.
     */
    where?: TrainingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingData to fetch.
     */
    orderBy?: TrainingDataOrderByWithRelationInput | TrainingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingData
    **/
    _count?: true | TrainingDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingDataMaxAggregateInputType
  }

  export type GetTrainingDataAggregateType<T extends TrainingDataAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingData[P]>
      : GetScalarType<T[P], AggregateTrainingData[P]>
  }




  export type TrainingDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingDataWhereInput
    orderBy?: TrainingDataOrderByWithAggregationInput | TrainingDataOrderByWithAggregationInput[]
    by: TrainingDataScalarFieldEnum[] | TrainingDataScalarFieldEnum
    having?: TrainingDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingDataCountAggregateInputType | true
    _avg?: TrainingDataAvgAggregateInputType
    _sum?: TrainingDataSumAggregateInputType
    _min?: TrainingDataMinAggregateInputType
    _max?: TrainingDataMaxAggregateInputType
  }

  export type TrainingDataGroupByOutputType = {
    id: string
    sessionId: string
    openaiFileId: string | null
    jsonlData: string | null
    fileSize: number | null
    trainingJobId: string | null
    modelId: string | null
    hyperparameters: JsonValue
    trainingConfig: JsonValue
    trainingMetrics: JsonValue | null
    validationResults: JsonValue | null
    trainingQuality: number
    expectedPerformance: number
    status: $Enums.TrainingStatus
    createdAt: Date
    completedAt: Date | null
    _count: TrainingDataCountAggregateOutputType | null
    _avg: TrainingDataAvgAggregateOutputType | null
    _sum: TrainingDataSumAggregateOutputType | null
    _min: TrainingDataMinAggregateOutputType | null
    _max: TrainingDataMaxAggregateOutputType | null
  }

  type GetTrainingDataGroupByPayload<T extends TrainingDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingDataGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingDataGroupByOutputType[P]>
        }
      >
    >


  export type TrainingDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    openaiFileId?: boolean
    jsonlData?: boolean
    fileSize?: boolean
    trainingJobId?: boolean
    modelId?: boolean
    hyperparameters?: boolean
    trainingConfig?: boolean
    trainingMetrics?: boolean
    validationResults?: boolean
    trainingQuality?: boolean
    expectedPerformance?: boolean
    status?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["trainingData"]>

  export type TrainingDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    openaiFileId?: boolean
    jsonlData?: boolean
    fileSize?: boolean
    trainingJobId?: boolean
    modelId?: boolean
    hyperparameters?: boolean
    trainingConfig?: boolean
    trainingMetrics?: boolean
    validationResults?: boolean
    trainingQuality?: boolean
    expectedPerformance?: boolean
    status?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }, ExtArgs["result"]["trainingData"]>

  export type TrainingDataSelectScalar = {
    id?: boolean
    sessionId?: boolean
    openaiFileId?: boolean
    jsonlData?: boolean
    fileSize?: boolean
    trainingJobId?: boolean
    modelId?: boolean
    hyperparameters?: boolean
    trainingConfig?: boolean
    trainingMetrics?: boolean
    validationResults?: boolean
    trainingQuality?: boolean
    expectedPerformance?: boolean
    status?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }


  export type $TrainingDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      openaiFileId: string | null
      jsonlData: string | null
      fileSize: number | null
      trainingJobId: string | null
      modelId: string | null
      hyperparameters: Prisma.JsonValue
      trainingConfig: Prisma.JsonValue
      trainingMetrics: Prisma.JsonValue | null
      validationResults: Prisma.JsonValue | null
      trainingQuality: number
      expectedPerformance: number
      status: $Enums.TrainingStatus
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["trainingData"]>
    composites: {}
  }

  type TrainingDataGetPayload<S extends boolean | null | undefined | TrainingDataDefaultArgs> = $Result.GetResult<Prisma.$TrainingDataPayload, S>

  type TrainingDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingDataCountAggregateInputType | true
    }

  export interface TrainingDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingData'], meta: { name: 'TrainingData' } }
    /**
     * Find zero or one TrainingData that matches the filter.
     * @param {TrainingDataFindUniqueArgs} args - Arguments to find a TrainingData
     * @example
     * // Get one TrainingData
     * const trainingData = await prisma.trainingData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingDataFindUniqueArgs>(args: SelectSubset<T, TrainingDataFindUniqueArgs<ExtArgs>>): Prisma__TrainingDataClient<$Result.GetResult<Prisma.$TrainingDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainingData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingDataFindUniqueOrThrowArgs} args - Arguments to find a TrainingData
     * @example
     * // Get one TrainingData
     * const trainingData = await prisma.trainingData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingDataFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingDataClient<$Result.GetResult<Prisma.$TrainingDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainingData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDataFindFirstArgs} args - Arguments to find a TrainingData
     * @example
     * // Get one TrainingData
     * const trainingData = await prisma.trainingData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingDataFindFirstArgs>(args?: SelectSubset<T, TrainingDataFindFirstArgs<ExtArgs>>): Prisma__TrainingDataClient<$Result.GetResult<Prisma.$TrainingDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainingData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDataFindFirstOrThrowArgs} args - Arguments to find a TrainingData
     * @example
     * // Get one TrainingData
     * const trainingData = await prisma.trainingData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingDataFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingDataClient<$Result.GetResult<Prisma.$TrainingDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainingData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingData
     * const trainingData = await prisma.trainingData.findMany()
     * 
     * // Get first 10 TrainingData
     * const trainingData = await prisma.trainingData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingDataWithIdOnly = await prisma.trainingData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingDataFindManyArgs>(args?: SelectSubset<T, TrainingDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainingData.
     * @param {TrainingDataCreateArgs} args - Arguments to create a TrainingData.
     * @example
     * // Create one TrainingData
     * const TrainingData = await prisma.trainingData.create({
     *   data: {
     *     // ... data to create a TrainingData
     *   }
     * })
     * 
     */
    create<T extends TrainingDataCreateArgs>(args: SelectSubset<T, TrainingDataCreateArgs<ExtArgs>>): Prisma__TrainingDataClient<$Result.GetResult<Prisma.$TrainingDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainingData.
     * @param {TrainingDataCreateManyArgs} args - Arguments to create many TrainingData.
     * @example
     * // Create many TrainingData
     * const trainingData = await prisma.trainingData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingDataCreateManyArgs>(args?: SelectSubset<T, TrainingDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingData and returns the data saved in the database.
     * @param {TrainingDataCreateManyAndReturnArgs} args - Arguments to create many TrainingData.
     * @example
     * // Create many TrainingData
     * const trainingData = await prisma.trainingData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingData and only return the `id`
     * const trainingDataWithIdOnly = await prisma.trainingData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingDataCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainingData.
     * @param {TrainingDataDeleteArgs} args - Arguments to delete one TrainingData.
     * @example
     * // Delete one TrainingData
     * const TrainingData = await prisma.trainingData.delete({
     *   where: {
     *     // ... filter to delete one TrainingData
     *   }
     * })
     * 
     */
    delete<T extends TrainingDataDeleteArgs>(args: SelectSubset<T, TrainingDataDeleteArgs<ExtArgs>>): Prisma__TrainingDataClient<$Result.GetResult<Prisma.$TrainingDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainingData.
     * @param {TrainingDataUpdateArgs} args - Arguments to update one TrainingData.
     * @example
     * // Update one TrainingData
     * const trainingData = await prisma.trainingData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingDataUpdateArgs>(args: SelectSubset<T, TrainingDataUpdateArgs<ExtArgs>>): Prisma__TrainingDataClient<$Result.GetResult<Prisma.$TrainingDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainingData.
     * @param {TrainingDataDeleteManyArgs} args - Arguments to filter TrainingData to delete.
     * @example
     * // Delete a few TrainingData
     * const { count } = await prisma.trainingData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingDataDeleteManyArgs>(args?: SelectSubset<T, TrainingDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingData
     * const trainingData = await prisma.trainingData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingDataUpdateManyArgs>(args: SelectSubset<T, TrainingDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingData.
     * @param {TrainingDataUpsertArgs} args - Arguments to update or create a TrainingData.
     * @example
     * // Update or create a TrainingData
     * const trainingData = await prisma.trainingData.upsert({
     *   create: {
     *     // ... data to create a TrainingData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingData we want to update
     *   }
     * })
     */
    upsert<T extends TrainingDataUpsertArgs>(args: SelectSubset<T, TrainingDataUpsertArgs<ExtArgs>>): Prisma__TrainingDataClient<$Result.GetResult<Prisma.$TrainingDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDataCountArgs} args - Arguments to filter TrainingData to count.
     * @example
     * // Count the number of TrainingData
     * const count = await prisma.trainingData.count({
     *   where: {
     *     // ... the filter for the TrainingData we want to count
     *   }
     * })
    **/
    count<T extends TrainingDataCountArgs>(
      args?: Subset<T, TrainingDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingDataAggregateArgs>(args: Subset<T, TrainingDataAggregateArgs>): Prisma.PrismaPromise<GetTrainingDataAggregateType<T>>

    /**
     * Group by TrainingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingDataGroupByArgs['orderBy'] }
        : { orderBy?: TrainingDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingData model
   */
  readonly fields: TrainingDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingData model
   */ 
  interface TrainingDataFieldRefs {
    readonly id: FieldRef<"TrainingData", 'String'>
    readonly sessionId: FieldRef<"TrainingData", 'String'>
    readonly openaiFileId: FieldRef<"TrainingData", 'String'>
    readonly jsonlData: FieldRef<"TrainingData", 'String'>
    readonly fileSize: FieldRef<"TrainingData", 'Int'>
    readonly trainingJobId: FieldRef<"TrainingData", 'String'>
    readonly modelId: FieldRef<"TrainingData", 'String'>
    readonly hyperparameters: FieldRef<"TrainingData", 'Json'>
    readonly trainingConfig: FieldRef<"TrainingData", 'Json'>
    readonly trainingMetrics: FieldRef<"TrainingData", 'Json'>
    readonly validationResults: FieldRef<"TrainingData", 'Json'>
    readonly trainingQuality: FieldRef<"TrainingData", 'Float'>
    readonly expectedPerformance: FieldRef<"TrainingData", 'Float'>
    readonly status: FieldRef<"TrainingData", 'TrainingStatus'>
    readonly createdAt: FieldRef<"TrainingData", 'DateTime'>
    readonly completedAt: FieldRef<"TrainingData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingData findUnique
   */
  export type TrainingDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelect<ExtArgs> | null
    /**
     * Filter, which TrainingData to fetch.
     */
    where: TrainingDataWhereUniqueInput
  }

  /**
   * TrainingData findUniqueOrThrow
   */
  export type TrainingDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelect<ExtArgs> | null
    /**
     * Filter, which TrainingData to fetch.
     */
    where: TrainingDataWhereUniqueInput
  }

  /**
   * TrainingData findFirst
   */
  export type TrainingDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelect<ExtArgs> | null
    /**
     * Filter, which TrainingData to fetch.
     */
    where?: TrainingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingData to fetch.
     */
    orderBy?: TrainingDataOrderByWithRelationInput | TrainingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingData.
     */
    cursor?: TrainingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingData.
     */
    distinct?: TrainingDataScalarFieldEnum | TrainingDataScalarFieldEnum[]
  }

  /**
   * TrainingData findFirstOrThrow
   */
  export type TrainingDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelect<ExtArgs> | null
    /**
     * Filter, which TrainingData to fetch.
     */
    where?: TrainingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingData to fetch.
     */
    orderBy?: TrainingDataOrderByWithRelationInput | TrainingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingData.
     */
    cursor?: TrainingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingData.
     */
    distinct?: TrainingDataScalarFieldEnum | TrainingDataScalarFieldEnum[]
  }

  /**
   * TrainingData findMany
   */
  export type TrainingDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelect<ExtArgs> | null
    /**
     * Filter, which TrainingData to fetch.
     */
    where?: TrainingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingData to fetch.
     */
    orderBy?: TrainingDataOrderByWithRelationInput | TrainingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingData.
     */
    cursor?: TrainingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingData.
     */
    skip?: number
    distinct?: TrainingDataScalarFieldEnum | TrainingDataScalarFieldEnum[]
  }

  /**
   * TrainingData create
   */
  export type TrainingDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelect<ExtArgs> | null
    /**
     * The data needed to create a TrainingData.
     */
    data: XOR<TrainingDataCreateInput, TrainingDataUncheckedCreateInput>
  }

  /**
   * TrainingData createMany
   */
  export type TrainingDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingData.
     */
    data: TrainingDataCreateManyInput | TrainingDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingData createManyAndReturn
   */
  export type TrainingDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainingData.
     */
    data: TrainingDataCreateManyInput | TrainingDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingData update
   */
  export type TrainingDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelect<ExtArgs> | null
    /**
     * The data needed to update a TrainingData.
     */
    data: XOR<TrainingDataUpdateInput, TrainingDataUncheckedUpdateInput>
    /**
     * Choose, which TrainingData to update.
     */
    where: TrainingDataWhereUniqueInput
  }

  /**
   * TrainingData updateMany
   */
  export type TrainingDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingData.
     */
    data: XOR<TrainingDataUpdateManyMutationInput, TrainingDataUncheckedUpdateManyInput>
    /**
     * Filter which TrainingData to update
     */
    where?: TrainingDataWhereInput
  }

  /**
   * TrainingData upsert
   */
  export type TrainingDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelect<ExtArgs> | null
    /**
     * The filter to search for the TrainingData to update in case it exists.
     */
    where: TrainingDataWhereUniqueInput
    /**
     * In case the TrainingData found by the `where` argument doesn't exist, create a new TrainingData with this data.
     */
    create: XOR<TrainingDataCreateInput, TrainingDataUncheckedCreateInput>
    /**
     * In case the TrainingData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingDataUpdateInput, TrainingDataUncheckedUpdateInput>
  }

  /**
   * TrainingData delete
   */
  export type TrainingDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelect<ExtArgs> | null
    /**
     * Filter which TrainingData to delete.
     */
    where: TrainingDataWhereUniqueInput
  }

  /**
   * TrainingData deleteMany
   */
  export type TrainingDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingData to delete
     */
    where?: TrainingDataWhereInput
  }

  /**
   * TrainingData without action
   */
  export type TrainingDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingData
     */
    select?: TrainingDataSelect<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    description: string | null
    category: string
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      description: string | null
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */ 
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'Json'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly category: FieldRef<"SystemConfig", 'String'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
  }


  /**
   * Model QualityReport
   */

  export type AggregateQualityReport = {
    _count: QualityReportCountAggregateOutputType | null
    _avg: QualityReportAvgAggregateOutputType | null
    _sum: QualityReportSumAggregateOutputType | null
    _min: QualityReportMinAggregateOutputType | null
    _max: QualityReportMaxAggregateOutputType | null
  }

  export type QualityReportAvgAggregateOutputType = {
    overallScore: number | null
    completenessScore: number | null
    reliabilityScore: number | null
    accuracyScore: number | null
  }

  export type QualityReportSumAggregateOutputType = {
    overallScore: number | null
    completenessScore: number | null
    reliabilityScore: number | null
    accuracyScore: number | null
  }

  export type QualityReportMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    overallScore: number | null
    completenessScore: number | null
    reliabilityScore: number | null
    accuracyScore: number | null
    generatedAt: Date | null
    version: string | null
  }

  export type QualityReportMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    overallScore: number | null
    completenessScore: number | null
    reliabilityScore: number | null
    accuracyScore: number | null
    generatedAt: Date | null
    version: string | null
  }

  export type QualityReportCountAggregateOutputType = {
    id: number
    sessionId: number
    overallScore: number
    completenessScore: number
    reliabilityScore: number
    accuracyScore: number
    validationResults: number
    issues: number
    recommendations: number
    generatedAt: number
    version: number
    _all: number
  }


  export type QualityReportAvgAggregateInputType = {
    overallScore?: true
    completenessScore?: true
    reliabilityScore?: true
    accuracyScore?: true
  }

  export type QualityReportSumAggregateInputType = {
    overallScore?: true
    completenessScore?: true
    reliabilityScore?: true
    accuracyScore?: true
  }

  export type QualityReportMinAggregateInputType = {
    id?: true
    sessionId?: true
    overallScore?: true
    completenessScore?: true
    reliabilityScore?: true
    accuracyScore?: true
    generatedAt?: true
    version?: true
  }

  export type QualityReportMaxAggregateInputType = {
    id?: true
    sessionId?: true
    overallScore?: true
    completenessScore?: true
    reliabilityScore?: true
    accuracyScore?: true
    generatedAt?: true
    version?: true
  }

  export type QualityReportCountAggregateInputType = {
    id?: true
    sessionId?: true
    overallScore?: true
    completenessScore?: true
    reliabilityScore?: true
    accuracyScore?: true
    validationResults?: true
    issues?: true
    recommendations?: true
    generatedAt?: true
    version?: true
    _all?: true
  }

  export type QualityReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualityReport to aggregate.
     */
    where?: QualityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityReports to fetch.
     */
    orderBy?: QualityReportOrderByWithRelationInput | QualityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QualityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QualityReports
    **/
    _count?: true | QualityReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QualityReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QualityReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QualityReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QualityReportMaxAggregateInputType
  }

  export type GetQualityReportAggregateType<T extends QualityReportAggregateArgs> = {
        [P in keyof T & keyof AggregateQualityReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualityReport[P]>
      : GetScalarType<T[P], AggregateQualityReport[P]>
  }




  export type QualityReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QualityReportWhereInput
    orderBy?: QualityReportOrderByWithAggregationInput | QualityReportOrderByWithAggregationInput[]
    by: QualityReportScalarFieldEnum[] | QualityReportScalarFieldEnum
    having?: QualityReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QualityReportCountAggregateInputType | true
    _avg?: QualityReportAvgAggregateInputType
    _sum?: QualityReportSumAggregateInputType
    _min?: QualityReportMinAggregateInputType
    _max?: QualityReportMaxAggregateInputType
  }

  export type QualityReportGroupByOutputType = {
    id: string
    sessionId: string
    overallScore: number
    completenessScore: number
    reliabilityScore: number
    accuracyScore: number
    validationResults: JsonValue
    issues: JsonValue
    recommendations: JsonValue
    generatedAt: Date
    version: string
    _count: QualityReportCountAggregateOutputType | null
    _avg: QualityReportAvgAggregateOutputType | null
    _sum: QualityReportSumAggregateOutputType | null
    _min: QualityReportMinAggregateOutputType | null
    _max: QualityReportMaxAggregateOutputType | null
  }

  type GetQualityReportGroupByPayload<T extends QualityReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QualityReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QualityReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QualityReportGroupByOutputType[P]>
            : GetScalarType<T[P], QualityReportGroupByOutputType[P]>
        }
      >
    >


  export type QualityReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    overallScore?: boolean
    completenessScore?: boolean
    reliabilityScore?: boolean
    accuracyScore?: boolean
    validationResults?: boolean
    issues?: boolean
    recommendations?: boolean
    generatedAt?: boolean
    version?: boolean
  }, ExtArgs["result"]["qualityReport"]>

  export type QualityReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    overallScore?: boolean
    completenessScore?: boolean
    reliabilityScore?: boolean
    accuracyScore?: boolean
    validationResults?: boolean
    issues?: boolean
    recommendations?: boolean
    generatedAt?: boolean
    version?: boolean
  }, ExtArgs["result"]["qualityReport"]>

  export type QualityReportSelectScalar = {
    id?: boolean
    sessionId?: boolean
    overallScore?: boolean
    completenessScore?: boolean
    reliabilityScore?: boolean
    accuracyScore?: boolean
    validationResults?: boolean
    issues?: boolean
    recommendations?: boolean
    generatedAt?: boolean
    version?: boolean
  }


  export type $QualityReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QualityReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      overallScore: number
      completenessScore: number
      reliabilityScore: number
      accuracyScore: number
      validationResults: Prisma.JsonValue
      issues: Prisma.JsonValue
      recommendations: Prisma.JsonValue
      generatedAt: Date
      version: string
    }, ExtArgs["result"]["qualityReport"]>
    composites: {}
  }

  type QualityReportGetPayload<S extends boolean | null | undefined | QualityReportDefaultArgs> = $Result.GetResult<Prisma.$QualityReportPayload, S>

  type QualityReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QualityReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QualityReportCountAggregateInputType | true
    }

  export interface QualityReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QualityReport'], meta: { name: 'QualityReport' } }
    /**
     * Find zero or one QualityReport that matches the filter.
     * @param {QualityReportFindUniqueArgs} args - Arguments to find a QualityReport
     * @example
     * // Get one QualityReport
     * const qualityReport = await prisma.qualityReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QualityReportFindUniqueArgs>(args: SelectSubset<T, QualityReportFindUniqueArgs<ExtArgs>>): Prisma__QualityReportClient<$Result.GetResult<Prisma.$QualityReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QualityReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QualityReportFindUniqueOrThrowArgs} args - Arguments to find a QualityReport
     * @example
     * // Get one QualityReport
     * const qualityReport = await prisma.qualityReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QualityReportFindUniqueOrThrowArgs>(args: SelectSubset<T, QualityReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QualityReportClient<$Result.GetResult<Prisma.$QualityReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QualityReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityReportFindFirstArgs} args - Arguments to find a QualityReport
     * @example
     * // Get one QualityReport
     * const qualityReport = await prisma.qualityReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QualityReportFindFirstArgs>(args?: SelectSubset<T, QualityReportFindFirstArgs<ExtArgs>>): Prisma__QualityReportClient<$Result.GetResult<Prisma.$QualityReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QualityReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityReportFindFirstOrThrowArgs} args - Arguments to find a QualityReport
     * @example
     * // Get one QualityReport
     * const qualityReport = await prisma.qualityReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QualityReportFindFirstOrThrowArgs>(args?: SelectSubset<T, QualityReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__QualityReportClient<$Result.GetResult<Prisma.$QualityReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QualityReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QualityReports
     * const qualityReports = await prisma.qualityReport.findMany()
     * 
     * // Get first 10 QualityReports
     * const qualityReports = await prisma.qualityReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qualityReportWithIdOnly = await prisma.qualityReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QualityReportFindManyArgs>(args?: SelectSubset<T, QualityReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QualityReport.
     * @param {QualityReportCreateArgs} args - Arguments to create a QualityReport.
     * @example
     * // Create one QualityReport
     * const QualityReport = await prisma.qualityReport.create({
     *   data: {
     *     // ... data to create a QualityReport
     *   }
     * })
     * 
     */
    create<T extends QualityReportCreateArgs>(args: SelectSubset<T, QualityReportCreateArgs<ExtArgs>>): Prisma__QualityReportClient<$Result.GetResult<Prisma.$QualityReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QualityReports.
     * @param {QualityReportCreateManyArgs} args - Arguments to create many QualityReports.
     * @example
     * // Create many QualityReports
     * const qualityReport = await prisma.qualityReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QualityReportCreateManyArgs>(args?: SelectSubset<T, QualityReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QualityReports and returns the data saved in the database.
     * @param {QualityReportCreateManyAndReturnArgs} args - Arguments to create many QualityReports.
     * @example
     * // Create many QualityReports
     * const qualityReport = await prisma.qualityReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QualityReports and only return the `id`
     * const qualityReportWithIdOnly = await prisma.qualityReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QualityReportCreateManyAndReturnArgs>(args?: SelectSubset<T, QualityReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QualityReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QualityReport.
     * @param {QualityReportDeleteArgs} args - Arguments to delete one QualityReport.
     * @example
     * // Delete one QualityReport
     * const QualityReport = await prisma.qualityReport.delete({
     *   where: {
     *     // ... filter to delete one QualityReport
     *   }
     * })
     * 
     */
    delete<T extends QualityReportDeleteArgs>(args: SelectSubset<T, QualityReportDeleteArgs<ExtArgs>>): Prisma__QualityReportClient<$Result.GetResult<Prisma.$QualityReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QualityReport.
     * @param {QualityReportUpdateArgs} args - Arguments to update one QualityReport.
     * @example
     * // Update one QualityReport
     * const qualityReport = await prisma.qualityReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QualityReportUpdateArgs>(args: SelectSubset<T, QualityReportUpdateArgs<ExtArgs>>): Prisma__QualityReportClient<$Result.GetResult<Prisma.$QualityReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QualityReports.
     * @param {QualityReportDeleteManyArgs} args - Arguments to filter QualityReports to delete.
     * @example
     * // Delete a few QualityReports
     * const { count } = await prisma.qualityReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QualityReportDeleteManyArgs>(args?: SelectSubset<T, QualityReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QualityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QualityReports
     * const qualityReport = await prisma.qualityReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QualityReportUpdateManyArgs>(args: SelectSubset<T, QualityReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QualityReport.
     * @param {QualityReportUpsertArgs} args - Arguments to update or create a QualityReport.
     * @example
     * // Update or create a QualityReport
     * const qualityReport = await prisma.qualityReport.upsert({
     *   create: {
     *     // ... data to create a QualityReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QualityReport we want to update
     *   }
     * })
     */
    upsert<T extends QualityReportUpsertArgs>(args: SelectSubset<T, QualityReportUpsertArgs<ExtArgs>>): Prisma__QualityReportClient<$Result.GetResult<Prisma.$QualityReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QualityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityReportCountArgs} args - Arguments to filter QualityReports to count.
     * @example
     * // Count the number of QualityReports
     * const count = await prisma.qualityReport.count({
     *   where: {
     *     // ... the filter for the QualityReports we want to count
     *   }
     * })
    **/
    count<T extends QualityReportCountArgs>(
      args?: Subset<T, QualityReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QualityReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QualityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QualityReportAggregateArgs>(args: Subset<T, QualityReportAggregateArgs>): Prisma.PrismaPromise<GetQualityReportAggregateType<T>>

    /**
     * Group by QualityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QualityReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QualityReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QualityReportGroupByArgs['orderBy'] }
        : { orderBy?: QualityReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QualityReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualityReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QualityReport model
   */
  readonly fields: QualityReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QualityReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QualityReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QualityReport model
   */ 
  interface QualityReportFieldRefs {
    readonly id: FieldRef<"QualityReport", 'String'>
    readonly sessionId: FieldRef<"QualityReport", 'String'>
    readonly overallScore: FieldRef<"QualityReport", 'Float'>
    readonly completenessScore: FieldRef<"QualityReport", 'Float'>
    readonly reliabilityScore: FieldRef<"QualityReport", 'Float'>
    readonly accuracyScore: FieldRef<"QualityReport", 'Float'>
    readonly validationResults: FieldRef<"QualityReport", 'Json'>
    readonly issues: FieldRef<"QualityReport", 'Json'>
    readonly recommendations: FieldRef<"QualityReport", 'Json'>
    readonly generatedAt: FieldRef<"QualityReport", 'DateTime'>
    readonly version: FieldRef<"QualityReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QualityReport findUnique
   */
  export type QualityReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelect<ExtArgs> | null
    /**
     * Filter, which QualityReport to fetch.
     */
    where: QualityReportWhereUniqueInput
  }

  /**
   * QualityReport findUniqueOrThrow
   */
  export type QualityReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelect<ExtArgs> | null
    /**
     * Filter, which QualityReport to fetch.
     */
    where: QualityReportWhereUniqueInput
  }

  /**
   * QualityReport findFirst
   */
  export type QualityReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelect<ExtArgs> | null
    /**
     * Filter, which QualityReport to fetch.
     */
    where?: QualityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityReports to fetch.
     */
    orderBy?: QualityReportOrderByWithRelationInput | QualityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualityReports.
     */
    cursor?: QualityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualityReports.
     */
    distinct?: QualityReportScalarFieldEnum | QualityReportScalarFieldEnum[]
  }

  /**
   * QualityReport findFirstOrThrow
   */
  export type QualityReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelect<ExtArgs> | null
    /**
     * Filter, which QualityReport to fetch.
     */
    where?: QualityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityReports to fetch.
     */
    orderBy?: QualityReportOrderByWithRelationInput | QualityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QualityReports.
     */
    cursor?: QualityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QualityReports.
     */
    distinct?: QualityReportScalarFieldEnum | QualityReportScalarFieldEnum[]
  }

  /**
   * QualityReport findMany
   */
  export type QualityReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelect<ExtArgs> | null
    /**
     * Filter, which QualityReports to fetch.
     */
    where?: QualityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QualityReports to fetch.
     */
    orderBy?: QualityReportOrderByWithRelationInput | QualityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QualityReports.
     */
    cursor?: QualityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QualityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QualityReports.
     */
    skip?: number
    distinct?: QualityReportScalarFieldEnum | QualityReportScalarFieldEnum[]
  }

  /**
   * QualityReport create
   */
  export type QualityReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelect<ExtArgs> | null
    /**
     * The data needed to create a QualityReport.
     */
    data: XOR<QualityReportCreateInput, QualityReportUncheckedCreateInput>
  }

  /**
   * QualityReport createMany
   */
  export type QualityReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QualityReports.
     */
    data: QualityReportCreateManyInput | QualityReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QualityReport createManyAndReturn
   */
  export type QualityReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QualityReports.
     */
    data: QualityReportCreateManyInput | QualityReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QualityReport update
   */
  export type QualityReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelect<ExtArgs> | null
    /**
     * The data needed to update a QualityReport.
     */
    data: XOR<QualityReportUpdateInput, QualityReportUncheckedUpdateInput>
    /**
     * Choose, which QualityReport to update.
     */
    where: QualityReportWhereUniqueInput
  }

  /**
   * QualityReport updateMany
   */
  export type QualityReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QualityReports.
     */
    data: XOR<QualityReportUpdateManyMutationInput, QualityReportUncheckedUpdateManyInput>
    /**
     * Filter which QualityReports to update
     */
    where?: QualityReportWhereInput
  }

  /**
   * QualityReport upsert
   */
  export type QualityReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelect<ExtArgs> | null
    /**
     * The filter to search for the QualityReport to update in case it exists.
     */
    where: QualityReportWhereUniqueInput
    /**
     * In case the QualityReport found by the `where` argument doesn't exist, create a new QualityReport with this data.
     */
    create: XOR<QualityReportCreateInput, QualityReportUncheckedCreateInput>
    /**
     * In case the QualityReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QualityReportUpdateInput, QualityReportUncheckedUpdateInput>
  }

  /**
   * QualityReport delete
   */
  export type QualityReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelect<ExtArgs> | null
    /**
     * Filter which QualityReport to delete.
     */
    where: QualityReportWhereUniqueInput
  }

  /**
   * QualityReport deleteMany
   */
  export type QualityReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QualityReports to delete
     */
    where?: QualityReportWhereInput
  }

  /**
   * QualityReport without action
   */
  export type QualityReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QualityReport
     */
    select?: QualityReportSelect<ExtArgs> | null
  }


  /**
   * Model PsychologyProfile
   */

  export type AggregatePsychologyProfile = {
    _count: PsychologyProfileCountAggregateOutputType | null
    _avg: PsychologyProfileAvgAggregateOutputType | null
    _sum: PsychologyProfileSumAggregateOutputType | null
    _min: PsychologyProfileMinAggregateOutputType | null
    _max: PsychologyProfileMaxAggregateOutputType | null
  }

  export type PsychologyProfileAvgAggregateOutputType = {
    trustLevel: number | null
    urgencyLevel: number | null
    priceSensitivity: number | null
    socialInfluence: number | null
    confidence: number | null
  }

  export type PsychologyProfileSumAggregateOutputType = {
    trustLevel: number | null
    urgencyLevel: number | null
    priceSensitivity: number | null
    socialInfluence: number | null
    confidence: number | null
  }

  export type PsychologyProfileMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    dominantPersonality: $Enums.PersonalityType | null
    emotionalState: $Enums.EmotionalState | null
    decisionMakingStyle: $Enums.DecisionMakingStyle | null
    trustLevel: number | null
    urgencyLevel: number | null
    priceSensitivity: number | null
    socialInfluence: number | null
    confidence: number | null
    processingTimestamp: Date | null
  }

  export type PsychologyProfileMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    dominantPersonality: $Enums.PersonalityType | null
    emotionalState: $Enums.EmotionalState | null
    decisionMakingStyle: $Enums.DecisionMakingStyle | null
    trustLevel: number | null
    urgencyLevel: number | null
    priceSensitivity: number | null
    socialInfluence: number | null
    confidence: number | null
    processingTimestamp: Date | null
  }

  export type PsychologyProfileCountAggregateOutputType = {
    id: number
    sessionId: number
    dominantPersonality: number
    emotionalState: number
    decisionMakingStyle: number
    trustLevel: number
    urgencyLevel: number
    priceSensitivity: number
    socialInfluence: number
    insights: number
    behaviorPredictions: number
    recommendations: number
    confidence: number
    processingTimestamp: number
    _all: number
  }


  export type PsychologyProfileAvgAggregateInputType = {
    trustLevel?: true
    urgencyLevel?: true
    priceSensitivity?: true
    socialInfluence?: true
    confidence?: true
  }

  export type PsychologyProfileSumAggregateInputType = {
    trustLevel?: true
    urgencyLevel?: true
    priceSensitivity?: true
    socialInfluence?: true
    confidence?: true
  }

  export type PsychologyProfileMinAggregateInputType = {
    id?: true
    sessionId?: true
    dominantPersonality?: true
    emotionalState?: true
    decisionMakingStyle?: true
    trustLevel?: true
    urgencyLevel?: true
    priceSensitivity?: true
    socialInfluence?: true
    confidence?: true
    processingTimestamp?: true
  }

  export type PsychologyProfileMaxAggregateInputType = {
    id?: true
    sessionId?: true
    dominantPersonality?: true
    emotionalState?: true
    decisionMakingStyle?: true
    trustLevel?: true
    urgencyLevel?: true
    priceSensitivity?: true
    socialInfluence?: true
    confidence?: true
    processingTimestamp?: true
  }

  export type PsychologyProfileCountAggregateInputType = {
    id?: true
    sessionId?: true
    dominantPersonality?: true
    emotionalState?: true
    decisionMakingStyle?: true
    trustLevel?: true
    urgencyLevel?: true
    priceSensitivity?: true
    socialInfluence?: true
    insights?: true
    behaviorPredictions?: true
    recommendations?: true
    confidence?: true
    processingTimestamp?: true
    _all?: true
  }

  export type PsychologyProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PsychologyProfile to aggregate.
     */
    where?: PsychologyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PsychologyProfiles to fetch.
     */
    orderBy?: PsychologyProfileOrderByWithRelationInput | PsychologyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PsychologyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PsychologyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PsychologyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PsychologyProfiles
    **/
    _count?: true | PsychologyProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PsychologyProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PsychologyProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PsychologyProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PsychologyProfileMaxAggregateInputType
  }

  export type GetPsychologyProfileAggregateType<T extends PsychologyProfileAggregateArgs> = {
        [P in keyof T & keyof AggregatePsychologyProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePsychologyProfile[P]>
      : GetScalarType<T[P], AggregatePsychologyProfile[P]>
  }




  export type PsychologyProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PsychologyProfileWhereInput
    orderBy?: PsychologyProfileOrderByWithAggregationInput | PsychologyProfileOrderByWithAggregationInput[]
    by: PsychologyProfileScalarFieldEnum[] | PsychologyProfileScalarFieldEnum
    having?: PsychologyProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PsychologyProfileCountAggregateInputType | true
    _avg?: PsychologyProfileAvgAggregateInputType
    _sum?: PsychologyProfileSumAggregateInputType
    _min?: PsychologyProfileMinAggregateInputType
    _max?: PsychologyProfileMaxAggregateInputType
  }

  export type PsychologyProfileGroupByOutputType = {
    id: string
    sessionId: string
    dominantPersonality: $Enums.PersonalityType
    emotionalState: $Enums.EmotionalState
    decisionMakingStyle: $Enums.DecisionMakingStyle
    trustLevel: number
    urgencyLevel: number
    priceSensitivity: number
    socialInfluence: number
    insights: JsonValue
    behaviorPredictions: JsonValue
    recommendations: JsonValue
    confidence: number
    processingTimestamp: Date
    _count: PsychologyProfileCountAggregateOutputType | null
    _avg: PsychologyProfileAvgAggregateOutputType | null
    _sum: PsychologyProfileSumAggregateOutputType | null
    _min: PsychologyProfileMinAggregateOutputType | null
    _max: PsychologyProfileMaxAggregateOutputType | null
  }

  type GetPsychologyProfileGroupByPayload<T extends PsychologyProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PsychologyProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PsychologyProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PsychologyProfileGroupByOutputType[P]>
            : GetScalarType<T[P], PsychologyProfileGroupByOutputType[P]>
        }
      >
    >


  export type PsychologyProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    dominantPersonality?: boolean
    emotionalState?: boolean
    decisionMakingStyle?: boolean
    trustLevel?: boolean
    urgencyLevel?: boolean
    priceSensitivity?: boolean
    socialInfluence?: boolean
    insights?: boolean
    behaviorPredictions?: boolean
    recommendations?: boolean
    confidence?: boolean
    processingTimestamp?: boolean
  }, ExtArgs["result"]["psychologyProfile"]>

  export type PsychologyProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    dominantPersonality?: boolean
    emotionalState?: boolean
    decisionMakingStyle?: boolean
    trustLevel?: boolean
    urgencyLevel?: boolean
    priceSensitivity?: boolean
    socialInfluence?: boolean
    insights?: boolean
    behaviorPredictions?: boolean
    recommendations?: boolean
    confidence?: boolean
    processingTimestamp?: boolean
  }, ExtArgs["result"]["psychologyProfile"]>

  export type PsychologyProfileSelectScalar = {
    id?: boolean
    sessionId?: boolean
    dominantPersonality?: boolean
    emotionalState?: boolean
    decisionMakingStyle?: boolean
    trustLevel?: boolean
    urgencyLevel?: boolean
    priceSensitivity?: boolean
    socialInfluence?: boolean
    insights?: boolean
    behaviorPredictions?: boolean
    recommendations?: boolean
    confidence?: boolean
    processingTimestamp?: boolean
  }


  export type $PsychologyProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PsychologyProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      dominantPersonality: $Enums.PersonalityType
      emotionalState: $Enums.EmotionalState
      decisionMakingStyle: $Enums.DecisionMakingStyle
      trustLevel: number
      urgencyLevel: number
      priceSensitivity: number
      socialInfluence: number
      insights: Prisma.JsonValue
      behaviorPredictions: Prisma.JsonValue
      recommendations: Prisma.JsonValue
      confidence: number
      processingTimestamp: Date
    }, ExtArgs["result"]["psychologyProfile"]>
    composites: {}
  }

  type PsychologyProfileGetPayload<S extends boolean | null | undefined | PsychologyProfileDefaultArgs> = $Result.GetResult<Prisma.$PsychologyProfilePayload, S>

  type PsychologyProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PsychologyProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PsychologyProfileCountAggregateInputType | true
    }

  export interface PsychologyProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PsychologyProfile'], meta: { name: 'PsychologyProfile' } }
    /**
     * Find zero or one PsychologyProfile that matches the filter.
     * @param {PsychologyProfileFindUniqueArgs} args - Arguments to find a PsychologyProfile
     * @example
     * // Get one PsychologyProfile
     * const psychologyProfile = await prisma.psychologyProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PsychologyProfileFindUniqueArgs>(args: SelectSubset<T, PsychologyProfileFindUniqueArgs<ExtArgs>>): Prisma__PsychologyProfileClient<$Result.GetResult<Prisma.$PsychologyProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PsychologyProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PsychologyProfileFindUniqueOrThrowArgs} args - Arguments to find a PsychologyProfile
     * @example
     * // Get one PsychologyProfile
     * const psychologyProfile = await prisma.psychologyProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PsychologyProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, PsychologyProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PsychologyProfileClient<$Result.GetResult<Prisma.$PsychologyProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PsychologyProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PsychologyProfileFindFirstArgs} args - Arguments to find a PsychologyProfile
     * @example
     * // Get one PsychologyProfile
     * const psychologyProfile = await prisma.psychologyProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PsychologyProfileFindFirstArgs>(args?: SelectSubset<T, PsychologyProfileFindFirstArgs<ExtArgs>>): Prisma__PsychologyProfileClient<$Result.GetResult<Prisma.$PsychologyProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PsychologyProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PsychologyProfileFindFirstOrThrowArgs} args - Arguments to find a PsychologyProfile
     * @example
     * // Get one PsychologyProfile
     * const psychologyProfile = await prisma.psychologyProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PsychologyProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, PsychologyProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__PsychologyProfileClient<$Result.GetResult<Prisma.$PsychologyProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PsychologyProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PsychologyProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PsychologyProfiles
     * const psychologyProfiles = await prisma.psychologyProfile.findMany()
     * 
     * // Get first 10 PsychologyProfiles
     * const psychologyProfiles = await prisma.psychologyProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const psychologyProfileWithIdOnly = await prisma.psychologyProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PsychologyProfileFindManyArgs>(args?: SelectSubset<T, PsychologyProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PsychologyProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PsychologyProfile.
     * @param {PsychologyProfileCreateArgs} args - Arguments to create a PsychologyProfile.
     * @example
     * // Create one PsychologyProfile
     * const PsychologyProfile = await prisma.psychologyProfile.create({
     *   data: {
     *     // ... data to create a PsychologyProfile
     *   }
     * })
     * 
     */
    create<T extends PsychologyProfileCreateArgs>(args: SelectSubset<T, PsychologyProfileCreateArgs<ExtArgs>>): Prisma__PsychologyProfileClient<$Result.GetResult<Prisma.$PsychologyProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PsychologyProfiles.
     * @param {PsychologyProfileCreateManyArgs} args - Arguments to create many PsychologyProfiles.
     * @example
     * // Create many PsychologyProfiles
     * const psychologyProfile = await prisma.psychologyProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PsychologyProfileCreateManyArgs>(args?: SelectSubset<T, PsychologyProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PsychologyProfiles and returns the data saved in the database.
     * @param {PsychologyProfileCreateManyAndReturnArgs} args - Arguments to create many PsychologyProfiles.
     * @example
     * // Create many PsychologyProfiles
     * const psychologyProfile = await prisma.psychologyProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PsychologyProfiles and only return the `id`
     * const psychologyProfileWithIdOnly = await prisma.psychologyProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PsychologyProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, PsychologyProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PsychologyProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PsychologyProfile.
     * @param {PsychologyProfileDeleteArgs} args - Arguments to delete one PsychologyProfile.
     * @example
     * // Delete one PsychologyProfile
     * const PsychologyProfile = await prisma.psychologyProfile.delete({
     *   where: {
     *     // ... filter to delete one PsychologyProfile
     *   }
     * })
     * 
     */
    delete<T extends PsychologyProfileDeleteArgs>(args: SelectSubset<T, PsychologyProfileDeleteArgs<ExtArgs>>): Prisma__PsychologyProfileClient<$Result.GetResult<Prisma.$PsychologyProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PsychologyProfile.
     * @param {PsychologyProfileUpdateArgs} args - Arguments to update one PsychologyProfile.
     * @example
     * // Update one PsychologyProfile
     * const psychologyProfile = await prisma.psychologyProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PsychologyProfileUpdateArgs>(args: SelectSubset<T, PsychologyProfileUpdateArgs<ExtArgs>>): Prisma__PsychologyProfileClient<$Result.GetResult<Prisma.$PsychologyProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PsychologyProfiles.
     * @param {PsychologyProfileDeleteManyArgs} args - Arguments to filter PsychologyProfiles to delete.
     * @example
     * // Delete a few PsychologyProfiles
     * const { count } = await prisma.psychologyProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PsychologyProfileDeleteManyArgs>(args?: SelectSubset<T, PsychologyProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PsychologyProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PsychologyProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PsychologyProfiles
     * const psychologyProfile = await prisma.psychologyProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PsychologyProfileUpdateManyArgs>(args: SelectSubset<T, PsychologyProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PsychologyProfile.
     * @param {PsychologyProfileUpsertArgs} args - Arguments to update or create a PsychologyProfile.
     * @example
     * // Update or create a PsychologyProfile
     * const psychologyProfile = await prisma.psychologyProfile.upsert({
     *   create: {
     *     // ... data to create a PsychologyProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PsychologyProfile we want to update
     *   }
     * })
     */
    upsert<T extends PsychologyProfileUpsertArgs>(args: SelectSubset<T, PsychologyProfileUpsertArgs<ExtArgs>>): Prisma__PsychologyProfileClient<$Result.GetResult<Prisma.$PsychologyProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PsychologyProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PsychologyProfileCountArgs} args - Arguments to filter PsychologyProfiles to count.
     * @example
     * // Count the number of PsychologyProfiles
     * const count = await prisma.psychologyProfile.count({
     *   where: {
     *     // ... the filter for the PsychologyProfiles we want to count
     *   }
     * })
    **/
    count<T extends PsychologyProfileCountArgs>(
      args?: Subset<T, PsychologyProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PsychologyProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PsychologyProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PsychologyProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PsychologyProfileAggregateArgs>(args: Subset<T, PsychologyProfileAggregateArgs>): Prisma.PrismaPromise<GetPsychologyProfileAggregateType<T>>

    /**
     * Group by PsychologyProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PsychologyProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PsychologyProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PsychologyProfileGroupByArgs['orderBy'] }
        : { orderBy?: PsychologyProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PsychologyProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPsychologyProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PsychologyProfile model
   */
  readonly fields: PsychologyProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PsychologyProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PsychologyProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PsychologyProfile model
   */ 
  interface PsychologyProfileFieldRefs {
    readonly id: FieldRef<"PsychologyProfile", 'String'>
    readonly sessionId: FieldRef<"PsychologyProfile", 'String'>
    readonly dominantPersonality: FieldRef<"PsychologyProfile", 'PersonalityType'>
    readonly emotionalState: FieldRef<"PsychologyProfile", 'EmotionalState'>
    readonly decisionMakingStyle: FieldRef<"PsychologyProfile", 'DecisionMakingStyle'>
    readonly trustLevel: FieldRef<"PsychologyProfile", 'Float'>
    readonly urgencyLevel: FieldRef<"PsychologyProfile", 'Float'>
    readonly priceSensitivity: FieldRef<"PsychologyProfile", 'Float'>
    readonly socialInfluence: FieldRef<"PsychologyProfile", 'Float'>
    readonly insights: FieldRef<"PsychologyProfile", 'Json'>
    readonly behaviorPredictions: FieldRef<"PsychologyProfile", 'Json'>
    readonly recommendations: FieldRef<"PsychologyProfile", 'Json'>
    readonly confidence: FieldRef<"PsychologyProfile", 'Float'>
    readonly processingTimestamp: FieldRef<"PsychologyProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PsychologyProfile findUnique
   */
  export type PsychologyProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelect<ExtArgs> | null
    /**
     * Filter, which PsychologyProfile to fetch.
     */
    where: PsychologyProfileWhereUniqueInput
  }

  /**
   * PsychologyProfile findUniqueOrThrow
   */
  export type PsychologyProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelect<ExtArgs> | null
    /**
     * Filter, which PsychologyProfile to fetch.
     */
    where: PsychologyProfileWhereUniqueInput
  }

  /**
   * PsychologyProfile findFirst
   */
  export type PsychologyProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelect<ExtArgs> | null
    /**
     * Filter, which PsychologyProfile to fetch.
     */
    where?: PsychologyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PsychologyProfiles to fetch.
     */
    orderBy?: PsychologyProfileOrderByWithRelationInput | PsychologyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PsychologyProfiles.
     */
    cursor?: PsychologyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PsychologyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PsychologyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PsychologyProfiles.
     */
    distinct?: PsychologyProfileScalarFieldEnum | PsychologyProfileScalarFieldEnum[]
  }

  /**
   * PsychologyProfile findFirstOrThrow
   */
  export type PsychologyProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelect<ExtArgs> | null
    /**
     * Filter, which PsychologyProfile to fetch.
     */
    where?: PsychologyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PsychologyProfiles to fetch.
     */
    orderBy?: PsychologyProfileOrderByWithRelationInput | PsychologyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PsychologyProfiles.
     */
    cursor?: PsychologyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PsychologyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PsychologyProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PsychologyProfiles.
     */
    distinct?: PsychologyProfileScalarFieldEnum | PsychologyProfileScalarFieldEnum[]
  }

  /**
   * PsychologyProfile findMany
   */
  export type PsychologyProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelect<ExtArgs> | null
    /**
     * Filter, which PsychologyProfiles to fetch.
     */
    where?: PsychologyProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PsychologyProfiles to fetch.
     */
    orderBy?: PsychologyProfileOrderByWithRelationInput | PsychologyProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PsychologyProfiles.
     */
    cursor?: PsychologyProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PsychologyProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PsychologyProfiles.
     */
    skip?: number
    distinct?: PsychologyProfileScalarFieldEnum | PsychologyProfileScalarFieldEnum[]
  }

  /**
   * PsychologyProfile create
   */
  export type PsychologyProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelect<ExtArgs> | null
    /**
     * The data needed to create a PsychologyProfile.
     */
    data: XOR<PsychologyProfileCreateInput, PsychologyProfileUncheckedCreateInput>
  }

  /**
   * PsychologyProfile createMany
   */
  export type PsychologyProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PsychologyProfiles.
     */
    data: PsychologyProfileCreateManyInput | PsychologyProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PsychologyProfile createManyAndReturn
   */
  export type PsychologyProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PsychologyProfiles.
     */
    data: PsychologyProfileCreateManyInput | PsychologyProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PsychologyProfile update
   */
  export type PsychologyProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelect<ExtArgs> | null
    /**
     * The data needed to update a PsychologyProfile.
     */
    data: XOR<PsychologyProfileUpdateInput, PsychologyProfileUncheckedUpdateInput>
    /**
     * Choose, which PsychologyProfile to update.
     */
    where: PsychologyProfileWhereUniqueInput
  }

  /**
   * PsychologyProfile updateMany
   */
  export type PsychologyProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PsychologyProfiles.
     */
    data: XOR<PsychologyProfileUpdateManyMutationInput, PsychologyProfileUncheckedUpdateManyInput>
    /**
     * Filter which PsychologyProfiles to update
     */
    where?: PsychologyProfileWhereInput
  }

  /**
   * PsychologyProfile upsert
   */
  export type PsychologyProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelect<ExtArgs> | null
    /**
     * The filter to search for the PsychologyProfile to update in case it exists.
     */
    where: PsychologyProfileWhereUniqueInput
    /**
     * In case the PsychologyProfile found by the `where` argument doesn't exist, create a new PsychologyProfile with this data.
     */
    create: XOR<PsychologyProfileCreateInput, PsychologyProfileUncheckedCreateInput>
    /**
     * In case the PsychologyProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PsychologyProfileUpdateInput, PsychologyProfileUncheckedUpdateInput>
  }

  /**
   * PsychologyProfile delete
   */
  export type PsychologyProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelect<ExtArgs> | null
    /**
     * Filter which PsychologyProfile to delete.
     */
    where: PsychologyProfileWhereUniqueInput
  }

  /**
   * PsychologyProfile deleteMany
   */
  export type PsychologyProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PsychologyProfiles to delete
     */
    where?: PsychologyProfileWhereInput
  }

  /**
   * PsychologyProfile without action
   */
  export type PsychologyProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PsychologyProfile
     */
    select?: PsychologyProfileSelect<ExtArgs> | null
  }


  /**
   * Model ContextEnhancement
   */

  export type AggregateContextEnhancement = {
    _count: ContextEnhancementCountAggregateOutputType | null
    _avg: ContextEnhancementAvgAggregateOutputType | null
    _sum: ContextEnhancementSumAggregateOutputType | null
    _min: ContextEnhancementMinAggregateOutputType | null
    _max: ContextEnhancementMaxAggregateOutputType | null
  }

  export type ContextEnhancementAvgAggregateOutputType = {
    trainingValue: number | null
  }

  export type ContextEnhancementSumAggregateOutputType = {
    trainingValue: number | null
  }

  export type ContextEnhancementMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    trainingValue: number | null
    processingTimestamp: Date | null
  }

  export type ContextEnhancementMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    trainingValue: number | null
    processingTimestamp: Date | null
  }

  export type ContextEnhancementCountAggregateOutputType = {
    id: number
    sessionId: number
    pageStructure: number
    userIntent: number
    navigationPattern: number
    shoppingBehavior: number
    contextualInsights: number
    trainingValue: number
    processingTimestamp: number
    _all: number
  }


  export type ContextEnhancementAvgAggregateInputType = {
    trainingValue?: true
  }

  export type ContextEnhancementSumAggregateInputType = {
    trainingValue?: true
  }

  export type ContextEnhancementMinAggregateInputType = {
    id?: true
    sessionId?: true
    trainingValue?: true
    processingTimestamp?: true
  }

  export type ContextEnhancementMaxAggregateInputType = {
    id?: true
    sessionId?: true
    trainingValue?: true
    processingTimestamp?: true
  }

  export type ContextEnhancementCountAggregateInputType = {
    id?: true
    sessionId?: true
    pageStructure?: true
    userIntent?: true
    navigationPattern?: true
    shoppingBehavior?: true
    contextualInsights?: true
    trainingValue?: true
    processingTimestamp?: true
    _all?: true
  }

  export type ContextEnhancementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextEnhancement to aggregate.
     */
    where?: ContextEnhancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextEnhancements to fetch.
     */
    orderBy?: ContextEnhancementOrderByWithRelationInput | ContextEnhancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextEnhancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextEnhancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextEnhancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextEnhancements
    **/
    _count?: true | ContextEnhancementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextEnhancementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextEnhancementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextEnhancementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextEnhancementMaxAggregateInputType
  }

  export type GetContextEnhancementAggregateType<T extends ContextEnhancementAggregateArgs> = {
        [P in keyof T & keyof AggregateContextEnhancement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextEnhancement[P]>
      : GetScalarType<T[P], AggregateContextEnhancement[P]>
  }




  export type ContextEnhancementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContextEnhancementWhereInput
    orderBy?: ContextEnhancementOrderByWithAggregationInput | ContextEnhancementOrderByWithAggregationInput[]
    by: ContextEnhancementScalarFieldEnum[] | ContextEnhancementScalarFieldEnum
    having?: ContextEnhancementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextEnhancementCountAggregateInputType | true
    _avg?: ContextEnhancementAvgAggregateInputType
    _sum?: ContextEnhancementSumAggregateInputType
    _min?: ContextEnhancementMinAggregateInputType
    _max?: ContextEnhancementMaxAggregateInputType
  }

  export type ContextEnhancementGroupByOutputType = {
    id: string
    sessionId: string
    pageStructure: JsonValue
    userIntent: JsonValue
    navigationPattern: JsonValue
    shoppingBehavior: JsonValue
    contextualInsights: JsonValue
    trainingValue: number
    processingTimestamp: Date
    _count: ContextEnhancementCountAggregateOutputType | null
    _avg: ContextEnhancementAvgAggregateOutputType | null
    _sum: ContextEnhancementSumAggregateOutputType | null
    _min: ContextEnhancementMinAggregateOutputType | null
    _max: ContextEnhancementMaxAggregateOutputType | null
  }

  type GetContextEnhancementGroupByPayload<T extends ContextEnhancementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextEnhancementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextEnhancementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextEnhancementGroupByOutputType[P]>
            : GetScalarType<T[P], ContextEnhancementGroupByOutputType[P]>
        }
      >
    >


  export type ContextEnhancementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    pageStructure?: boolean
    userIntent?: boolean
    navigationPattern?: boolean
    shoppingBehavior?: boolean
    contextualInsights?: boolean
    trainingValue?: boolean
    processingTimestamp?: boolean
  }, ExtArgs["result"]["contextEnhancement"]>

  export type ContextEnhancementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    pageStructure?: boolean
    userIntent?: boolean
    navigationPattern?: boolean
    shoppingBehavior?: boolean
    contextualInsights?: boolean
    trainingValue?: boolean
    processingTimestamp?: boolean
  }, ExtArgs["result"]["contextEnhancement"]>

  export type ContextEnhancementSelectScalar = {
    id?: boolean
    sessionId?: boolean
    pageStructure?: boolean
    userIntent?: boolean
    navigationPattern?: boolean
    shoppingBehavior?: boolean
    contextualInsights?: boolean
    trainingValue?: boolean
    processingTimestamp?: boolean
  }


  export type $ContextEnhancementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContextEnhancement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      pageStructure: Prisma.JsonValue
      userIntent: Prisma.JsonValue
      navigationPattern: Prisma.JsonValue
      shoppingBehavior: Prisma.JsonValue
      contextualInsights: Prisma.JsonValue
      trainingValue: number
      processingTimestamp: Date
    }, ExtArgs["result"]["contextEnhancement"]>
    composites: {}
  }

  type ContextEnhancementGetPayload<S extends boolean | null | undefined | ContextEnhancementDefaultArgs> = $Result.GetResult<Prisma.$ContextEnhancementPayload, S>

  type ContextEnhancementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContextEnhancementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContextEnhancementCountAggregateInputType | true
    }

  export interface ContextEnhancementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextEnhancement'], meta: { name: 'ContextEnhancement' } }
    /**
     * Find zero or one ContextEnhancement that matches the filter.
     * @param {ContextEnhancementFindUniqueArgs} args - Arguments to find a ContextEnhancement
     * @example
     * // Get one ContextEnhancement
     * const contextEnhancement = await prisma.contextEnhancement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContextEnhancementFindUniqueArgs>(args: SelectSubset<T, ContextEnhancementFindUniqueArgs<ExtArgs>>): Prisma__ContextEnhancementClient<$Result.GetResult<Prisma.$ContextEnhancementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContextEnhancement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContextEnhancementFindUniqueOrThrowArgs} args - Arguments to find a ContextEnhancement
     * @example
     * // Get one ContextEnhancement
     * const contextEnhancement = await prisma.contextEnhancement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContextEnhancementFindUniqueOrThrowArgs>(args: SelectSubset<T, ContextEnhancementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContextEnhancementClient<$Result.GetResult<Prisma.$ContextEnhancementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContextEnhancement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextEnhancementFindFirstArgs} args - Arguments to find a ContextEnhancement
     * @example
     * // Get one ContextEnhancement
     * const contextEnhancement = await prisma.contextEnhancement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContextEnhancementFindFirstArgs>(args?: SelectSubset<T, ContextEnhancementFindFirstArgs<ExtArgs>>): Prisma__ContextEnhancementClient<$Result.GetResult<Prisma.$ContextEnhancementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContextEnhancement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextEnhancementFindFirstOrThrowArgs} args - Arguments to find a ContextEnhancement
     * @example
     * // Get one ContextEnhancement
     * const contextEnhancement = await prisma.contextEnhancement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContextEnhancementFindFirstOrThrowArgs>(args?: SelectSubset<T, ContextEnhancementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContextEnhancementClient<$Result.GetResult<Prisma.$ContextEnhancementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContextEnhancements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextEnhancementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextEnhancements
     * const contextEnhancements = await prisma.contextEnhancement.findMany()
     * 
     * // Get first 10 ContextEnhancements
     * const contextEnhancements = await prisma.contextEnhancement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextEnhancementWithIdOnly = await prisma.contextEnhancement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContextEnhancementFindManyArgs>(args?: SelectSubset<T, ContextEnhancementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextEnhancementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContextEnhancement.
     * @param {ContextEnhancementCreateArgs} args - Arguments to create a ContextEnhancement.
     * @example
     * // Create one ContextEnhancement
     * const ContextEnhancement = await prisma.contextEnhancement.create({
     *   data: {
     *     // ... data to create a ContextEnhancement
     *   }
     * })
     * 
     */
    create<T extends ContextEnhancementCreateArgs>(args: SelectSubset<T, ContextEnhancementCreateArgs<ExtArgs>>): Prisma__ContextEnhancementClient<$Result.GetResult<Prisma.$ContextEnhancementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContextEnhancements.
     * @param {ContextEnhancementCreateManyArgs} args - Arguments to create many ContextEnhancements.
     * @example
     * // Create many ContextEnhancements
     * const contextEnhancement = await prisma.contextEnhancement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContextEnhancementCreateManyArgs>(args?: SelectSubset<T, ContextEnhancementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContextEnhancements and returns the data saved in the database.
     * @param {ContextEnhancementCreateManyAndReturnArgs} args - Arguments to create many ContextEnhancements.
     * @example
     * // Create many ContextEnhancements
     * const contextEnhancement = await prisma.contextEnhancement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContextEnhancements and only return the `id`
     * const contextEnhancementWithIdOnly = await prisma.contextEnhancement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContextEnhancementCreateManyAndReturnArgs>(args?: SelectSubset<T, ContextEnhancementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContextEnhancementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContextEnhancement.
     * @param {ContextEnhancementDeleteArgs} args - Arguments to delete one ContextEnhancement.
     * @example
     * // Delete one ContextEnhancement
     * const ContextEnhancement = await prisma.contextEnhancement.delete({
     *   where: {
     *     // ... filter to delete one ContextEnhancement
     *   }
     * })
     * 
     */
    delete<T extends ContextEnhancementDeleteArgs>(args: SelectSubset<T, ContextEnhancementDeleteArgs<ExtArgs>>): Prisma__ContextEnhancementClient<$Result.GetResult<Prisma.$ContextEnhancementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContextEnhancement.
     * @param {ContextEnhancementUpdateArgs} args - Arguments to update one ContextEnhancement.
     * @example
     * // Update one ContextEnhancement
     * const contextEnhancement = await prisma.contextEnhancement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContextEnhancementUpdateArgs>(args: SelectSubset<T, ContextEnhancementUpdateArgs<ExtArgs>>): Prisma__ContextEnhancementClient<$Result.GetResult<Prisma.$ContextEnhancementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContextEnhancements.
     * @param {ContextEnhancementDeleteManyArgs} args - Arguments to filter ContextEnhancements to delete.
     * @example
     * // Delete a few ContextEnhancements
     * const { count } = await prisma.contextEnhancement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContextEnhancementDeleteManyArgs>(args?: SelectSubset<T, ContextEnhancementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextEnhancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextEnhancementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextEnhancements
     * const contextEnhancement = await prisma.contextEnhancement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContextEnhancementUpdateManyArgs>(args: SelectSubset<T, ContextEnhancementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContextEnhancement.
     * @param {ContextEnhancementUpsertArgs} args - Arguments to update or create a ContextEnhancement.
     * @example
     * // Update or create a ContextEnhancement
     * const contextEnhancement = await prisma.contextEnhancement.upsert({
     *   create: {
     *     // ... data to create a ContextEnhancement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextEnhancement we want to update
     *   }
     * })
     */
    upsert<T extends ContextEnhancementUpsertArgs>(args: SelectSubset<T, ContextEnhancementUpsertArgs<ExtArgs>>): Prisma__ContextEnhancementClient<$Result.GetResult<Prisma.$ContextEnhancementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContextEnhancements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextEnhancementCountArgs} args - Arguments to filter ContextEnhancements to count.
     * @example
     * // Count the number of ContextEnhancements
     * const count = await prisma.contextEnhancement.count({
     *   where: {
     *     // ... the filter for the ContextEnhancements we want to count
     *   }
     * })
    **/
    count<T extends ContextEnhancementCountArgs>(
      args?: Subset<T, ContextEnhancementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextEnhancementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextEnhancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextEnhancementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextEnhancementAggregateArgs>(args: Subset<T, ContextEnhancementAggregateArgs>): Prisma.PrismaPromise<GetContextEnhancementAggregateType<T>>

    /**
     * Group by ContextEnhancement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextEnhancementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextEnhancementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextEnhancementGroupByArgs['orderBy'] }
        : { orderBy?: ContextEnhancementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextEnhancementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextEnhancementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextEnhancement model
   */
  readonly fields: ContextEnhancementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextEnhancement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContextEnhancementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContextEnhancement model
   */ 
  interface ContextEnhancementFieldRefs {
    readonly id: FieldRef<"ContextEnhancement", 'String'>
    readonly sessionId: FieldRef<"ContextEnhancement", 'String'>
    readonly pageStructure: FieldRef<"ContextEnhancement", 'Json'>
    readonly userIntent: FieldRef<"ContextEnhancement", 'Json'>
    readonly navigationPattern: FieldRef<"ContextEnhancement", 'Json'>
    readonly shoppingBehavior: FieldRef<"ContextEnhancement", 'Json'>
    readonly contextualInsights: FieldRef<"ContextEnhancement", 'Json'>
    readonly trainingValue: FieldRef<"ContextEnhancement", 'Float'>
    readonly processingTimestamp: FieldRef<"ContextEnhancement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContextEnhancement findUnique
   */
  export type ContextEnhancementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelect<ExtArgs> | null
    /**
     * Filter, which ContextEnhancement to fetch.
     */
    where: ContextEnhancementWhereUniqueInput
  }

  /**
   * ContextEnhancement findUniqueOrThrow
   */
  export type ContextEnhancementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelect<ExtArgs> | null
    /**
     * Filter, which ContextEnhancement to fetch.
     */
    where: ContextEnhancementWhereUniqueInput
  }

  /**
   * ContextEnhancement findFirst
   */
  export type ContextEnhancementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelect<ExtArgs> | null
    /**
     * Filter, which ContextEnhancement to fetch.
     */
    where?: ContextEnhancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextEnhancements to fetch.
     */
    orderBy?: ContextEnhancementOrderByWithRelationInput | ContextEnhancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextEnhancements.
     */
    cursor?: ContextEnhancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextEnhancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextEnhancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextEnhancements.
     */
    distinct?: ContextEnhancementScalarFieldEnum | ContextEnhancementScalarFieldEnum[]
  }

  /**
   * ContextEnhancement findFirstOrThrow
   */
  export type ContextEnhancementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelect<ExtArgs> | null
    /**
     * Filter, which ContextEnhancement to fetch.
     */
    where?: ContextEnhancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextEnhancements to fetch.
     */
    orderBy?: ContextEnhancementOrderByWithRelationInput | ContextEnhancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextEnhancements.
     */
    cursor?: ContextEnhancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextEnhancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextEnhancements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextEnhancements.
     */
    distinct?: ContextEnhancementScalarFieldEnum | ContextEnhancementScalarFieldEnum[]
  }

  /**
   * ContextEnhancement findMany
   */
  export type ContextEnhancementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelect<ExtArgs> | null
    /**
     * Filter, which ContextEnhancements to fetch.
     */
    where?: ContextEnhancementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextEnhancements to fetch.
     */
    orderBy?: ContextEnhancementOrderByWithRelationInput | ContextEnhancementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextEnhancements.
     */
    cursor?: ContextEnhancementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextEnhancements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextEnhancements.
     */
    skip?: number
    distinct?: ContextEnhancementScalarFieldEnum | ContextEnhancementScalarFieldEnum[]
  }

  /**
   * ContextEnhancement create
   */
  export type ContextEnhancementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelect<ExtArgs> | null
    /**
     * The data needed to create a ContextEnhancement.
     */
    data: XOR<ContextEnhancementCreateInput, ContextEnhancementUncheckedCreateInput>
  }

  /**
   * ContextEnhancement createMany
   */
  export type ContextEnhancementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextEnhancements.
     */
    data: ContextEnhancementCreateManyInput | ContextEnhancementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContextEnhancement createManyAndReturn
   */
  export type ContextEnhancementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContextEnhancements.
     */
    data: ContextEnhancementCreateManyInput | ContextEnhancementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContextEnhancement update
   */
  export type ContextEnhancementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelect<ExtArgs> | null
    /**
     * The data needed to update a ContextEnhancement.
     */
    data: XOR<ContextEnhancementUpdateInput, ContextEnhancementUncheckedUpdateInput>
    /**
     * Choose, which ContextEnhancement to update.
     */
    where: ContextEnhancementWhereUniqueInput
  }

  /**
   * ContextEnhancement updateMany
   */
  export type ContextEnhancementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextEnhancements.
     */
    data: XOR<ContextEnhancementUpdateManyMutationInput, ContextEnhancementUncheckedUpdateManyInput>
    /**
     * Filter which ContextEnhancements to update
     */
    where?: ContextEnhancementWhereInput
  }

  /**
   * ContextEnhancement upsert
   */
  export type ContextEnhancementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelect<ExtArgs> | null
    /**
     * The filter to search for the ContextEnhancement to update in case it exists.
     */
    where: ContextEnhancementWhereUniqueInput
    /**
     * In case the ContextEnhancement found by the `where` argument doesn't exist, create a new ContextEnhancement with this data.
     */
    create: XOR<ContextEnhancementCreateInput, ContextEnhancementUncheckedCreateInput>
    /**
     * In case the ContextEnhancement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextEnhancementUpdateInput, ContextEnhancementUncheckedUpdateInput>
  }

  /**
   * ContextEnhancement delete
   */
  export type ContextEnhancementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelect<ExtArgs> | null
    /**
     * Filter which ContextEnhancement to delete.
     */
    where: ContextEnhancementWhereUniqueInput
  }

  /**
   * ContextEnhancement deleteMany
   */
  export type ContextEnhancementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextEnhancements to delete
     */
    where?: ContextEnhancementWhereInput
  }

  /**
   * ContextEnhancement without action
   */
  export type ContextEnhancementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextEnhancement
     */
    select?: ContextEnhancementSelect<ExtArgs> | null
  }


  /**
   * Model VisionAnalysisCache
   */

  export type AggregateVisionAnalysisCache = {
    _count: VisionAnalysisCacheCountAggregateOutputType | null
    _avg: VisionAnalysisCacheAvgAggregateOutputType | null
    _sum: VisionAnalysisCacheSumAggregateOutputType | null
    _min: VisionAnalysisCacheMinAggregateOutputType | null
    _max: VisionAnalysisCacheMaxAggregateOutputType | null
  }

  export type VisionAnalysisCacheAvgAggregateOutputType = {
    qualityScore: number | null
    hitCount: number | null
  }

  export type VisionAnalysisCacheSumAggregateOutputType = {
    qualityScore: number | null
    hitCount: number | null
  }

  export type VisionAnalysisCacheMinAggregateOutputType = {
    id: string | null
    screenshotId: string | null
    analysisType: string | null
    qualityScore: number | null
    createdAt: Date | null
    expiresAt: Date | null
    hitCount: number | null
  }

  export type VisionAnalysisCacheMaxAggregateOutputType = {
    id: string | null
    screenshotId: string | null
    analysisType: string | null
    qualityScore: number | null
    createdAt: Date | null
    expiresAt: Date | null
    hitCount: number | null
  }

  export type VisionAnalysisCacheCountAggregateOutputType = {
    id: number
    screenshotId: number
    analysisType: number
    analysisResult: number
    qualityScore: number
    createdAt: number
    expiresAt: number
    hitCount: number
    _all: number
  }


  export type VisionAnalysisCacheAvgAggregateInputType = {
    qualityScore?: true
    hitCount?: true
  }

  export type VisionAnalysisCacheSumAggregateInputType = {
    qualityScore?: true
    hitCount?: true
  }

  export type VisionAnalysisCacheMinAggregateInputType = {
    id?: true
    screenshotId?: true
    analysisType?: true
    qualityScore?: true
    createdAt?: true
    expiresAt?: true
    hitCount?: true
  }

  export type VisionAnalysisCacheMaxAggregateInputType = {
    id?: true
    screenshotId?: true
    analysisType?: true
    qualityScore?: true
    createdAt?: true
    expiresAt?: true
    hitCount?: true
  }

  export type VisionAnalysisCacheCountAggregateInputType = {
    id?: true
    screenshotId?: true
    analysisType?: true
    analysisResult?: true
    qualityScore?: true
    createdAt?: true
    expiresAt?: true
    hitCount?: true
    _all?: true
  }

  export type VisionAnalysisCacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisionAnalysisCache to aggregate.
     */
    where?: VisionAnalysisCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisionAnalysisCaches to fetch.
     */
    orderBy?: VisionAnalysisCacheOrderByWithRelationInput | VisionAnalysisCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisionAnalysisCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisionAnalysisCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisionAnalysisCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisionAnalysisCaches
    **/
    _count?: true | VisionAnalysisCacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisionAnalysisCacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisionAnalysisCacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisionAnalysisCacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisionAnalysisCacheMaxAggregateInputType
  }

  export type GetVisionAnalysisCacheAggregateType<T extends VisionAnalysisCacheAggregateArgs> = {
        [P in keyof T & keyof AggregateVisionAnalysisCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisionAnalysisCache[P]>
      : GetScalarType<T[P], AggregateVisionAnalysisCache[P]>
  }




  export type VisionAnalysisCacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisionAnalysisCacheWhereInput
    orderBy?: VisionAnalysisCacheOrderByWithAggregationInput | VisionAnalysisCacheOrderByWithAggregationInput[]
    by: VisionAnalysisCacheScalarFieldEnum[] | VisionAnalysisCacheScalarFieldEnum
    having?: VisionAnalysisCacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisionAnalysisCacheCountAggregateInputType | true
    _avg?: VisionAnalysisCacheAvgAggregateInputType
    _sum?: VisionAnalysisCacheSumAggregateInputType
    _min?: VisionAnalysisCacheMinAggregateInputType
    _max?: VisionAnalysisCacheMaxAggregateInputType
  }

  export type VisionAnalysisCacheGroupByOutputType = {
    id: string
    screenshotId: string
    analysisType: string
    analysisResult: JsonValue
    qualityScore: number
    createdAt: Date
    expiresAt: Date
    hitCount: number
    _count: VisionAnalysisCacheCountAggregateOutputType | null
    _avg: VisionAnalysisCacheAvgAggregateOutputType | null
    _sum: VisionAnalysisCacheSumAggregateOutputType | null
    _min: VisionAnalysisCacheMinAggregateOutputType | null
    _max: VisionAnalysisCacheMaxAggregateOutputType | null
  }

  type GetVisionAnalysisCacheGroupByPayload<T extends VisionAnalysisCacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisionAnalysisCacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisionAnalysisCacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisionAnalysisCacheGroupByOutputType[P]>
            : GetScalarType<T[P], VisionAnalysisCacheGroupByOutputType[P]>
        }
      >
    >


  export type VisionAnalysisCacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    screenshotId?: boolean
    analysisType?: boolean
    analysisResult?: boolean
    qualityScore?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    hitCount?: boolean
  }, ExtArgs["result"]["visionAnalysisCache"]>

  export type VisionAnalysisCacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    screenshotId?: boolean
    analysisType?: boolean
    analysisResult?: boolean
    qualityScore?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    hitCount?: boolean
  }, ExtArgs["result"]["visionAnalysisCache"]>

  export type VisionAnalysisCacheSelectScalar = {
    id?: boolean
    screenshotId?: boolean
    analysisType?: boolean
    analysisResult?: boolean
    qualityScore?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    hitCount?: boolean
  }


  export type $VisionAnalysisCachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisionAnalysisCache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      screenshotId: string
      analysisType: string
      analysisResult: Prisma.JsonValue
      qualityScore: number
      createdAt: Date
      expiresAt: Date
      hitCount: number
    }, ExtArgs["result"]["visionAnalysisCache"]>
    composites: {}
  }

  type VisionAnalysisCacheGetPayload<S extends boolean | null | undefined | VisionAnalysisCacheDefaultArgs> = $Result.GetResult<Prisma.$VisionAnalysisCachePayload, S>

  type VisionAnalysisCacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisionAnalysisCacheFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisionAnalysisCacheCountAggregateInputType | true
    }

  export interface VisionAnalysisCacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisionAnalysisCache'], meta: { name: 'VisionAnalysisCache' } }
    /**
     * Find zero or one VisionAnalysisCache that matches the filter.
     * @param {VisionAnalysisCacheFindUniqueArgs} args - Arguments to find a VisionAnalysisCache
     * @example
     * // Get one VisionAnalysisCache
     * const visionAnalysisCache = await prisma.visionAnalysisCache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisionAnalysisCacheFindUniqueArgs>(args: SelectSubset<T, VisionAnalysisCacheFindUniqueArgs<ExtArgs>>): Prisma__VisionAnalysisCacheClient<$Result.GetResult<Prisma.$VisionAnalysisCachePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisionAnalysisCache that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisionAnalysisCacheFindUniqueOrThrowArgs} args - Arguments to find a VisionAnalysisCache
     * @example
     * // Get one VisionAnalysisCache
     * const visionAnalysisCache = await prisma.visionAnalysisCache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisionAnalysisCacheFindUniqueOrThrowArgs>(args: SelectSubset<T, VisionAnalysisCacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisionAnalysisCacheClient<$Result.GetResult<Prisma.$VisionAnalysisCachePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisionAnalysisCache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionAnalysisCacheFindFirstArgs} args - Arguments to find a VisionAnalysisCache
     * @example
     * // Get one VisionAnalysisCache
     * const visionAnalysisCache = await prisma.visionAnalysisCache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisionAnalysisCacheFindFirstArgs>(args?: SelectSubset<T, VisionAnalysisCacheFindFirstArgs<ExtArgs>>): Prisma__VisionAnalysisCacheClient<$Result.GetResult<Prisma.$VisionAnalysisCachePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisionAnalysisCache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionAnalysisCacheFindFirstOrThrowArgs} args - Arguments to find a VisionAnalysisCache
     * @example
     * // Get one VisionAnalysisCache
     * const visionAnalysisCache = await prisma.visionAnalysisCache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisionAnalysisCacheFindFirstOrThrowArgs>(args?: SelectSubset<T, VisionAnalysisCacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisionAnalysisCacheClient<$Result.GetResult<Prisma.$VisionAnalysisCachePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisionAnalysisCaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionAnalysisCacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisionAnalysisCaches
     * const visionAnalysisCaches = await prisma.visionAnalysisCache.findMany()
     * 
     * // Get first 10 VisionAnalysisCaches
     * const visionAnalysisCaches = await prisma.visionAnalysisCache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visionAnalysisCacheWithIdOnly = await prisma.visionAnalysisCache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisionAnalysisCacheFindManyArgs>(args?: SelectSubset<T, VisionAnalysisCacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisionAnalysisCachePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisionAnalysisCache.
     * @param {VisionAnalysisCacheCreateArgs} args - Arguments to create a VisionAnalysisCache.
     * @example
     * // Create one VisionAnalysisCache
     * const VisionAnalysisCache = await prisma.visionAnalysisCache.create({
     *   data: {
     *     // ... data to create a VisionAnalysisCache
     *   }
     * })
     * 
     */
    create<T extends VisionAnalysisCacheCreateArgs>(args: SelectSubset<T, VisionAnalysisCacheCreateArgs<ExtArgs>>): Prisma__VisionAnalysisCacheClient<$Result.GetResult<Prisma.$VisionAnalysisCachePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisionAnalysisCaches.
     * @param {VisionAnalysisCacheCreateManyArgs} args - Arguments to create many VisionAnalysisCaches.
     * @example
     * // Create many VisionAnalysisCaches
     * const visionAnalysisCache = await prisma.visionAnalysisCache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisionAnalysisCacheCreateManyArgs>(args?: SelectSubset<T, VisionAnalysisCacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VisionAnalysisCaches and returns the data saved in the database.
     * @param {VisionAnalysisCacheCreateManyAndReturnArgs} args - Arguments to create many VisionAnalysisCaches.
     * @example
     * // Create many VisionAnalysisCaches
     * const visionAnalysisCache = await prisma.visionAnalysisCache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VisionAnalysisCaches and only return the `id`
     * const visionAnalysisCacheWithIdOnly = await prisma.visionAnalysisCache.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VisionAnalysisCacheCreateManyAndReturnArgs>(args?: SelectSubset<T, VisionAnalysisCacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisionAnalysisCachePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VisionAnalysisCache.
     * @param {VisionAnalysisCacheDeleteArgs} args - Arguments to delete one VisionAnalysisCache.
     * @example
     * // Delete one VisionAnalysisCache
     * const VisionAnalysisCache = await prisma.visionAnalysisCache.delete({
     *   where: {
     *     // ... filter to delete one VisionAnalysisCache
     *   }
     * })
     * 
     */
    delete<T extends VisionAnalysisCacheDeleteArgs>(args: SelectSubset<T, VisionAnalysisCacheDeleteArgs<ExtArgs>>): Prisma__VisionAnalysisCacheClient<$Result.GetResult<Prisma.$VisionAnalysisCachePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisionAnalysisCache.
     * @param {VisionAnalysisCacheUpdateArgs} args - Arguments to update one VisionAnalysisCache.
     * @example
     * // Update one VisionAnalysisCache
     * const visionAnalysisCache = await prisma.visionAnalysisCache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisionAnalysisCacheUpdateArgs>(args: SelectSubset<T, VisionAnalysisCacheUpdateArgs<ExtArgs>>): Prisma__VisionAnalysisCacheClient<$Result.GetResult<Prisma.$VisionAnalysisCachePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisionAnalysisCaches.
     * @param {VisionAnalysisCacheDeleteManyArgs} args - Arguments to filter VisionAnalysisCaches to delete.
     * @example
     * // Delete a few VisionAnalysisCaches
     * const { count } = await prisma.visionAnalysisCache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisionAnalysisCacheDeleteManyArgs>(args?: SelectSubset<T, VisionAnalysisCacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisionAnalysisCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionAnalysisCacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisionAnalysisCaches
     * const visionAnalysisCache = await prisma.visionAnalysisCache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisionAnalysisCacheUpdateManyArgs>(args: SelectSubset<T, VisionAnalysisCacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisionAnalysisCache.
     * @param {VisionAnalysisCacheUpsertArgs} args - Arguments to update or create a VisionAnalysisCache.
     * @example
     * // Update or create a VisionAnalysisCache
     * const visionAnalysisCache = await prisma.visionAnalysisCache.upsert({
     *   create: {
     *     // ... data to create a VisionAnalysisCache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisionAnalysisCache we want to update
     *   }
     * })
     */
    upsert<T extends VisionAnalysisCacheUpsertArgs>(args: SelectSubset<T, VisionAnalysisCacheUpsertArgs<ExtArgs>>): Prisma__VisionAnalysisCacheClient<$Result.GetResult<Prisma.$VisionAnalysisCachePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisionAnalysisCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionAnalysisCacheCountArgs} args - Arguments to filter VisionAnalysisCaches to count.
     * @example
     * // Count the number of VisionAnalysisCaches
     * const count = await prisma.visionAnalysisCache.count({
     *   where: {
     *     // ... the filter for the VisionAnalysisCaches we want to count
     *   }
     * })
    **/
    count<T extends VisionAnalysisCacheCountArgs>(
      args?: Subset<T, VisionAnalysisCacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisionAnalysisCacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisionAnalysisCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionAnalysisCacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisionAnalysisCacheAggregateArgs>(args: Subset<T, VisionAnalysisCacheAggregateArgs>): Prisma.PrismaPromise<GetVisionAnalysisCacheAggregateType<T>>

    /**
     * Group by VisionAnalysisCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisionAnalysisCacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisionAnalysisCacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisionAnalysisCacheGroupByArgs['orderBy'] }
        : { orderBy?: VisionAnalysisCacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisionAnalysisCacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisionAnalysisCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisionAnalysisCache model
   */
  readonly fields: VisionAnalysisCacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisionAnalysisCache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisionAnalysisCacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisionAnalysisCache model
   */ 
  interface VisionAnalysisCacheFieldRefs {
    readonly id: FieldRef<"VisionAnalysisCache", 'String'>
    readonly screenshotId: FieldRef<"VisionAnalysisCache", 'String'>
    readonly analysisType: FieldRef<"VisionAnalysisCache", 'String'>
    readonly analysisResult: FieldRef<"VisionAnalysisCache", 'Json'>
    readonly qualityScore: FieldRef<"VisionAnalysisCache", 'Float'>
    readonly createdAt: FieldRef<"VisionAnalysisCache", 'DateTime'>
    readonly expiresAt: FieldRef<"VisionAnalysisCache", 'DateTime'>
    readonly hitCount: FieldRef<"VisionAnalysisCache", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VisionAnalysisCache findUnique
   */
  export type VisionAnalysisCacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelect<ExtArgs> | null
    /**
     * Filter, which VisionAnalysisCache to fetch.
     */
    where: VisionAnalysisCacheWhereUniqueInput
  }

  /**
   * VisionAnalysisCache findUniqueOrThrow
   */
  export type VisionAnalysisCacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelect<ExtArgs> | null
    /**
     * Filter, which VisionAnalysisCache to fetch.
     */
    where: VisionAnalysisCacheWhereUniqueInput
  }

  /**
   * VisionAnalysisCache findFirst
   */
  export type VisionAnalysisCacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelect<ExtArgs> | null
    /**
     * Filter, which VisionAnalysisCache to fetch.
     */
    where?: VisionAnalysisCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisionAnalysisCaches to fetch.
     */
    orderBy?: VisionAnalysisCacheOrderByWithRelationInput | VisionAnalysisCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisionAnalysisCaches.
     */
    cursor?: VisionAnalysisCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisionAnalysisCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisionAnalysisCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisionAnalysisCaches.
     */
    distinct?: VisionAnalysisCacheScalarFieldEnum | VisionAnalysisCacheScalarFieldEnum[]
  }

  /**
   * VisionAnalysisCache findFirstOrThrow
   */
  export type VisionAnalysisCacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelect<ExtArgs> | null
    /**
     * Filter, which VisionAnalysisCache to fetch.
     */
    where?: VisionAnalysisCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisionAnalysisCaches to fetch.
     */
    orderBy?: VisionAnalysisCacheOrderByWithRelationInput | VisionAnalysisCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisionAnalysisCaches.
     */
    cursor?: VisionAnalysisCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisionAnalysisCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisionAnalysisCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisionAnalysisCaches.
     */
    distinct?: VisionAnalysisCacheScalarFieldEnum | VisionAnalysisCacheScalarFieldEnum[]
  }

  /**
   * VisionAnalysisCache findMany
   */
  export type VisionAnalysisCacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelect<ExtArgs> | null
    /**
     * Filter, which VisionAnalysisCaches to fetch.
     */
    where?: VisionAnalysisCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisionAnalysisCaches to fetch.
     */
    orderBy?: VisionAnalysisCacheOrderByWithRelationInput | VisionAnalysisCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisionAnalysisCaches.
     */
    cursor?: VisionAnalysisCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisionAnalysisCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisionAnalysisCaches.
     */
    skip?: number
    distinct?: VisionAnalysisCacheScalarFieldEnum | VisionAnalysisCacheScalarFieldEnum[]
  }

  /**
   * VisionAnalysisCache create
   */
  export type VisionAnalysisCacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelect<ExtArgs> | null
    /**
     * The data needed to create a VisionAnalysisCache.
     */
    data: XOR<VisionAnalysisCacheCreateInput, VisionAnalysisCacheUncheckedCreateInput>
  }

  /**
   * VisionAnalysisCache createMany
   */
  export type VisionAnalysisCacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisionAnalysisCaches.
     */
    data: VisionAnalysisCacheCreateManyInput | VisionAnalysisCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisionAnalysisCache createManyAndReturn
   */
  export type VisionAnalysisCacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VisionAnalysisCaches.
     */
    data: VisionAnalysisCacheCreateManyInput | VisionAnalysisCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisionAnalysisCache update
   */
  export type VisionAnalysisCacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelect<ExtArgs> | null
    /**
     * The data needed to update a VisionAnalysisCache.
     */
    data: XOR<VisionAnalysisCacheUpdateInput, VisionAnalysisCacheUncheckedUpdateInput>
    /**
     * Choose, which VisionAnalysisCache to update.
     */
    where: VisionAnalysisCacheWhereUniqueInput
  }

  /**
   * VisionAnalysisCache updateMany
   */
  export type VisionAnalysisCacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisionAnalysisCaches.
     */
    data: XOR<VisionAnalysisCacheUpdateManyMutationInput, VisionAnalysisCacheUncheckedUpdateManyInput>
    /**
     * Filter which VisionAnalysisCaches to update
     */
    where?: VisionAnalysisCacheWhereInput
  }

  /**
   * VisionAnalysisCache upsert
   */
  export type VisionAnalysisCacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelect<ExtArgs> | null
    /**
     * The filter to search for the VisionAnalysisCache to update in case it exists.
     */
    where: VisionAnalysisCacheWhereUniqueInput
    /**
     * In case the VisionAnalysisCache found by the `where` argument doesn't exist, create a new VisionAnalysisCache with this data.
     */
    create: XOR<VisionAnalysisCacheCreateInput, VisionAnalysisCacheUncheckedCreateInput>
    /**
     * In case the VisionAnalysisCache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisionAnalysisCacheUpdateInput, VisionAnalysisCacheUncheckedUpdateInput>
  }

  /**
   * VisionAnalysisCache delete
   */
  export type VisionAnalysisCacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelect<ExtArgs> | null
    /**
     * Filter which VisionAnalysisCache to delete.
     */
    where: VisionAnalysisCacheWhereUniqueInput
  }

  /**
   * VisionAnalysisCache deleteMany
   */
  export type VisionAnalysisCacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisionAnalysisCaches to delete
     */
    where?: VisionAnalysisCacheWhereInput
  }

  /**
   * VisionAnalysisCache without action
   */
  export type VisionAnalysisCacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisionAnalysisCache
     */
    select?: VisionAnalysisCacheSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UnifiedSessionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    archiveUrl: 'archiveUrl',
    trainingFileId: 'trainingFileId',
    modelId: 'modelId',
    qualityScore: 'qualityScore',
    completeness: 'completeness',
    reliability: 'reliability',
    trainingValue: 'trainingValue',
    processingStatus: 'processingStatus',
    processingSteps: 'processingSteps',
    processingErrors: 'processingErrors',
    config: 'config',
    workerId: 'workerId',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    trainingMetrics: 'trainingMetrics',
    modelPerformance: 'modelPerformance',
    dominantPersonality: 'dominantPersonality',
    emotionalState: 'emotionalState',
    decisionMakingStyle: 'decisionMakingStyle',
    trustLevel: 'trustLevel',
    urgencyLevel: 'urgencyLevel',
    priceSensitivity: 'priceSensitivity',
    socialInfluence: 'socialInfluence',
    psychologyConfidence: 'psychologyConfidence',
    pageType: 'pageType',
    userIntent: 'userIntent',
    shoppingStage: 'shoppingStage',
    behaviorType: 'behaviorType',
    purchaseReadiness: 'purchaseReadiness',
    navigationEfficiency: 'navigationEfficiency',
    contextualInsights: 'contextualInsights',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnifiedSessionScalarFieldEnum = (typeof UnifiedSessionScalarFieldEnum)[keyof typeof UnifiedSessionScalarFieldEnum]


  export const InteractionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    type: 'type',
    timestamp: 'timestamp',
    sessionTime: 'sessionTime',
    primarySelector: 'primarySelector',
    selectorAlternatives: 'selectorAlternatives',
    xpath: 'xpath',
    cssPath: 'cssPath',
    elementTag: 'elementTag',
    elementText: 'elementText',
    elementValue: 'elementValue',
    elementAttributes: 'elementAttributes',
    clientX: 'clientX',
    clientY: 'clientY',
    pageX: 'pageX',
    pageY: 'pageY',
    boundingBox: 'boundingBox',
    viewport: 'viewport',
    isInViewport: 'isInViewport',
    percentVisible: 'percentVisible',
    url: 'url',
    pageTitle: 'pageTitle',
    pageStructure: 'pageStructure',
    parentElements: 'parentElements',
    siblingElements: 'siblingElements',
    nearbyElements: 'nearbyElements',
    stateBefore: 'stateBefore',
    stateAfter: 'stateAfter',
    stateChanges: 'stateChanges',
    confidence: 'confidence',
    selectorReliability: 'selectorReliability',
    userIntent: 'userIntent',
    userReasoning: 'userReasoning',
    visualCues: 'visualCues'
  };

  export type InteractionScalarFieldEnum = (typeof InteractionScalarFieldEnum)[keyof typeof InteractionScalarFieldEnum]


  export const ScreenshotScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    interactionId: 'interactionId',
    timestamp: 'timestamp',
    eventType: 'eventType',
    s3Key: 's3Key',
    dataUrl: 'dataUrl',
    compressed: 'compressed',
    format: 'format',
    fileSize: 'fileSize',
    viewport: 'viewport',
    quality: 'quality',
    visionAnalysis: 'visionAnalysis',
    userPsychology: 'userPsychology'
  };

  export type ScreenshotScalarFieldEnum = (typeof ScreenshotScalarFieldEnum)[keyof typeof ScreenshotScalarFieldEnum]


  export const SessionArchiveScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    version: 'version',
    format: 'format',
    s3Bucket: 's3Bucket',
    s3Key: 's3Key',
    fileSize: 'fileSize',
    checksum: 'checksum',
    manifest: 'manifest',
    compressionRatio: 'compressionRatio',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type SessionArchiveScalarFieldEnum = (typeof SessionArchiveScalarFieldEnum)[keyof typeof SessionArchiveScalarFieldEnum]


  export const TrainingDataScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    openaiFileId: 'openaiFileId',
    jsonlData: 'jsonlData',
    fileSize: 'fileSize',
    trainingJobId: 'trainingJobId',
    modelId: 'modelId',
    hyperparameters: 'hyperparameters',
    trainingConfig: 'trainingConfig',
    trainingMetrics: 'trainingMetrics',
    validationResults: 'validationResults',
    trainingQuality: 'trainingQuality',
    expectedPerformance: 'expectedPerformance',
    status: 'status',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type TrainingDataScalarFieldEnum = (typeof TrainingDataScalarFieldEnum)[keyof typeof TrainingDataScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const QualityReportScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    overallScore: 'overallScore',
    completenessScore: 'completenessScore',
    reliabilityScore: 'reliabilityScore',
    accuracyScore: 'accuracyScore',
    validationResults: 'validationResults',
    issues: 'issues',
    recommendations: 'recommendations',
    generatedAt: 'generatedAt',
    version: 'version'
  };

  export type QualityReportScalarFieldEnum = (typeof QualityReportScalarFieldEnum)[keyof typeof QualityReportScalarFieldEnum]


  export const PsychologyProfileScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    dominantPersonality: 'dominantPersonality',
    emotionalState: 'emotionalState',
    decisionMakingStyle: 'decisionMakingStyle',
    trustLevel: 'trustLevel',
    urgencyLevel: 'urgencyLevel',
    priceSensitivity: 'priceSensitivity',
    socialInfluence: 'socialInfluence',
    insights: 'insights',
    behaviorPredictions: 'behaviorPredictions',
    recommendations: 'recommendations',
    confidence: 'confidence',
    processingTimestamp: 'processingTimestamp'
  };

  export type PsychologyProfileScalarFieldEnum = (typeof PsychologyProfileScalarFieldEnum)[keyof typeof PsychologyProfileScalarFieldEnum]


  export const ContextEnhancementScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    pageStructure: 'pageStructure',
    userIntent: 'userIntent',
    navigationPattern: 'navigationPattern',
    shoppingBehavior: 'shoppingBehavior',
    contextualInsights: 'contextualInsights',
    trainingValue: 'trainingValue',
    processingTimestamp: 'processingTimestamp'
  };

  export type ContextEnhancementScalarFieldEnum = (typeof ContextEnhancementScalarFieldEnum)[keyof typeof ContextEnhancementScalarFieldEnum]


  export const VisionAnalysisCacheScalarFieldEnum: {
    id: 'id',
    screenshotId: 'screenshotId',
    analysisType: 'analysisType',
    analysisResult: 'analysisResult',
    qualityScore: 'qualityScore',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    hitCount: 'hitCount'
  };

  export type VisionAnalysisCacheScalarFieldEnum = (typeof VisionAnalysisCacheScalarFieldEnum)[keyof typeof VisionAnalysisCacheScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'SessionType'
   */
  export type EnumSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionType'>
    


  /**
   * Reference to a field of type 'SessionType[]'
   */
  export type ListEnumSessionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionType[]'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ProcessingStatus'
   */
  export type EnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus'>
    


  /**
   * Reference to a field of type 'ProcessingStatus[]'
   */
  export type ListEnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'PersonalityType'
   */
  export type EnumPersonalityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonalityType'>
    


  /**
   * Reference to a field of type 'PersonalityType[]'
   */
  export type ListEnumPersonalityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonalityType[]'>
    


  /**
   * Reference to a field of type 'EmotionalState'
   */
  export type EnumEmotionalStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmotionalState'>
    


  /**
   * Reference to a field of type 'EmotionalState[]'
   */
  export type ListEnumEmotionalStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmotionalState[]'>
    


  /**
   * Reference to a field of type 'DecisionMakingStyle'
   */
  export type EnumDecisionMakingStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DecisionMakingStyle'>
    


  /**
   * Reference to a field of type 'DecisionMakingStyle[]'
   */
  export type ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DecisionMakingStyle[]'>
    


  /**
   * Reference to a field of type 'InteractionType'
   */
  export type EnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType'>
    


  /**
   * Reference to a field of type 'InteractionType[]'
   */
  export type ListEnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ArchiveStatus'
   */
  export type EnumArchiveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArchiveStatus'>
    


  /**
   * Reference to a field of type 'ArchiveStatus[]'
   */
  export type ListEnumArchiveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArchiveStatus[]'>
    


  /**
   * Reference to a field of type 'TrainingStatus'
   */
  export type EnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus'>
    


  /**
   * Reference to a field of type 'TrainingStatus[]'
   */
  export type ListEnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UnifiedSessionWhereInput = {
    AND?: UnifiedSessionWhereInput | UnifiedSessionWhereInput[]
    OR?: UnifiedSessionWhereInput[]
    NOT?: UnifiedSessionWhereInput | UnifiedSessionWhereInput[]
    id?: StringFilter<"UnifiedSession"> | string
    type?: EnumSessionTypeFilter<"UnifiedSession"> | $Enums.SessionType
    status?: EnumSessionStatusFilter<"UnifiedSession"> | $Enums.SessionStatus
    startTime?: DateTimeFilter<"UnifiedSession"> | Date | string
    endTime?: DateTimeNullableFilter<"UnifiedSession"> | Date | string | null
    duration?: IntNullableFilter<"UnifiedSession"> | number | null
    archiveUrl?: StringNullableFilter<"UnifiedSession"> | string | null
    trainingFileId?: StringNullableFilter<"UnifiedSession"> | string | null
    modelId?: StringNullableFilter<"UnifiedSession"> | string | null
    qualityScore?: FloatFilter<"UnifiedSession"> | number
    completeness?: FloatFilter<"UnifiedSession"> | number
    reliability?: FloatFilter<"UnifiedSession"> | number
    trainingValue?: FloatFilter<"UnifiedSession"> | number
    processingStatus?: EnumProcessingStatusFilter<"UnifiedSession"> | $Enums.ProcessingStatus
    processingSteps?: JsonFilter<"UnifiedSession">
    processingErrors?: JsonFilter<"UnifiedSession">
    config?: JsonFilter<"UnifiedSession">
    workerId?: StringNullableFilter<"UnifiedSession"> | string | null
    userAgent?: StringNullableFilter<"UnifiedSession"> | string | null
    ipAddress?: StringNullableFilter<"UnifiedSession"> | string | null
    trainingMetrics?: JsonNullableFilter<"UnifiedSession">
    modelPerformance?: JsonNullableFilter<"UnifiedSession">
    dominantPersonality?: EnumPersonalityTypeNullableFilter<"UnifiedSession"> | $Enums.PersonalityType | null
    emotionalState?: EnumEmotionalStateNullableFilter<"UnifiedSession"> | $Enums.EmotionalState | null
    decisionMakingStyle?: EnumDecisionMakingStyleNullableFilter<"UnifiedSession"> | $Enums.DecisionMakingStyle | null
    trustLevel?: FloatNullableFilter<"UnifiedSession"> | number | null
    urgencyLevel?: FloatNullableFilter<"UnifiedSession"> | number | null
    priceSensitivity?: FloatNullableFilter<"UnifiedSession"> | number | null
    socialInfluence?: FloatNullableFilter<"UnifiedSession"> | number | null
    psychologyConfidence?: FloatNullableFilter<"UnifiedSession"> | number | null
    pageType?: StringNullableFilter<"UnifiedSession"> | string | null
    userIntent?: StringNullableFilter<"UnifiedSession"> | string | null
    shoppingStage?: StringNullableFilter<"UnifiedSession"> | string | null
    behaviorType?: StringNullableFilter<"UnifiedSession"> | string | null
    purchaseReadiness?: FloatNullableFilter<"UnifiedSession"> | number | null
    navigationEfficiency?: FloatNullableFilter<"UnifiedSession"> | number | null
    contextualInsights?: JsonNullableFilter<"UnifiedSession">
    createdAt?: DateTimeFilter<"UnifiedSession"> | Date | string
    updatedAt?: DateTimeFilter<"UnifiedSession"> | Date | string
    interactions?: InteractionListRelationFilter
    screenshots?: ScreenshotListRelationFilter
    archives?: SessionArchiveListRelationFilter
  }

  export type UnifiedSessionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    archiveUrl?: SortOrderInput | SortOrder
    trainingFileId?: SortOrderInput | SortOrder
    modelId?: SortOrderInput | SortOrder
    qualityScore?: SortOrder
    completeness?: SortOrder
    reliability?: SortOrder
    trainingValue?: SortOrder
    processingStatus?: SortOrder
    processingSteps?: SortOrder
    processingErrors?: SortOrder
    config?: SortOrder
    workerId?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    trainingMetrics?: SortOrderInput | SortOrder
    modelPerformance?: SortOrderInput | SortOrder
    dominantPersonality?: SortOrderInput | SortOrder
    emotionalState?: SortOrderInput | SortOrder
    decisionMakingStyle?: SortOrderInput | SortOrder
    trustLevel?: SortOrderInput | SortOrder
    urgencyLevel?: SortOrderInput | SortOrder
    priceSensitivity?: SortOrderInput | SortOrder
    socialInfluence?: SortOrderInput | SortOrder
    psychologyConfidence?: SortOrderInput | SortOrder
    pageType?: SortOrderInput | SortOrder
    userIntent?: SortOrderInput | SortOrder
    shoppingStage?: SortOrderInput | SortOrder
    behaviorType?: SortOrderInput | SortOrder
    purchaseReadiness?: SortOrderInput | SortOrder
    navigationEfficiency?: SortOrderInput | SortOrder
    contextualInsights?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interactions?: InteractionOrderByRelationAggregateInput
    screenshots?: ScreenshotOrderByRelationAggregateInput
    archives?: SessionArchiveOrderByRelationAggregateInput
  }

  export type UnifiedSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnifiedSessionWhereInput | UnifiedSessionWhereInput[]
    OR?: UnifiedSessionWhereInput[]
    NOT?: UnifiedSessionWhereInput | UnifiedSessionWhereInput[]
    type?: EnumSessionTypeFilter<"UnifiedSession"> | $Enums.SessionType
    status?: EnumSessionStatusFilter<"UnifiedSession"> | $Enums.SessionStatus
    startTime?: DateTimeFilter<"UnifiedSession"> | Date | string
    endTime?: DateTimeNullableFilter<"UnifiedSession"> | Date | string | null
    duration?: IntNullableFilter<"UnifiedSession"> | number | null
    archiveUrl?: StringNullableFilter<"UnifiedSession"> | string | null
    trainingFileId?: StringNullableFilter<"UnifiedSession"> | string | null
    modelId?: StringNullableFilter<"UnifiedSession"> | string | null
    qualityScore?: FloatFilter<"UnifiedSession"> | number
    completeness?: FloatFilter<"UnifiedSession"> | number
    reliability?: FloatFilter<"UnifiedSession"> | number
    trainingValue?: FloatFilter<"UnifiedSession"> | number
    processingStatus?: EnumProcessingStatusFilter<"UnifiedSession"> | $Enums.ProcessingStatus
    processingSteps?: JsonFilter<"UnifiedSession">
    processingErrors?: JsonFilter<"UnifiedSession">
    config?: JsonFilter<"UnifiedSession">
    workerId?: StringNullableFilter<"UnifiedSession"> | string | null
    userAgent?: StringNullableFilter<"UnifiedSession"> | string | null
    ipAddress?: StringNullableFilter<"UnifiedSession"> | string | null
    trainingMetrics?: JsonNullableFilter<"UnifiedSession">
    modelPerformance?: JsonNullableFilter<"UnifiedSession">
    dominantPersonality?: EnumPersonalityTypeNullableFilter<"UnifiedSession"> | $Enums.PersonalityType | null
    emotionalState?: EnumEmotionalStateNullableFilter<"UnifiedSession"> | $Enums.EmotionalState | null
    decisionMakingStyle?: EnumDecisionMakingStyleNullableFilter<"UnifiedSession"> | $Enums.DecisionMakingStyle | null
    trustLevel?: FloatNullableFilter<"UnifiedSession"> | number | null
    urgencyLevel?: FloatNullableFilter<"UnifiedSession"> | number | null
    priceSensitivity?: FloatNullableFilter<"UnifiedSession"> | number | null
    socialInfluence?: FloatNullableFilter<"UnifiedSession"> | number | null
    psychologyConfidence?: FloatNullableFilter<"UnifiedSession"> | number | null
    pageType?: StringNullableFilter<"UnifiedSession"> | string | null
    userIntent?: StringNullableFilter<"UnifiedSession"> | string | null
    shoppingStage?: StringNullableFilter<"UnifiedSession"> | string | null
    behaviorType?: StringNullableFilter<"UnifiedSession"> | string | null
    purchaseReadiness?: FloatNullableFilter<"UnifiedSession"> | number | null
    navigationEfficiency?: FloatNullableFilter<"UnifiedSession"> | number | null
    contextualInsights?: JsonNullableFilter<"UnifiedSession">
    createdAt?: DateTimeFilter<"UnifiedSession"> | Date | string
    updatedAt?: DateTimeFilter<"UnifiedSession"> | Date | string
    interactions?: InteractionListRelationFilter
    screenshots?: ScreenshotListRelationFilter
    archives?: SessionArchiveListRelationFilter
  }, "id">

  export type UnifiedSessionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    archiveUrl?: SortOrderInput | SortOrder
    trainingFileId?: SortOrderInput | SortOrder
    modelId?: SortOrderInput | SortOrder
    qualityScore?: SortOrder
    completeness?: SortOrder
    reliability?: SortOrder
    trainingValue?: SortOrder
    processingStatus?: SortOrder
    processingSteps?: SortOrder
    processingErrors?: SortOrder
    config?: SortOrder
    workerId?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    trainingMetrics?: SortOrderInput | SortOrder
    modelPerformance?: SortOrderInput | SortOrder
    dominantPersonality?: SortOrderInput | SortOrder
    emotionalState?: SortOrderInput | SortOrder
    decisionMakingStyle?: SortOrderInput | SortOrder
    trustLevel?: SortOrderInput | SortOrder
    urgencyLevel?: SortOrderInput | SortOrder
    priceSensitivity?: SortOrderInput | SortOrder
    socialInfluence?: SortOrderInput | SortOrder
    psychologyConfidence?: SortOrderInput | SortOrder
    pageType?: SortOrderInput | SortOrder
    userIntent?: SortOrderInput | SortOrder
    shoppingStage?: SortOrderInput | SortOrder
    behaviorType?: SortOrderInput | SortOrder
    purchaseReadiness?: SortOrderInput | SortOrder
    navigationEfficiency?: SortOrderInput | SortOrder
    contextualInsights?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnifiedSessionCountOrderByAggregateInput
    _avg?: UnifiedSessionAvgOrderByAggregateInput
    _max?: UnifiedSessionMaxOrderByAggregateInput
    _min?: UnifiedSessionMinOrderByAggregateInput
    _sum?: UnifiedSessionSumOrderByAggregateInput
  }

  export type UnifiedSessionScalarWhereWithAggregatesInput = {
    AND?: UnifiedSessionScalarWhereWithAggregatesInput | UnifiedSessionScalarWhereWithAggregatesInput[]
    OR?: UnifiedSessionScalarWhereWithAggregatesInput[]
    NOT?: UnifiedSessionScalarWhereWithAggregatesInput | UnifiedSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UnifiedSession"> | string
    type?: EnumSessionTypeWithAggregatesFilter<"UnifiedSession"> | $Enums.SessionType
    status?: EnumSessionStatusWithAggregatesFilter<"UnifiedSession"> | $Enums.SessionStatus
    startTime?: DateTimeWithAggregatesFilter<"UnifiedSession"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"UnifiedSession"> | Date | string | null
    duration?: IntNullableWithAggregatesFilter<"UnifiedSession"> | number | null
    archiveUrl?: StringNullableWithAggregatesFilter<"UnifiedSession"> | string | null
    trainingFileId?: StringNullableWithAggregatesFilter<"UnifiedSession"> | string | null
    modelId?: StringNullableWithAggregatesFilter<"UnifiedSession"> | string | null
    qualityScore?: FloatWithAggregatesFilter<"UnifiedSession"> | number
    completeness?: FloatWithAggregatesFilter<"UnifiedSession"> | number
    reliability?: FloatWithAggregatesFilter<"UnifiedSession"> | number
    trainingValue?: FloatWithAggregatesFilter<"UnifiedSession"> | number
    processingStatus?: EnumProcessingStatusWithAggregatesFilter<"UnifiedSession"> | $Enums.ProcessingStatus
    processingSteps?: JsonWithAggregatesFilter<"UnifiedSession">
    processingErrors?: JsonWithAggregatesFilter<"UnifiedSession">
    config?: JsonWithAggregatesFilter<"UnifiedSession">
    workerId?: StringNullableWithAggregatesFilter<"UnifiedSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UnifiedSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UnifiedSession"> | string | null
    trainingMetrics?: JsonNullableWithAggregatesFilter<"UnifiedSession">
    modelPerformance?: JsonNullableWithAggregatesFilter<"UnifiedSession">
    dominantPersonality?: EnumPersonalityTypeNullableWithAggregatesFilter<"UnifiedSession"> | $Enums.PersonalityType | null
    emotionalState?: EnumEmotionalStateNullableWithAggregatesFilter<"UnifiedSession"> | $Enums.EmotionalState | null
    decisionMakingStyle?: EnumDecisionMakingStyleNullableWithAggregatesFilter<"UnifiedSession"> | $Enums.DecisionMakingStyle | null
    trustLevel?: FloatNullableWithAggregatesFilter<"UnifiedSession"> | number | null
    urgencyLevel?: FloatNullableWithAggregatesFilter<"UnifiedSession"> | number | null
    priceSensitivity?: FloatNullableWithAggregatesFilter<"UnifiedSession"> | number | null
    socialInfluence?: FloatNullableWithAggregatesFilter<"UnifiedSession"> | number | null
    psychologyConfidence?: FloatNullableWithAggregatesFilter<"UnifiedSession"> | number | null
    pageType?: StringNullableWithAggregatesFilter<"UnifiedSession"> | string | null
    userIntent?: StringNullableWithAggregatesFilter<"UnifiedSession"> | string | null
    shoppingStage?: StringNullableWithAggregatesFilter<"UnifiedSession"> | string | null
    behaviorType?: StringNullableWithAggregatesFilter<"UnifiedSession"> | string | null
    purchaseReadiness?: FloatNullableWithAggregatesFilter<"UnifiedSession"> | number | null
    navigationEfficiency?: FloatNullableWithAggregatesFilter<"UnifiedSession"> | number | null
    contextualInsights?: JsonNullableWithAggregatesFilter<"UnifiedSession">
    createdAt?: DateTimeWithAggregatesFilter<"UnifiedSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UnifiedSession"> | Date | string
  }

  export type InteractionWhereInput = {
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    id?: StringFilter<"Interaction"> | string
    sessionId?: StringFilter<"Interaction"> | string
    type?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    timestamp?: BigIntFilter<"Interaction"> | bigint | number
    sessionTime?: IntFilter<"Interaction"> | number
    primarySelector?: StringFilter<"Interaction"> | string
    selectorAlternatives?: JsonFilter<"Interaction">
    xpath?: StringNullableFilter<"Interaction"> | string | null
    cssPath?: StringNullableFilter<"Interaction"> | string | null
    elementTag?: StringFilter<"Interaction"> | string
    elementText?: StringNullableFilter<"Interaction"> | string | null
    elementValue?: StringNullableFilter<"Interaction"> | string | null
    elementAttributes?: JsonFilter<"Interaction">
    clientX?: IntNullableFilter<"Interaction"> | number | null
    clientY?: IntNullableFilter<"Interaction"> | number | null
    pageX?: IntNullableFilter<"Interaction"> | number | null
    pageY?: IntNullableFilter<"Interaction"> | number | null
    boundingBox?: JsonFilter<"Interaction">
    viewport?: JsonFilter<"Interaction">
    isInViewport?: BoolFilter<"Interaction"> | boolean
    percentVisible?: FloatFilter<"Interaction"> | number
    url?: StringFilter<"Interaction"> | string
    pageTitle?: StringFilter<"Interaction"> | string
    pageStructure?: JsonFilter<"Interaction">
    parentElements?: JsonFilter<"Interaction">
    siblingElements?: JsonFilter<"Interaction">
    nearbyElements?: JsonFilter<"Interaction">
    stateBefore?: JsonFilter<"Interaction">
    stateAfter?: JsonNullableFilter<"Interaction">
    stateChanges?: JsonFilter<"Interaction">
    confidence?: FloatFilter<"Interaction"> | number
    selectorReliability?: JsonFilter<"Interaction">
    userIntent?: StringNullableFilter<"Interaction"> | string | null
    userReasoning?: StringNullableFilter<"Interaction"> | string | null
    visualCues?: JsonFilter<"Interaction">
    session?: XOR<UnifiedSessionRelationFilter, UnifiedSessionWhereInput>
    relatedScreenshots?: ScreenshotListRelationFilter
  }

  export type InteractionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    sessionTime?: SortOrder
    primarySelector?: SortOrder
    selectorAlternatives?: SortOrder
    xpath?: SortOrderInput | SortOrder
    cssPath?: SortOrderInput | SortOrder
    elementTag?: SortOrder
    elementText?: SortOrderInput | SortOrder
    elementValue?: SortOrderInput | SortOrder
    elementAttributes?: SortOrder
    clientX?: SortOrderInput | SortOrder
    clientY?: SortOrderInput | SortOrder
    pageX?: SortOrderInput | SortOrder
    pageY?: SortOrderInput | SortOrder
    boundingBox?: SortOrder
    viewport?: SortOrder
    isInViewport?: SortOrder
    percentVisible?: SortOrder
    url?: SortOrder
    pageTitle?: SortOrder
    pageStructure?: SortOrder
    parentElements?: SortOrder
    siblingElements?: SortOrder
    nearbyElements?: SortOrder
    stateBefore?: SortOrder
    stateAfter?: SortOrderInput | SortOrder
    stateChanges?: SortOrder
    confidence?: SortOrder
    selectorReliability?: SortOrder
    userIntent?: SortOrderInput | SortOrder
    userReasoning?: SortOrderInput | SortOrder
    visualCues?: SortOrder
    session?: UnifiedSessionOrderByWithRelationInput
    relatedScreenshots?: ScreenshotOrderByRelationAggregateInput
  }

  export type InteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    sessionId?: StringFilter<"Interaction"> | string
    type?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    timestamp?: BigIntFilter<"Interaction"> | bigint | number
    sessionTime?: IntFilter<"Interaction"> | number
    primarySelector?: StringFilter<"Interaction"> | string
    selectorAlternatives?: JsonFilter<"Interaction">
    xpath?: StringNullableFilter<"Interaction"> | string | null
    cssPath?: StringNullableFilter<"Interaction"> | string | null
    elementTag?: StringFilter<"Interaction"> | string
    elementText?: StringNullableFilter<"Interaction"> | string | null
    elementValue?: StringNullableFilter<"Interaction"> | string | null
    elementAttributes?: JsonFilter<"Interaction">
    clientX?: IntNullableFilter<"Interaction"> | number | null
    clientY?: IntNullableFilter<"Interaction"> | number | null
    pageX?: IntNullableFilter<"Interaction"> | number | null
    pageY?: IntNullableFilter<"Interaction"> | number | null
    boundingBox?: JsonFilter<"Interaction">
    viewport?: JsonFilter<"Interaction">
    isInViewport?: BoolFilter<"Interaction"> | boolean
    percentVisible?: FloatFilter<"Interaction"> | number
    url?: StringFilter<"Interaction"> | string
    pageTitle?: StringFilter<"Interaction"> | string
    pageStructure?: JsonFilter<"Interaction">
    parentElements?: JsonFilter<"Interaction">
    siblingElements?: JsonFilter<"Interaction">
    nearbyElements?: JsonFilter<"Interaction">
    stateBefore?: JsonFilter<"Interaction">
    stateAfter?: JsonNullableFilter<"Interaction">
    stateChanges?: JsonFilter<"Interaction">
    confidence?: FloatFilter<"Interaction"> | number
    selectorReliability?: JsonFilter<"Interaction">
    userIntent?: StringNullableFilter<"Interaction"> | string | null
    userReasoning?: StringNullableFilter<"Interaction"> | string | null
    visualCues?: JsonFilter<"Interaction">
    session?: XOR<UnifiedSessionRelationFilter, UnifiedSessionWhereInput>
    relatedScreenshots?: ScreenshotListRelationFilter
  }, "id">

  export type InteractionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    sessionTime?: SortOrder
    primarySelector?: SortOrder
    selectorAlternatives?: SortOrder
    xpath?: SortOrderInput | SortOrder
    cssPath?: SortOrderInput | SortOrder
    elementTag?: SortOrder
    elementText?: SortOrderInput | SortOrder
    elementValue?: SortOrderInput | SortOrder
    elementAttributes?: SortOrder
    clientX?: SortOrderInput | SortOrder
    clientY?: SortOrderInput | SortOrder
    pageX?: SortOrderInput | SortOrder
    pageY?: SortOrderInput | SortOrder
    boundingBox?: SortOrder
    viewport?: SortOrder
    isInViewport?: SortOrder
    percentVisible?: SortOrder
    url?: SortOrder
    pageTitle?: SortOrder
    pageStructure?: SortOrder
    parentElements?: SortOrder
    siblingElements?: SortOrder
    nearbyElements?: SortOrder
    stateBefore?: SortOrder
    stateAfter?: SortOrderInput | SortOrder
    stateChanges?: SortOrder
    confidence?: SortOrder
    selectorReliability?: SortOrder
    userIntent?: SortOrderInput | SortOrder
    userReasoning?: SortOrderInput | SortOrder
    visualCues?: SortOrder
    _count?: InteractionCountOrderByAggregateInput
    _avg?: InteractionAvgOrderByAggregateInput
    _max?: InteractionMaxOrderByAggregateInput
    _min?: InteractionMinOrderByAggregateInput
    _sum?: InteractionSumOrderByAggregateInput
  }

  export type InteractionScalarWhereWithAggregatesInput = {
    AND?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    OR?: InteractionScalarWhereWithAggregatesInput[]
    NOT?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interaction"> | string
    sessionId?: StringWithAggregatesFilter<"Interaction"> | string
    type?: EnumInteractionTypeWithAggregatesFilter<"Interaction"> | $Enums.InteractionType
    timestamp?: BigIntWithAggregatesFilter<"Interaction"> | bigint | number
    sessionTime?: IntWithAggregatesFilter<"Interaction"> | number
    primarySelector?: StringWithAggregatesFilter<"Interaction"> | string
    selectorAlternatives?: JsonWithAggregatesFilter<"Interaction">
    xpath?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    cssPath?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    elementTag?: StringWithAggregatesFilter<"Interaction"> | string
    elementText?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    elementValue?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    elementAttributes?: JsonWithAggregatesFilter<"Interaction">
    clientX?: IntNullableWithAggregatesFilter<"Interaction"> | number | null
    clientY?: IntNullableWithAggregatesFilter<"Interaction"> | number | null
    pageX?: IntNullableWithAggregatesFilter<"Interaction"> | number | null
    pageY?: IntNullableWithAggregatesFilter<"Interaction"> | number | null
    boundingBox?: JsonWithAggregatesFilter<"Interaction">
    viewport?: JsonWithAggregatesFilter<"Interaction">
    isInViewport?: BoolWithAggregatesFilter<"Interaction"> | boolean
    percentVisible?: FloatWithAggregatesFilter<"Interaction"> | number
    url?: StringWithAggregatesFilter<"Interaction"> | string
    pageTitle?: StringWithAggregatesFilter<"Interaction"> | string
    pageStructure?: JsonWithAggregatesFilter<"Interaction">
    parentElements?: JsonWithAggregatesFilter<"Interaction">
    siblingElements?: JsonWithAggregatesFilter<"Interaction">
    nearbyElements?: JsonWithAggregatesFilter<"Interaction">
    stateBefore?: JsonWithAggregatesFilter<"Interaction">
    stateAfter?: JsonNullableWithAggregatesFilter<"Interaction">
    stateChanges?: JsonWithAggregatesFilter<"Interaction">
    confidence?: FloatWithAggregatesFilter<"Interaction"> | number
    selectorReliability?: JsonWithAggregatesFilter<"Interaction">
    userIntent?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    userReasoning?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    visualCues?: JsonWithAggregatesFilter<"Interaction">
  }

  export type ScreenshotWhereInput = {
    AND?: ScreenshotWhereInput | ScreenshotWhereInput[]
    OR?: ScreenshotWhereInput[]
    NOT?: ScreenshotWhereInput | ScreenshotWhereInput[]
    id?: StringFilter<"Screenshot"> | string
    sessionId?: StringFilter<"Screenshot"> | string
    interactionId?: StringNullableFilter<"Screenshot"> | string | null
    timestamp?: BigIntFilter<"Screenshot"> | bigint | number
    eventType?: StringFilter<"Screenshot"> | string
    s3Key?: StringNullableFilter<"Screenshot"> | string | null
    dataUrl?: StringNullableFilter<"Screenshot"> | string | null
    compressed?: BoolFilter<"Screenshot"> | boolean
    format?: StringFilter<"Screenshot"> | string
    fileSize?: IntNullableFilter<"Screenshot"> | number | null
    viewport?: JsonFilter<"Screenshot">
    quality?: FloatFilter<"Screenshot"> | number
    visionAnalysis?: JsonNullableFilter<"Screenshot">
    userPsychology?: JsonNullableFilter<"Screenshot">
    session?: XOR<UnifiedSessionRelationFilter, UnifiedSessionWhereInput>
    interaction?: XOR<InteractionNullableRelationFilter, InteractionWhereInput> | null
  }

  export type ScreenshotOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interactionId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    eventType?: SortOrder
    s3Key?: SortOrderInput | SortOrder
    dataUrl?: SortOrderInput | SortOrder
    compressed?: SortOrder
    format?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    viewport?: SortOrder
    quality?: SortOrder
    visionAnalysis?: SortOrderInput | SortOrder
    userPsychology?: SortOrderInput | SortOrder
    session?: UnifiedSessionOrderByWithRelationInput
    interaction?: InteractionOrderByWithRelationInput
  }

  export type ScreenshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScreenshotWhereInput | ScreenshotWhereInput[]
    OR?: ScreenshotWhereInput[]
    NOT?: ScreenshotWhereInput | ScreenshotWhereInput[]
    sessionId?: StringFilter<"Screenshot"> | string
    interactionId?: StringNullableFilter<"Screenshot"> | string | null
    timestamp?: BigIntFilter<"Screenshot"> | bigint | number
    eventType?: StringFilter<"Screenshot"> | string
    s3Key?: StringNullableFilter<"Screenshot"> | string | null
    dataUrl?: StringNullableFilter<"Screenshot"> | string | null
    compressed?: BoolFilter<"Screenshot"> | boolean
    format?: StringFilter<"Screenshot"> | string
    fileSize?: IntNullableFilter<"Screenshot"> | number | null
    viewport?: JsonFilter<"Screenshot">
    quality?: FloatFilter<"Screenshot"> | number
    visionAnalysis?: JsonNullableFilter<"Screenshot">
    userPsychology?: JsonNullableFilter<"Screenshot">
    session?: XOR<UnifiedSessionRelationFilter, UnifiedSessionWhereInput>
    interaction?: XOR<InteractionNullableRelationFilter, InteractionWhereInput> | null
  }, "id">

  export type ScreenshotOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interactionId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    eventType?: SortOrder
    s3Key?: SortOrderInput | SortOrder
    dataUrl?: SortOrderInput | SortOrder
    compressed?: SortOrder
    format?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    viewport?: SortOrder
    quality?: SortOrder
    visionAnalysis?: SortOrderInput | SortOrder
    userPsychology?: SortOrderInput | SortOrder
    _count?: ScreenshotCountOrderByAggregateInput
    _avg?: ScreenshotAvgOrderByAggregateInput
    _max?: ScreenshotMaxOrderByAggregateInput
    _min?: ScreenshotMinOrderByAggregateInput
    _sum?: ScreenshotSumOrderByAggregateInput
  }

  export type ScreenshotScalarWhereWithAggregatesInput = {
    AND?: ScreenshotScalarWhereWithAggregatesInput | ScreenshotScalarWhereWithAggregatesInput[]
    OR?: ScreenshotScalarWhereWithAggregatesInput[]
    NOT?: ScreenshotScalarWhereWithAggregatesInput | ScreenshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Screenshot"> | string
    sessionId?: StringWithAggregatesFilter<"Screenshot"> | string
    interactionId?: StringNullableWithAggregatesFilter<"Screenshot"> | string | null
    timestamp?: BigIntWithAggregatesFilter<"Screenshot"> | bigint | number
    eventType?: StringWithAggregatesFilter<"Screenshot"> | string
    s3Key?: StringNullableWithAggregatesFilter<"Screenshot"> | string | null
    dataUrl?: StringNullableWithAggregatesFilter<"Screenshot"> | string | null
    compressed?: BoolWithAggregatesFilter<"Screenshot"> | boolean
    format?: StringWithAggregatesFilter<"Screenshot"> | string
    fileSize?: IntNullableWithAggregatesFilter<"Screenshot"> | number | null
    viewport?: JsonWithAggregatesFilter<"Screenshot">
    quality?: FloatWithAggregatesFilter<"Screenshot"> | number
    visionAnalysis?: JsonNullableWithAggregatesFilter<"Screenshot">
    userPsychology?: JsonNullableWithAggregatesFilter<"Screenshot">
  }

  export type SessionArchiveWhereInput = {
    AND?: SessionArchiveWhereInput | SessionArchiveWhereInput[]
    OR?: SessionArchiveWhereInput[]
    NOT?: SessionArchiveWhereInput | SessionArchiveWhereInput[]
    id?: StringFilter<"SessionArchive"> | string
    sessionId?: StringFilter<"SessionArchive"> | string
    version?: StringFilter<"SessionArchive"> | string
    format?: StringFilter<"SessionArchive"> | string
    s3Bucket?: StringFilter<"SessionArchive"> | string
    s3Key?: StringFilter<"SessionArchive"> | string
    fileSize?: BigIntFilter<"SessionArchive"> | bigint | number
    checksum?: StringFilter<"SessionArchive"> | string
    manifest?: JsonFilter<"SessionArchive">
    compressionRatio?: FloatNullableFilter<"SessionArchive"> | number | null
    status?: EnumArchiveStatusFilter<"SessionArchive"> | $Enums.ArchiveStatus
    createdAt?: DateTimeFilter<"SessionArchive"> | Date | string
    session?: XOR<UnifiedSessionRelationFilter, UnifiedSessionWhereInput>
  }

  export type SessionArchiveOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    version?: SortOrder
    format?: SortOrder
    s3Bucket?: SortOrder
    s3Key?: SortOrder
    fileSize?: SortOrder
    checksum?: SortOrder
    manifest?: SortOrder
    compressionRatio?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    session?: UnifiedSessionOrderByWithRelationInput
  }

  export type SessionArchiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionArchiveWhereInput | SessionArchiveWhereInput[]
    OR?: SessionArchiveWhereInput[]
    NOT?: SessionArchiveWhereInput | SessionArchiveWhereInput[]
    sessionId?: StringFilter<"SessionArchive"> | string
    version?: StringFilter<"SessionArchive"> | string
    format?: StringFilter<"SessionArchive"> | string
    s3Bucket?: StringFilter<"SessionArchive"> | string
    s3Key?: StringFilter<"SessionArchive"> | string
    fileSize?: BigIntFilter<"SessionArchive"> | bigint | number
    checksum?: StringFilter<"SessionArchive"> | string
    manifest?: JsonFilter<"SessionArchive">
    compressionRatio?: FloatNullableFilter<"SessionArchive"> | number | null
    status?: EnumArchiveStatusFilter<"SessionArchive"> | $Enums.ArchiveStatus
    createdAt?: DateTimeFilter<"SessionArchive"> | Date | string
    session?: XOR<UnifiedSessionRelationFilter, UnifiedSessionWhereInput>
  }, "id">

  export type SessionArchiveOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    version?: SortOrder
    format?: SortOrder
    s3Bucket?: SortOrder
    s3Key?: SortOrder
    fileSize?: SortOrder
    checksum?: SortOrder
    manifest?: SortOrder
    compressionRatio?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: SessionArchiveCountOrderByAggregateInput
    _avg?: SessionArchiveAvgOrderByAggregateInput
    _max?: SessionArchiveMaxOrderByAggregateInput
    _min?: SessionArchiveMinOrderByAggregateInput
    _sum?: SessionArchiveSumOrderByAggregateInput
  }

  export type SessionArchiveScalarWhereWithAggregatesInput = {
    AND?: SessionArchiveScalarWhereWithAggregatesInput | SessionArchiveScalarWhereWithAggregatesInput[]
    OR?: SessionArchiveScalarWhereWithAggregatesInput[]
    NOT?: SessionArchiveScalarWhereWithAggregatesInput | SessionArchiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionArchive"> | string
    sessionId?: StringWithAggregatesFilter<"SessionArchive"> | string
    version?: StringWithAggregatesFilter<"SessionArchive"> | string
    format?: StringWithAggregatesFilter<"SessionArchive"> | string
    s3Bucket?: StringWithAggregatesFilter<"SessionArchive"> | string
    s3Key?: StringWithAggregatesFilter<"SessionArchive"> | string
    fileSize?: BigIntWithAggregatesFilter<"SessionArchive"> | bigint | number
    checksum?: StringWithAggregatesFilter<"SessionArchive"> | string
    manifest?: JsonWithAggregatesFilter<"SessionArchive">
    compressionRatio?: FloatNullableWithAggregatesFilter<"SessionArchive"> | number | null
    status?: EnumArchiveStatusWithAggregatesFilter<"SessionArchive"> | $Enums.ArchiveStatus
    createdAt?: DateTimeWithAggregatesFilter<"SessionArchive"> | Date | string
  }

  export type TrainingDataWhereInput = {
    AND?: TrainingDataWhereInput | TrainingDataWhereInput[]
    OR?: TrainingDataWhereInput[]
    NOT?: TrainingDataWhereInput | TrainingDataWhereInput[]
    id?: StringFilter<"TrainingData"> | string
    sessionId?: StringFilter<"TrainingData"> | string
    openaiFileId?: StringNullableFilter<"TrainingData"> | string | null
    jsonlData?: StringNullableFilter<"TrainingData"> | string | null
    fileSize?: IntNullableFilter<"TrainingData"> | number | null
    trainingJobId?: StringNullableFilter<"TrainingData"> | string | null
    modelId?: StringNullableFilter<"TrainingData"> | string | null
    hyperparameters?: JsonFilter<"TrainingData">
    trainingConfig?: JsonFilter<"TrainingData">
    trainingMetrics?: JsonNullableFilter<"TrainingData">
    validationResults?: JsonNullableFilter<"TrainingData">
    trainingQuality?: FloatFilter<"TrainingData"> | number
    expectedPerformance?: FloatFilter<"TrainingData"> | number
    status?: EnumTrainingStatusFilter<"TrainingData"> | $Enums.TrainingStatus
    createdAt?: DateTimeFilter<"TrainingData"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingData"> | Date | string | null
  }

  export type TrainingDataOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    openaiFileId?: SortOrderInput | SortOrder
    jsonlData?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    trainingJobId?: SortOrderInput | SortOrder
    modelId?: SortOrderInput | SortOrder
    hyperparameters?: SortOrder
    trainingConfig?: SortOrder
    trainingMetrics?: SortOrderInput | SortOrder
    validationResults?: SortOrderInput | SortOrder
    trainingQuality?: SortOrder
    expectedPerformance?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
  }

  export type TrainingDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingDataWhereInput | TrainingDataWhereInput[]
    OR?: TrainingDataWhereInput[]
    NOT?: TrainingDataWhereInput | TrainingDataWhereInput[]
    sessionId?: StringFilter<"TrainingData"> | string
    openaiFileId?: StringNullableFilter<"TrainingData"> | string | null
    jsonlData?: StringNullableFilter<"TrainingData"> | string | null
    fileSize?: IntNullableFilter<"TrainingData"> | number | null
    trainingJobId?: StringNullableFilter<"TrainingData"> | string | null
    modelId?: StringNullableFilter<"TrainingData"> | string | null
    hyperparameters?: JsonFilter<"TrainingData">
    trainingConfig?: JsonFilter<"TrainingData">
    trainingMetrics?: JsonNullableFilter<"TrainingData">
    validationResults?: JsonNullableFilter<"TrainingData">
    trainingQuality?: FloatFilter<"TrainingData"> | number
    expectedPerformance?: FloatFilter<"TrainingData"> | number
    status?: EnumTrainingStatusFilter<"TrainingData"> | $Enums.TrainingStatus
    createdAt?: DateTimeFilter<"TrainingData"> | Date | string
    completedAt?: DateTimeNullableFilter<"TrainingData"> | Date | string | null
  }, "id">

  export type TrainingDataOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    openaiFileId?: SortOrderInput | SortOrder
    jsonlData?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    trainingJobId?: SortOrderInput | SortOrder
    modelId?: SortOrderInput | SortOrder
    hyperparameters?: SortOrder
    trainingConfig?: SortOrder
    trainingMetrics?: SortOrderInput | SortOrder
    validationResults?: SortOrderInput | SortOrder
    trainingQuality?: SortOrder
    expectedPerformance?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: TrainingDataCountOrderByAggregateInput
    _avg?: TrainingDataAvgOrderByAggregateInput
    _max?: TrainingDataMaxOrderByAggregateInput
    _min?: TrainingDataMinOrderByAggregateInput
    _sum?: TrainingDataSumOrderByAggregateInput
  }

  export type TrainingDataScalarWhereWithAggregatesInput = {
    AND?: TrainingDataScalarWhereWithAggregatesInput | TrainingDataScalarWhereWithAggregatesInput[]
    OR?: TrainingDataScalarWhereWithAggregatesInput[]
    NOT?: TrainingDataScalarWhereWithAggregatesInput | TrainingDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingData"> | string
    sessionId?: StringWithAggregatesFilter<"TrainingData"> | string
    openaiFileId?: StringNullableWithAggregatesFilter<"TrainingData"> | string | null
    jsonlData?: StringNullableWithAggregatesFilter<"TrainingData"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"TrainingData"> | number | null
    trainingJobId?: StringNullableWithAggregatesFilter<"TrainingData"> | string | null
    modelId?: StringNullableWithAggregatesFilter<"TrainingData"> | string | null
    hyperparameters?: JsonWithAggregatesFilter<"TrainingData">
    trainingConfig?: JsonWithAggregatesFilter<"TrainingData">
    trainingMetrics?: JsonNullableWithAggregatesFilter<"TrainingData">
    validationResults?: JsonNullableWithAggregatesFilter<"TrainingData">
    trainingQuality?: FloatWithAggregatesFilter<"TrainingData"> | number
    expectedPerformance?: FloatWithAggregatesFilter<"TrainingData"> | number
    status?: EnumTrainingStatusWithAggregatesFilter<"TrainingData"> | $Enums.TrainingStatus
    createdAt?: DateTimeWithAggregatesFilter<"TrainingData"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"TrainingData"> | Date | string | null
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: JsonFilter<"SystemConfig">
    description?: StringNullableFilter<"SystemConfig"> | string | null
    category?: StringFilter<"SystemConfig"> | string
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: JsonFilter<"SystemConfig">
    description?: StringNullableFilter<"SystemConfig"> | string | null
    category?: StringFilter<"SystemConfig"> | string
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: JsonWithAggregatesFilter<"SystemConfig">
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    category?: StringWithAggregatesFilter<"SystemConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type QualityReportWhereInput = {
    AND?: QualityReportWhereInput | QualityReportWhereInput[]
    OR?: QualityReportWhereInput[]
    NOT?: QualityReportWhereInput | QualityReportWhereInput[]
    id?: StringFilter<"QualityReport"> | string
    sessionId?: StringFilter<"QualityReport"> | string
    overallScore?: FloatFilter<"QualityReport"> | number
    completenessScore?: FloatFilter<"QualityReport"> | number
    reliabilityScore?: FloatFilter<"QualityReport"> | number
    accuracyScore?: FloatFilter<"QualityReport"> | number
    validationResults?: JsonFilter<"QualityReport">
    issues?: JsonFilter<"QualityReport">
    recommendations?: JsonFilter<"QualityReport">
    generatedAt?: DateTimeFilter<"QualityReport"> | Date | string
    version?: StringFilter<"QualityReport"> | string
  }

  export type QualityReportOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    completenessScore?: SortOrder
    reliabilityScore?: SortOrder
    accuracyScore?: SortOrder
    validationResults?: SortOrder
    issues?: SortOrder
    recommendations?: SortOrder
    generatedAt?: SortOrder
    version?: SortOrder
  }

  export type QualityReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QualityReportWhereInput | QualityReportWhereInput[]
    OR?: QualityReportWhereInput[]
    NOT?: QualityReportWhereInput | QualityReportWhereInput[]
    sessionId?: StringFilter<"QualityReport"> | string
    overallScore?: FloatFilter<"QualityReport"> | number
    completenessScore?: FloatFilter<"QualityReport"> | number
    reliabilityScore?: FloatFilter<"QualityReport"> | number
    accuracyScore?: FloatFilter<"QualityReport"> | number
    validationResults?: JsonFilter<"QualityReport">
    issues?: JsonFilter<"QualityReport">
    recommendations?: JsonFilter<"QualityReport">
    generatedAt?: DateTimeFilter<"QualityReport"> | Date | string
    version?: StringFilter<"QualityReport"> | string
  }, "id">

  export type QualityReportOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    completenessScore?: SortOrder
    reliabilityScore?: SortOrder
    accuracyScore?: SortOrder
    validationResults?: SortOrder
    issues?: SortOrder
    recommendations?: SortOrder
    generatedAt?: SortOrder
    version?: SortOrder
    _count?: QualityReportCountOrderByAggregateInput
    _avg?: QualityReportAvgOrderByAggregateInput
    _max?: QualityReportMaxOrderByAggregateInput
    _min?: QualityReportMinOrderByAggregateInput
    _sum?: QualityReportSumOrderByAggregateInput
  }

  export type QualityReportScalarWhereWithAggregatesInput = {
    AND?: QualityReportScalarWhereWithAggregatesInput | QualityReportScalarWhereWithAggregatesInput[]
    OR?: QualityReportScalarWhereWithAggregatesInput[]
    NOT?: QualityReportScalarWhereWithAggregatesInput | QualityReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QualityReport"> | string
    sessionId?: StringWithAggregatesFilter<"QualityReport"> | string
    overallScore?: FloatWithAggregatesFilter<"QualityReport"> | number
    completenessScore?: FloatWithAggregatesFilter<"QualityReport"> | number
    reliabilityScore?: FloatWithAggregatesFilter<"QualityReport"> | number
    accuracyScore?: FloatWithAggregatesFilter<"QualityReport"> | number
    validationResults?: JsonWithAggregatesFilter<"QualityReport">
    issues?: JsonWithAggregatesFilter<"QualityReport">
    recommendations?: JsonWithAggregatesFilter<"QualityReport">
    generatedAt?: DateTimeWithAggregatesFilter<"QualityReport"> | Date | string
    version?: StringWithAggregatesFilter<"QualityReport"> | string
  }

  export type PsychologyProfileWhereInput = {
    AND?: PsychologyProfileWhereInput | PsychologyProfileWhereInput[]
    OR?: PsychologyProfileWhereInput[]
    NOT?: PsychologyProfileWhereInput | PsychologyProfileWhereInput[]
    id?: StringFilter<"PsychologyProfile"> | string
    sessionId?: StringFilter<"PsychologyProfile"> | string
    dominantPersonality?: EnumPersonalityTypeFilter<"PsychologyProfile"> | $Enums.PersonalityType
    emotionalState?: EnumEmotionalStateFilter<"PsychologyProfile"> | $Enums.EmotionalState
    decisionMakingStyle?: EnumDecisionMakingStyleFilter<"PsychologyProfile"> | $Enums.DecisionMakingStyle
    trustLevel?: FloatFilter<"PsychologyProfile"> | number
    urgencyLevel?: FloatFilter<"PsychologyProfile"> | number
    priceSensitivity?: FloatFilter<"PsychologyProfile"> | number
    socialInfluence?: FloatFilter<"PsychologyProfile"> | number
    insights?: JsonFilter<"PsychologyProfile">
    behaviorPredictions?: JsonFilter<"PsychologyProfile">
    recommendations?: JsonFilter<"PsychologyProfile">
    confidence?: FloatFilter<"PsychologyProfile"> | number
    processingTimestamp?: DateTimeFilter<"PsychologyProfile"> | Date | string
  }

  export type PsychologyProfileOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    dominantPersonality?: SortOrder
    emotionalState?: SortOrder
    decisionMakingStyle?: SortOrder
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    insights?: SortOrder
    behaviorPredictions?: SortOrder
    recommendations?: SortOrder
    confidence?: SortOrder
    processingTimestamp?: SortOrder
  }

  export type PsychologyProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: PsychologyProfileWhereInput | PsychologyProfileWhereInput[]
    OR?: PsychologyProfileWhereInput[]
    NOT?: PsychologyProfileWhereInput | PsychologyProfileWhereInput[]
    dominantPersonality?: EnumPersonalityTypeFilter<"PsychologyProfile"> | $Enums.PersonalityType
    emotionalState?: EnumEmotionalStateFilter<"PsychologyProfile"> | $Enums.EmotionalState
    decisionMakingStyle?: EnumDecisionMakingStyleFilter<"PsychologyProfile"> | $Enums.DecisionMakingStyle
    trustLevel?: FloatFilter<"PsychologyProfile"> | number
    urgencyLevel?: FloatFilter<"PsychologyProfile"> | number
    priceSensitivity?: FloatFilter<"PsychologyProfile"> | number
    socialInfluence?: FloatFilter<"PsychologyProfile"> | number
    insights?: JsonFilter<"PsychologyProfile">
    behaviorPredictions?: JsonFilter<"PsychologyProfile">
    recommendations?: JsonFilter<"PsychologyProfile">
    confidence?: FloatFilter<"PsychologyProfile"> | number
    processingTimestamp?: DateTimeFilter<"PsychologyProfile"> | Date | string
  }, "id" | "sessionId">

  export type PsychologyProfileOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    dominantPersonality?: SortOrder
    emotionalState?: SortOrder
    decisionMakingStyle?: SortOrder
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    insights?: SortOrder
    behaviorPredictions?: SortOrder
    recommendations?: SortOrder
    confidence?: SortOrder
    processingTimestamp?: SortOrder
    _count?: PsychologyProfileCountOrderByAggregateInput
    _avg?: PsychologyProfileAvgOrderByAggregateInput
    _max?: PsychologyProfileMaxOrderByAggregateInput
    _min?: PsychologyProfileMinOrderByAggregateInput
    _sum?: PsychologyProfileSumOrderByAggregateInput
  }

  export type PsychologyProfileScalarWhereWithAggregatesInput = {
    AND?: PsychologyProfileScalarWhereWithAggregatesInput | PsychologyProfileScalarWhereWithAggregatesInput[]
    OR?: PsychologyProfileScalarWhereWithAggregatesInput[]
    NOT?: PsychologyProfileScalarWhereWithAggregatesInput | PsychologyProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PsychologyProfile"> | string
    sessionId?: StringWithAggregatesFilter<"PsychologyProfile"> | string
    dominantPersonality?: EnumPersonalityTypeWithAggregatesFilter<"PsychologyProfile"> | $Enums.PersonalityType
    emotionalState?: EnumEmotionalStateWithAggregatesFilter<"PsychologyProfile"> | $Enums.EmotionalState
    decisionMakingStyle?: EnumDecisionMakingStyleWithAggregatesFilter<"PsychologyProfile"> | $Enums.DecisionMakingStyle
    trustLevel?: FloatWithAggregatesFilter<"PsychologyProfile"> | number
    urgencyLevel?: FloatWithAggregatesFilter<"PsychologyProfile"> | number
    priceSensitivity?: FloatWithAggregatesFilter<"PsychologyProfile"> | number
    socialInfluence?: FloatWithAggregatesFilter<"PsychologyProfile"> | number
    insights?: JsonWithAggregatesFilter<"PsychologyProfile">
    behaviorPredictions?: JsonWithAggregatesFilter<"PsychologyProfile">
    recommendations?: JsonWithAggregatesFilter<"PsychologyProfile">
    confidence?: FloatWithAggregatesFilter<"PsychologyProfile"> | number
    processingTimestamp?: DateTimeWithAggregatesFilter<"PsychologyProfile"> | Date | string
  }

  export type ContextEnhancementWhereInput = {
    AND?: ContextEnhancementWhereInput | ContextEnhancementWhereInput[]
    OR?: ContextEnhancementWhereInput[]
    NOT?: ContextEnhancementWhereInput | ContextEnhancementWhereInput[]
    id?: StringFilter<"ContextEnhancement"> | string
    sessionId?: StringFilter<"ContextEnhancement"> | string
    pageStructure?: JsonFilter<"ContextEnhancement">
    userIntent?: JsonFilter<"ContextEnhancement">
    navigationPattern?: JsonFilter<"ContextEnhancement">
    shoppingBehavior?: JsonFilter<"ContextEnhancement">
    contextualInsights?: JsonFilter<"ContextEnhancement">
    trainingValue?: FloatFilter<"ContextEnhancement"> | number
    processingTimestamp?: DateTimeFilter<"ContextEnhancement"> | Date | string
  }

  export type ContextEnhancementOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    pageStructure?: SortOrder
    userIntent?: SortOrder
    navigationPattern?: SortOrder
    shoppingBehavior?: SortOrder
    contextualInsights?: SortOrder
    trainingValue?: SortOrder
    processingTimestamp?: SortOrder
  }

  export type ContextEnhancementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: ContextEnhancementWhereInput | ContextEnhancementWhereInput[]
    OR?: ContextEnhancementWhereInput[]
    NOT?: ContextEnhancementWhereInput | ContextEnhancementWhereInput[]
    pageStructure?: JsonFilter<"ContextEnhancement">
    userIntent?: JsonFilter<"ContextEnhancement">
    navigationPattern?: JsonFilter<"ContextEnhancement">
    shoppingBehavior?: JsonFilter<"ContextEnhancement">
    contextualInsights?: JsonFilter<"ContextEnhancement">
    trainingValue?: FloatFilter<"ContextEnhancement"> | number
    processingTimestamp?: DateTimeFilter<"ContextEnhancement"> | Date | string
  }, "id" | "sessionId">

  export type ContextEnhancementOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    pageStructure?: SortOrder
    userIntent?: SortOrder
    navigationPattern?: SortOrder
    shoppingBehavior?: SortOrder
    contextualInsights?: SortOrder
    trainingValue?: SortOrder
    processingTimestamp?: SortOrder
    _count?: ContextEnhancementCountOrderByAggregateInput
    _avg?: ContextEnhancementAvgOrderByAggregateInput
    _max?: ContextEnhancementMaxOrderByAggregateInput
    _min?: ContextEnhancementMinOrderByAggregateInput
    _sum?: ContextEnhancementSumOrderByAggregateInput
  }

  export type ContextEnhancementScalarWhereWithAggregatesInput = {
    AND?: ContextEnhancementScalarWhereWithAggregatesInput | ContextEnhancementScalarWhereWithAggregatesInput[]
    OR?: ContextEnhancementScalarWhereWithAggregatesInput[]
    NOT?: ContextEnhancementScalarWhereWithAggregatesInput | ContextEnhancementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextEnhancement"> | string
    sessionId?: StringWithAggregatesFilter<"ContextEnhancement"> | string
    pageStructure?: JsonWithAggregatesFilter<"ContextEnhancement">
    userIntent?: JsonWithAggregatesFilter<"ContextEnhancement">
    navigationPattern?: JsonWithAggregatesFilter<"ContextEnhancement">
    shoppingBehavior?: JsonWithAggregatesFilter<"ContextEnhancement">
    contextualInsights?: JsonWithAggregatesFilter<"ContextEnhancement">
    trainingValue?: FloatWithAggregatesFilter<"ContextEnhancement"> | number
    processingTimestamp?: DateTimeWithAggregatesFilter<"ContextEnhancement"> | Date | string
  }

  export type VisionAnalysisCacheWhereInput = {
    AND?: VisionAnalysisCacheWhereInput | VisionAnalysisCacheWhereInput[]
    OR?: VisionAnalysisCacheWhereInput[]
    NOT?: VisionAnalysisCacheWhereInput | VisionAnalysisCacheWhereInput[]
    id?: StringFilter<"VisionAnalysisCache"> | string
    screenshotId?: StringFilter<"VisionAnalysisCache"> | string
    analysisType?: StringFilter<"VisionAnalysisCache"> | string
    analysisResult?: JsonFilter<"VisionAnalysisCache">
    qualityScore?: FloatFilter<"VisionAnalysisCache"> | number
    createdAt?: DateTimeFilter<"VisionAnalysisCache"> | Date | string
    expiresAt?: DateTimeFilter<"VisionAnalysisCache"> | Date | string
    hitCount?: IntFilter<"VisionAnalysisCache"> | number
  }

  export type VisionAnalysisCacheOrderByWithRelationInput = {
    id?: SortOrder
    screenshotId?: SortOrder
    analysisType?: SortOrder
    analysisResult?: SortOrder
    qualityScore?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    hitCount?: SortOrder
  }

  export type VisionAnalysisCacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    screenshotId_analysisType?: VisionAnalysisCacheScreenshotIdAnalysisTypeCompoundUniqueInput
    AND?: VisionAnalysisCacheWhereInput | VisionAnalysisCacheWhereInput[]
    OR?: VisionAnalysisCacheWhereInput[]
    NOT?: VisionAnalysisCacheWhereInput | VisionAnalysisCacheWhereInput[]
    screenshotId?: StringFilter<"VisionAnalysisCache"> | string
    analysisType?: StringFilter<"VisionAnalysisCache"> | string
    analysisResult?: JsonFilter<"VisionAnalysisCache">
    qualityScore?: FloatFilter<"VisionAnalysisCache"> | number
    createdAt?: DateTimeFilter<"VisionAnalysisCache"> | Date | string
    expiresAt?: DateTimeFilter<"VisionAnalysisCache"> | Date | string
    hitCount?: IntFilter<"VisionAnalysisCache"> | number
  }, "id" | "screenshotId_analysisType">

  export type VisionAnalysisCacheOrderByWithAggregationInput = {
    id?: SortOrder
    screenshotId?: SortOrder
    analysisType?: SortOrder
    analysisResult?: SortOrder
    qualityScore?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    hitCount?: SortOrder
    _count?: VisionAnalysisCacheCountOrderByAggregateInput
    _avg?: VisionAnalysisCacheAvgOrderByAggregateInput
    _max?: VisionAnalysisCacheMaxOrderByAggregateInput
    _min?: VisionAnalysisCacheMinOrderByAggregateInput
    _sum?: VisionAnalysisCacheSumOrderByAggregateInput
  }

  export type VisionAnalysisCacheScalarWhereWithAggregatesInput = {
    AND?: VisionAnalysisCacheScalarWhereWithAggregatesInput | VisionAnalysisCacheScalarWhereWithAggregatesInput[]
    OR?: VisionAnalysisCacheScalarWhereWithAggregatesInput[]
    NOT?: VisionAnalysisCacheScalarWhereWithAggregatesInput | VisionAnalysisCacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisionAnalysisCache"> | string
    screenshotId?: StringWithAggregatesFilter<"VisionAnalysisCache"> | string
    analysisType?: StringWithAggregatesFilter<"VisionAnalysisCache"> | string
    analysisResult?: JsonWithAggregatesFilter<"VisionAnalysisCache">
    qualityScore?: FloatWithAggregatesFilter<"VisionAnalysisCache"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VisionAnalysisCache"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"VisionAnalysisCache"> | Date | string
    hitCount?: IntWithAggregatesFilter<"VisionAnalysisCache"> | number
  }

  export type UnifiedSessionCreateInput = {
    id?: string
    type?: $Enums.SessionType
    status?: $Enums.SessionStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    archiveUrl?: string | null
    trainingFileId?: string | null
    modelId?: string | null
    qualityScore?: number
    completeness?: number
    reliability?: number
    trainingValue?: number
    processingStatus?: $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: $Enums.PersonalityType | null
    emotionalState?: $Enums.EmotionalState | null
    decisionMakingStyle?: $Enums.DecisionMakingStyle | null
    trustLevel?: number | null
    urgencyLevel?: number | null
    priceSensitivity?: number | null
    socialInfluence?: number | null
    psychologyConfidence?: number | null
    pageType?: string | null
    userIntent?: string | null
    shoppingStage?: string | null
    behaviorType?: string | null
    purchaseReadiness?: number | null
    navigationEfficiency?: number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionCreateNestedManyWithoutSessionInput
    screenshots?: ScreenshotCreateNestedManyWithoutSessionInput
    archives?: SessionArchiveCreateNestedManyWithoutSessionInput
  }

  export type UnifiedSessionUncheckedCreateInput = {
    id?: string
    type?: $Enums.SessionType
    status?: $Enums.SessionStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    archiveUrl?: string | null
    trainingFileId?: string | null
    modelId?: string | null
    qualityScore?: number
    completeness?: number
    reliability?: number
    trainingValue?: number
    processingStatus?: $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: $Enums.PersonalityType | null
    emotionalState?: $Enums.EmotionalState | null
    decisionMakingStyle?: $Enums.DecisionMakingStyle | null
    trustLevel?: number | null
    urgencyLevel?: number | null
    priceSensitivity?: number | null
    socialInfluence?: number | null
    psychologyConfidence?: number | null
    pageType?: string | null
    userIntent?: string | null
    shoppingStage?: string | null
    behaviorType?: string | null
    purchaseReadiness?: number | null
    navigationEfficiency?: number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutSessionInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutSessionInput
    archives?: SessionArchiveUncheckedCreateNestedManyWithoutSessionInput
  }

  export type UnifiedSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    archiveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trainingFileId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    reliability?: FloatFieldUpdateOperationsInput | number
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    emotionalState?: NullableEnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState | null
    decisionMakingStyle?: NullableEnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle | null
    trustLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    urgencyLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    priceSensitivity?: NullableFloatFieldUpdateOperationsInput | number | null
    socialInfluence?: NullableFloatFieldUpdateOperationsInput | number | null
    psychologyConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pageType?: NullableStringFieldUpdateOperationsInput | string | null
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingStage?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseReadiness?: NullableFloatFieldUpdateOperationsInput | number | null
    navigationEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUpdateManyWithoutSessionNestedInput
    screenshots?: ScreenshotUpdateManyWithoutSessionNestedInput
    archives?: SessionArchiveUpdateManyWithoutSessionNestedInput
  }

  export type UnifiedSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    archiveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trainingFileId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    reliability?: FloatFieldUpdateOperationsInput | number
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    emotionalState?: NullableEnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState | null
    decisionMakingStyle?: NullableEnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle | null
    trustLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    urgencyLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    priceSensitivity?: NullableFloatFieldUpdateOperationsInput | number | null
    socialInfluence?: NullableFloatFieldUpdateOperationsInput | number | null
    psychologyConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pageType?: NullableStringFieldUpdateOperationsInput | string | null
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingStage?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseReadiness?: NullableFloatFieldUpdateOperationsInput | number | null
    navigationEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutSessionNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutSessionNestedInput
    archives?: SessionArchiveUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UnifiedSessionCreateManyInput = {
    id?: string
    type?: $Enums.SessionType
    status?: $Enums.SessionStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    archiveUrl?: string | null
    trainingFileId?: string | null
    modelId?: string | null
    qualityScore?: number
    completeness?: number
    reliability?: number
    trainingValue?: number
    processingStatus?: $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: $Enums.PersonalityType | null
    emotionalState?: $Enums.EmotionalState | null
    decisionMakingStyle?: $Enums.DecisionMakingStyle | null
    trustLevel?: number | null
    urgencyLevel?: number | null
    priceSensitivity?: number | null
    socialInfluence?: number | null
    psychologyConfidence?: number | null
    pageType?: string | null
    userIntent?: string | null
    shoppingStage?: string | null
    behaviorType?: string | null
    purchaseReadiness?: number | null
    navigationEfficiency?: number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnifiedSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    archiveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trainingFileId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    reliability?: FloatFieldUpdateOperationsInput | number
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    emotionalState?: NullableEnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState | null
    decisionMakingStyle?: NullableEnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle | null
    trustLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    urgencyLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    priceSensitivity?: NullableFloatFieldUpdateOperationsInput | number | null
    socialInfluence?: NullableFloatFieldUpdateOperationsInput | number | null
    psychologyConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pageType?: NullableStringFieldUpdateOperationsInput | string | null
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingStage?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseReadiness?: NullableFloatFieldUpdateOperationsInput | number | null
    navigationEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnifiedSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    archiveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trainingFileId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    reliability?: FloatFieldUpdateOperationsInput | number
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    emotionalState?: NullableEnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState | null
    decisionMakingStyle?: NullableEnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle | null
    trustLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    urgencyLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    priceSensitivity?: NullableFloatFieldUpdateOperationsInput | number | null
    socialInfluence?: NullableFloatFieldUpdateOperationsInput | number | null
    psychologyConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pageType?: NullableStringFieldUpdateOperationsInput | string | null
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingStage?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseReadiness?: NullableFloatFieldUpdateOperationsInput | number | null
    navigationEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionCreateInput = {
    id?: string
    type: $Enums.InteractionType
    timestamp: bigint | number
    sessionTime: number
    primarySelector: string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: string | null
    cssPath?: string | null
    elementTag: string
    elementText?: string | null
    elementValue?: string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: number | null
    clientY?: number | null
    pageX?: number | null
    pageY?: number | null
    boundingBox: JsonNullValueInput | InputJsonValue
    viewport: JsonNullValueInput | InputJsonValue
    isInViewport?: boolean
    percentVisible?: number
    url: string
    pageTitle: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: string | null
    userReasoning?: string | null
    visualCues?: JsonNullValueInput | InputJsonValue
    session: UnifiedSessionCreateNestedOneWithoutInteractionsInput
    relatedScreenshots?: ScreenshotCreateNestedManyWithoutInteractionInput
  }

  export type InteractionUncheckedCreateInput = {
    id?: string
    sessionId: string
    type: $Enums.InteractionType
    timestamp: bigint | number
    sessionTime: number
    primarySelector: string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: string | null
    cssPath?: string | null
    elementTag: string
    elementText?: string | null
    elementValue?: string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: number | null
    clientY?: number | null
    pageX?: number | null
    pageY?: number | null
    boundingBox: JsonNullValueInput | InputJsonValue
    viewport: JsonNullValueInput | InputJsonValue
    isInViewport?: boolean
    percentVisible?: number
    url: string
    pageTitle: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: string | null
    userReasoning?: string | null
    visualCues?: JsonNullValueInput | InputJsonValue
    relatedScreenshots?: ScreenshotUncheckedCreateNestedManyWithoutInteractionInput
  }

  export type InteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionTime?: IntFieldUpdateOperationsInput | number
    primarySelector?: StringFieldUpdateOperationsInput | string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: NullableStringFieldUpdateOperationsInput | string | null
    cssPath?: NullableStringFieldUpdateOperationsInput | string | null
    elementTag?: StringFieldUpdateOperationsInput | string
    elementText?: NullableStringFieldUpdateOperationsInput | string | null
    elementValue?: NullableStringFieldUpdateOperationsInput | string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: NullableIntFieldUpdateOperationsInput | number | null
    clientY?: NullableIntFieldUpdateOperationsInput | number | null
    pageX?: NullableIntFieldUpdateOperationsInput | number | null
    pageY?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: JsonNullValueInput | InputJsonValue
    viewport?: JsonNullValueInput | InputJsonValue
    isInViewport?: BoolFieldUpdateOperationsInput | boolean
    percentVisible?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    pageTitle?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    userReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    visualCues?: JsonNullValueInput | InputJsonValue
    session?: UnifiedSessionUpdateOneRequiredWithoutInteractionsNestedInput
    relatedScreenshots?: ScreenshotUpdateManyWithoutInteractionNestedInput
  }

  export type InteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionTime?: IntFieldUpdateOperationsInput | number
    primarySelector?: StringFieldUpdateOperationsInput | string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: NullableStringFieldUpdateOperationsInput | string | null
    cssPath?: NullableStringFieldUpdateOperationsInput | string | null
    elementTag?: StringFieldUpdateOperationsInput | string
    elementText?: NullableStringFieldUpdateOperationsInput | string | null
    elementValue?: NullableStringFieldUpdateOperationsInput | string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: NullableIntFieldUpdateOperationsInput | number | null
    clientY?: NullableIntFieldUpdateOperationsInput | number | null
    pageX?: NullableIntFieldUpdateOperationsInput | number | null
    pageY?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: JsonNullValueInput | InputJsonValue
    viewport?: JsonNullValueInput | InputJsonValue
    isInViewport?: BoolFieldUpdateOperationsInput | boolean
    percentVisible?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    pageTitle?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    userReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    visualCues?: JsonNullValueInput | InputJsonValue
    relatedScreenshots?: ScreenshotUncheckedUpdateManyWithoutInteractionNestedInput
  }

  export type InteractionCreateManyInput = {
    id?: string
    sessionId: string
    type: $Enums.InteractionType
    timestamp: bigint | number
    sessionTime: number
    primarySelector: string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: string | null
    cssPath?: string | null
    elementTag: string
    elementText?: string | null
    elementValue?: string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: number | null
    clientY?: number | null
    pageX?: number | null
    pageY?: number | null
    boundingBox: JsonNullValueInput | InputJsonValue
    viewport: JsonNullValueInput | InputJsonValue
    isInViewport?: boolean
    percentVisible?: number
    url: string
    pageTitle: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: string | null
    userReasoning?: string | null
    visualCues?: JsonNullValueInput | InputJsonValue
  }

  export type InteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionTime?: IntFieldUpdateOperationsInput | number
    primarySelector?: StringFieldUpdateOperationsInput | string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: NullableStringFieldUpdateOperationsInput | string | null
    cssPath?: NullableStringFieldUpdateOperationsInput | string | null
    elementTag?: StringFieldUpdateOperationsInput | string
    elementText?: NullableStringFieldUpdateOperationsInput | string | null
    elementValue?: NullableStringFieldUpdateOperationsInput | string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: NullableIntFieldUpdateOperationsInput | number | null
    clientY?: NullableIntFieldUpdateOperationsInput | number | null
    pageX?: NullableIntFieldUpdateOperationsInput | number | null
    pageY?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: JsonNullValueInput | InputJsonValue
    viewport?: JsonNullValueInput | InputJsonValue
    isInViewport?: BoolFieldUpdateOperationsInput | boolean
    percentVisible?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    pageTitle?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    userReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    visualCues?: JsonNullValueInput | InputJsonValue
  }

  export type InteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionTime?: IntFieldUpdateOperationsInput | number
    primarySelector?: StringFieldUpdateOperationsInput | string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: NullableStringFieldUpdateOperationsInput | string | null
    cssPath?: NullableStringFieldUpdateOperationsInput | string | null
    elementTag?: StringFieldUpdateOperationsInput | string
    elementText?: NullableStringFieldUpdateOperationsInput | string | null
    elementValue?: NullableStringFieldUpdateOperationsInput | string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: NullableIntFieldUpdateOperationsInput | number | null
    clientY?: NullableIntFieldUpdateOperationsInput | number | null
    pageX?: NullableIntFieldUpdateOperationsInput | number | null
    pageY?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: JsonNullValueInput | InputJsonValue
    viewport?: JsonNullValueInput | InputJsonValue
    isInViewport?: BoolFieldUpdateOperationsInput | boolean
    percentVisible?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    pageTitle?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    userReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    visualCues?: JsonNullValueInput | InputJsonValue
  }

  export type ScreenshotCreateInput = {
    id?: string
    timestamp: bigint | number
    eventType: string
    s3Key?: string | null
    dataUrl?: string | null
    compressed?: boolean
    format?: string
    fileSize?: number | null
    viewport: JsonNullValueInput | InputJsonValue
    quality?: number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
    session: UnifiedSessionCreateNestedOneWithoutScreenshotsInput
    interaction?: InteractionCreateNestedOneWithoutRelatedScreenshotsInput
  }

  export type ScreenshotUncheckedCreateInput = {
    id?: string
    sessionId: string
    interactionId?: string | null
    timestamp: bigint | number
    eventType: string
    s3Key?: string | null
    dataUrl?: string | null
    compressed?: boolean
    format?: string
    fileSize?: number | null
    viewport: JsonNullValueInput | InputJsonValue
    quality?: number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScreenshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    dataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    compressed?: BoolFieldUpdateOperationsInput | boolean
    format?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    viewport?: JsonNullValueInput | InputJsonValue
    quality?: FloatFieldUpdateOperationsInput | number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
    session?: UnifiedSessionUpdateOneRequiredWithoutScreenshotsNestedInput
    interaction?: InteractionUpdateOneWithoutRelatedScreenshotsNestedInput
  }

  export type ScreenshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    dataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    compressed?: BoolFieldUpdateOperationsInput | boolean
    format?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    viewport?: JsonNullValueInput | InputJsonValue
    quality?: FloatFieldUpdateOperationsInput | number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScreenshotCreateManyInput = {
    id?: string
    sessionId: string
    interactionId?: string | null
    timestamp: bigint | number
    eventType: string
    s3Key?: string | null
    dataUrl?: string | null
    compressed?: boolean
    format?: string
    fileSize?: number | null
    viewport: JsonNullValueInput | InputJsonValue
    quality?: number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScreenshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    dataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    compressed?: BoolFieldUpdateOperationsInput | boolean
    format?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    viewport?: JsonNullValueInput | InputJsonValue
    quality?: FloatFieldUpdateOperationsInput | number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScreenshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    dataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    compressed?: BoolFieldUpdateOperationsInput | boolean
    format?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    viewport?: JsonNullValueInput | InputJsonValue
    quality?: FloatFieldUpdateOperationsInput | number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionArchiveCreateInput = {
    id?: string
    version?: string
    format?: string
    s3Bucket: string
    s3Key: string
    fileSize: bigint | number
    checksum: string
    manifest: JsonNullValueInput | InputJsonValue
    compressionRatio?: number | null
    status?: $Enums.ArchiveStatus
    createdAt?: Date | string
    session: UnifiedSessionCreateNestedOneWithoutArchivesInput
  }

  export type SessionArchiveUncheckedCreateInput = {
    id?: string
    sessionId: string
    version?: string
    format?: string
    s3Bucket: string
    s3Key: string
    fileSize: bigint | number
    checksum: string
    manifest: JsonNullValueInput | InputJsonValue
    compressionRatio?: number | null
    status?: $Enums.ArchiveStatus
    createdAt?: Date | string
  }

  export type SessionArchiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: StringFieldUpdateOperationsInput | string
    manifest?: JsonNullValueInput | InputJsonValue
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumArchiveStatusFieldUpdateOperationsInput | $Enums.ArchiveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: UnifiedSessionUpdateOneRequiredWithoutArchivesNestedInput
  }

  export type SessionArchiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: StringFieldUpdateOperationsInput | string
    manifest?: JsonNullValueInput | InputJsonValue
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumArchiveStatusFieldUpdateOperationsInput | $Enums.ArchiveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionArchiveCreateManyInput = {
    id?: string
    sessionId: string
    version?: string
    format?: string
    s3Bucket: string
    s3Key: string
    fileSize: bigint | number
    checksum: string
    manifest: JsonNullValueInput | InputJsonValue
    compressionRatio?: number | null
    status?: $Enums.ArchiveStatus
    createdAt?: Date | string
  }

  export type SessionArchiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: StringFieldUpdateOperationsInput | string
    manifest?: JsonNullValueInput | InputJsonValue
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumArchiveStatusFieldUpdateOperationsInput | $Enums.ArchiveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionArchiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: StringFieldUpdateOperationsInput | string
    manifest?: JsonNullValueInput | InputJsonValue
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumArchiveStatusFieldUpdateOperationsInput | $Enums.ArchiveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingDataCreateInput = {
    id?: string
    sessionId: string
    openaiFileId?: string | null
    jsonlData?: string | null
    fileSize?: number | null
    trainingJobId?: string | null
    modelId?: string | null
    hyperparameters?: JsonNullValueInput | InputJsonValue
    trainingConfig?: JsonNullValueInput | InputJsonValue
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    trainingQuality?: number
    expectedPerformance?: number
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingDataUncheckedCreateInput = {
    id?: string
    sessionId: string
    openaiFileId?: string | null
    jsonlData?: string | null
    fileSize?: number | null
    trainingJobId?: string | null
    modelId?: string | null
    hyperparameters?: JsonNullValueInput | InputJsonValue
    trainingConfig?: JsonNullValueInput | InputJsonValue
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    trainingQuality?: number
    expectedPerformance?: number
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    openaiFileId?: NullableStringFieldUpdateOperationsInput | string | null
    jsonlData?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    trainingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    hyperparameters?: JsonNullValueInput | InputJsonValue
    trainingConfig?: JsonNullValueInput | InputJsonValue
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    trainingQuality?: FloatFieldUpdateOperationsInput | number
    expectedPerformance?: FloatFieldUpdateOperationsInput | number
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    openaiFileId?: NullableStringFieldUpdateOperationsInput | string | null
    jsonlData?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    trainingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    hyperparameters?: JsonNullValueInput | InputJsonValue
    trainingConfig?: JsonNullValueInput | InputJsonValue
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    trainingQuality?: FloatFieldUpdateOperationsInput | number
    expectedPerformance?: FloatFieldUpdateOperationsInput | number
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingDataCreateManyInput = {
    id?: string
    sessionId: string
    openaiFileId?: string | null
    jsonlData?: string | null
    fileSize?: number | null
    trainingJobId?: string | null
    modelId?: string | null
    hyperparameters?: JsonNullValueInput | InputJsonValue
    trainingConfig?: JsonNullValueInput | InputJsonValue
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    trainingQuality?: number
    expectedPerformance?: number
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type TrainingDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    openaiFileId?: NullableStringFieldUpdateOperationsInput | string | null
    jsonlData?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    trainingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    hyperparameters?: JsonNullValueInput | InputJsonValue
    trainingConfig?: JsonNullValueInput | InputJsonValue
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    trainingQuality?: FloatFieldUpdateOperationsInput | number
    expectedPerformance?: FloatFieldUpdateOperationsInput | number
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    openaiFileId?: NullableStringFieldUpdateOperationsInput | string | null
    jsonlData?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    trainingJobId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    hyperparameters?: JsonNullValueInput | InputJsonValue
    trainingConfig?: JsonNullValueInput | InputJsonValue
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    validationResults?: NullableJsonNullValueInput | InputJsonValue
    trainingQuality?: FloatFieldUpdateOperationsInput | number
    expectedPerformance?: FloatFieldUpdateOperationsInput | number
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description?: string | null
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description?: string | null
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description?: string | null
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QualityReportCreateInput = {
    id?: string
    sessionId: string
    overallScore: number
    completenessScore: number
    reliabilityScore: number
    accuracyScore: number
    validationResults?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    version?: string
  }

  export type QualityReportUncheckedCreateInput = {
    id?: string
    sessionId: string
    overallScore: number
    completenessScore: number
    reliabilityScore: number
    accuracyScore: number
    validationResults?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    version?: string
  }

  export type QualityReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completenessScore?: FloatFieldUpdateOperationsInput | number
    reliabilityScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    validationResults?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type QualityReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completenessScore?: FloatFieldUpdateOperationsInput | number
    reliabilityScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    validationResults?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type QualityReportCreateManyInput = {
    id?: string
    sessionId: string
    overallScore: number
    completenessScore: number
    reliabilityScore: number
    accuracyScore: number
    validationResults?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    version?: string
  }

  export type QualityReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completenessScore?: FloatFieldUpdateOperationsInput | number
    reliabilityScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    validationResults?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type QualityReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    overallScore?: FloatFieldUpdateOperationsInput | number
    completenessScore?: FloatFieldUpdateOperationsInput | number
    reliabilityScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    validationResults?: JsonNullValueInput | InputJsonValue
    issues?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type PsychologyProfileCreateInput = {
    id?: string
    sessionId: string
    dominantPersonality: $Enums.PersonalityType
    emotionalState: $Enums.EmotionalState
    decisionMakingStyle: $Enums.DecisionMakingStyle
    trustLevel?: number
    urgencyLevel?: number
    priceSensitivity?: number
    socialInfluence?: number
    insights?: JsonNullValueInput | InputJsonValue
    behaviorPredictions?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    confidence?: number
    processingTimestamp?: Date | string
  }

  export type PsychologyProfileUncheckedCreateInput = {
    id?: string
    sessionId: string
    dominantPersonality: $Enums.PersonalityType
    emotionalState: $Enums.EmotionalState
    decisionMakingStyle: $Enums.DecisionMakingStyle
    trustLevel?: number
    urgencyLevel?: number
    priceSensitivity?: number
    socialInfluence?: number
    insights?: JsonNullValueInput | InputJsonValue
    behaviorPredictions?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    confidence?: number
    processingTimestamp?: Date | string
  }

  export type PsychologyProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    dominantPersonality?: EnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType
    emotionalState?: EnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState
    decisionMakingStyle?: EnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle
    trustLevel?: FloatFieldUpdateOperationsInput | number
    urgencyLevel?: FloatFieldUpdateOperationsInput | number
    priceSensitivity?: FloatFieldUpdateOperationsInput | number
    socialInfluence?: FloatFieldUpdateOperationsInput | number
    insights?: JsonNullValueInput | InputJsonValue
    behaviorPredictions?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    processingTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PsychologyProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    dominantPersonality?: EnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType
    emotionalState?: EnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState
    decisionMakingStyle?: EnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle
    trustLevel?: FloatFieldUpdateOperationsInput | number
    urgencyLevel?: FloatFieldUpdateOperationsInput | number
    priceSensitivity?: FloatFieldUpdateOperationsInput | number
    socialInfluence?: FloatFieldUpdateOperationsInput | number
    insights?: JsonNullValueInput | InputJsonValue
    behaviorPredictions?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    processingTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PsychologyProfileCreateManyInput = {
    id?: string
    sessionId: string
    dominantPersonality: $Enums.PersonalityType
    emotionalState: $Enums.EmotionalState
    decisionMakingStyle: $Enums.DecisionMakingStyle
    trustLevel?: number
    urgencyLevel?: number
    priceSensitivity?: number
    socialInfluence?: number
    insights?: JsonNullValueInput | InputJsonValue
    behaviorPredictions?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    confidence?: number
    processingTimestamp?: Date | string
  }

  export type PsychologyProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    dominantPersonality?: EnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType
    emotionalState?: EnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState
    decisionMakingStyle?: EnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle
    trustLevel?: FloatFieldUpdateOperationsInput | number
    urgencyLevel?: FloatFieldUpdateOperationsInput | number
    priceSensitivity?: FloatFieldUpdateOperationsInput | number
    socialInfluence?: FloatFieldUpdateOperationsInput | number
    insights?: JsonNullValueInput | InputJsonValue
    behaviorPredictions?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    processingTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PsychologyProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    dominantPersonality?: EnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType
    emotionalState?: EnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState
    decisionMakingStyle?: EnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle
    trustLevel?: FloatFieldUpdateOperationsInput | number
    urgencyLevel?: FloatFieldUpdateOperationsInput | number
    priceSensitivity?: FloatFieldUpdateOperationsInput | number
    socialInfluence?: FloatFieldUpdateOperationsInput | number
    insights?: JsonNullValueInput | InputJsonValue
    behaviorPredictions?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    processingTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextEnhancementCreateInput = {
    id?: string
    sessionId: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    userIntent?: JsonNullValueInput | InputJsonValue
    navigationPattern?: JsonNullValueInput | InputJsonValue
    shoppingBehavior?: JsonNullValueInput | InputJsonValue
    contextualInsights?: JsonNullValueInput | InputJsonValue
    trainingValue?: number
    processingTimestamp?: Date | string
  }

  export type ContextEnhancementUncheckedCreateInput = {
    id?: string
    sessionId: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    userIntent?: JsonNullValueInput | InputJsonValue
    navigationPattern?: JsonNullValueInput | InputJsonValue
    shoppingBehavior?: JsonNullValueInput | InputJsonValue
    contextualInsights?: JsonNullValueInput | InputJsonValue
    trainingValue?: number
    processingTimestamp?: Date | string
  }

  export type ContextEnhancementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    userIntent?: JsonNullValueInput | InputJsonValue
    navigationPattern?: JsonNullValueInput | InputJsonValue
    shoppingBehavior?: JsonNullValueInput | InputJsonValue
    contextualInsights?: JsonNullValueInput | InputJsonValue
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextEnhancementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    userIntent?: JsonNullValueInput | InputJsonValue
    navigationPattern?: JsonNullValueInput | InputJsonValue
    shoppingBehavior?: JsonNullValueInput | InputJsonValue
    contextualInsights?: JsonNullValueInput | InputJsonValue
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextEnhancementCreateManyInput = {
    id?: string
    sessionId: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    userIntent?: JsonNullValueInput | InputJsonValue
    navigationPattern?: JsonNullValueInput | InputJsonValue
    shoppingBehavior?: JsonNullValueInput | InputJsonValue
    contextualInsights?: JsonNullValueInput | InputJsonValue
    trainingValue?: number
    processingTimestamp?: Date | string
  }

  export type ContextEnhancementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    userIntent?: JsonNullValueInput | InputJsonValue
    navigationPattern?: JsonNullValueInput | InputJsonValue
    shoppingBehavior?: JsonNullValueInput | InputJsonValue
    contextualInsights?: JsonNullValueInput | InputJsonValue
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextEnhancementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    userIntent?: JsonNullValueInput | InputJsonValue
    navigationPattern?: JsonNullValueInput | InputJsonValue
    shoppingBehavior?: JsonNullValueInput | InputJsonValue
    contextualInsights?: JsonNullValueInput | InputJsonValue
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisionAnalysisCacheCreateInput = {
    id?: string
    screenshotId: string
    analysisType: string
    analysisResult: JsonNullValueInput | InputJsonValue
    qualityScore?: number
    createdAt?: Date | string
    expiresAt: Date | string
    hitCount?: number
  }

  export type VisionAnalysisCacheUncheckedCreateInput = {
    id?: string
    screenshotId: string
    analysisType: string
    analysisResult: JsonNullValueInput | InputJsonValue
    qualityScore?: number
    createdAt?: Date | string
    expiresAt: Date | string
    hitCount?: number
  }

  export type VisionAnalysisCacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    screenshotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    analysisResult?: JsonNullValueInput | InputJsonValue
    qualityScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
  }

  export type VisionAnalysisCacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    screenshotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    analysisResult?: JsonNullValueInput | InputJsonValue
    qualityScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
  }

  export type VisionAnalysisCacheCreateManyInput = {
    id?: string
    screenshotId: string
    analysisType: string
    analysisResult: JsonNullValueInput | InputJsonValue
    qualityScore?: number
    createdAt?: Date | string
    expiresAt: Date | string
    hitCount?: number
  }

  export type VisionAnalysisCacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    screenshotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    analysisResult?: JsonNullValueInput | InputJsonValue
    qualityScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
  }

  export type VisionAnalysisCacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    screenshotId?: StringFieldUpdateOperationsInput | string
    analysisType?: StringFieldUpdateOperationsInput | string
    analysisResult?: JsonNullValueInput | InputJsonValue
    qualityScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeFilter<$PrismaModel> | $Enums.SessionType
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumPersonalityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel> | $Enums.PersonalityType | null
  }

  export type EnumEmotionalStateNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalState | EnumEmotionalStateFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmotionalStateNullableFilter<$PrismaModel> | $Enums.EmotionalState | null
  }

  export type EnumDecisionMakingStyleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionMakingStyle | EnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDecisionMakingStyleNullableFilter<$PrismaModel> | $Enums.DecisionMakingStyle | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type InteractionListRelationFilter = {
    every?: InteractionWhereInput
    some?: InteractionWhereInput
    none?: InteractionWhereInput
  }

  export type ScreenshotListRelationFilter = {
    every?: ScreenshotWhereInput
    some?: ScreenshotWhereInput
    none?: ScreenshotWhereInput
  }

  export type SessionArchiveListRelationFilter = {
    every?: SessionArchiveWhereInput
    some?: SessionArchiveWhereInput
    none?: SessionArchiveWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type InteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScreenshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionArchiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnifiedSessionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    archiveUrl?: SortOrder
    trainingFileId?: SortOrder
    modelId?: SortOrder
    qualityScore?: SortOrder
    completeness?: SortOrder
    reliability?: SortOrder
    trainingValue?: SortOrder
    processingStatus?: SortOrder
    processingSteps?: SortOrder
    processingErrors?: SortOrder
    config?: SortOrder
    workerId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    trainingMetrics?: SortOrder
    modelPerformance?: SortOrder
    dominantPersonality?: SortOrder
    emotionalState?: SortOrder
    decisionMakingStyle?: SortOrder
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    psychologyConfidence?: SortOrder
    pageType?: SortOrder
    userIntent?: SortOrder
    shoppingStage?: SortOrder
    behaviorType?: SortOrder
    purchaseReadiness?: SortOrder
    navigationEfficiency?: SortOrder
    contextualInsights?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
    qualityScore?: SortOrder
    completeness?: SortOrder
    reliability?: SortOrder
    trainingValue?: SortOrder
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    psychologyConfidence?: SortOrder
    purchaseReadiness?: SortOrder
    navigationEfficiency?: SortOrder
  }

  export type UnifiedSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    archiveUrl?: SortOrder
    trainingFileId?: SortOrder
    modelId?: SortOrder
    qualityScore?: SortOrder
    completeness?: SortOrder
    reliability?: SortOrder
    trainingValue?: SortOrder
    processingStatus?: SortOrder
    workerId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    dominantPersonality?: SortOrder
    emotionalState?: SortOrder
    decisionMakingStyle?: SortOrder
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    psychologyConfidence?: SortOrder
    pageType?: SortOrder
    userIntent?: SortOrder
    shoppingStage?: SortOrder
    behaviorType?: SortOrder
    purchaseReadiness?: SortOrder
    navigationEfficiency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedSessionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    archiveUrl?: SortOrder
    trainingFileId?: SortOrder
    modelId?: SortOrder
    qualityScore?: SortOrder
    completeness?: SortOrder
    reliability?: SortOrder
    trainingValue?: SortOrder
    processingStatus?: SortOrder
    workerId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    dominantPersonality?: SortOrder
    emotionalState?: SortOrder
    decisionMakingStyle?: SortOrder
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    psychologyConfidence?: SortOrder
    pageType?: SortOrder
    userIntent?: SortOrder
    shoppingStage?: SortOrder
    behaviorType?: SortOrder
    purchaseReadiness?: SortOrder
    navigationEfficiency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnifiedSessionSumOrderByAggregateInput = {
    duration?: SortOrder
    qualityScore?: SortOrder
    completeness?: SortOrder
    reliability?: SortOrder
    trainingValue?: SortOrder
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    psychologyConfidence?: SortOrder
    purchaseReadiness?: SortOrder
    navigationEfficiency?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumSessionTypeFilter<$PrismaModel>
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumPersonalityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPersonalityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PersonalityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel>
  }

  export type EnumEmotionalStateNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalState | EnumEmotionalStateFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmotionalStateNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmotionalState | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEmotionalStateNullableFilter<$PrismaModel>
    _max?: NestedEnumEmotionalStateNullableFilter<$PrismaModel>
  }

  export type EnumDecisionMakingStyleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionMakingStyle | EnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDecisionMakingStyleNullableWithAggregatesFilter<$PrismaModel> | $Enums.DecisionMakingStyle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDecisionMakingStyleNullableFilter<$PrismaModel>
    _max?: NestedEnumDecisionMakingStyleNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UnifiedSessionRelationFilter = {
    is?: UnifiedSessionWhereInput
    isNot?: UnifiedSessionWhereInput
  }

  export type InteractionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    sessionTime?: SortOrder
    primarySelector?: SortOrder
    selectorAlternatives?: SortOrder
    xpath?: SortOrder
    cssPath?: SortOrder
    elementTag?: SortOrder
    elementText?: SortOrder
    elementValue?: SortOrder
    elementAttributes?: SortOrder
    clientX?: SortOrder
    clientY?: SortOrder
    pageX?: SortOrder
    pageY?: SortOrder
    boundingBox?: SortOrder
    viewport?: SortOrder
    isInViewport?: SortOrder
    percentVisible?: SortOrder
    url?: SortOrder
    pageTitle?: SortOrder
    pageStructure?: SortOrder
    parentElements?: SortOrder
    siblingElements?: SortOrder
    nearbyElements?: SortOrder
    stateBefore?: SortOrder
    stateAfter?: SortOrder
    stateChanges?: SortOrder
    confidence?: SortOrder
    selectorReliability?: SortOrder
    userIntent?: SortOrder
    userReasoning?: SortOrder
    visualCues?: SortOrder
  }

  export type InteractionAvgOrderByAggregateInput = {
    timestamp?: SortOrder
    sessionTime?: SortOrder
    clientX?: SortOrder
    clientY?: SortOrder
    pageX?: SortOrder
    pageY?: SortOrder
    percentVisible?: SortOrder
    confidence?: SortOrder
  }

  export type InteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    sessionTime?: SortOrder
    primarySelector?: SortOrder
    xpath?: SortOrder
    cssPath?: SortOrder
    elementTag?: SortOrder
    elementText?: SortOrder
    elementValue?: SortOrder
    clientX?: SortOrder
    clientY?: SortOrder
    pageX?: SortOrder
    pageY?: SortOrder
    isInViewport?: SortOrder
    percentVisible?: SortOrder
    url?: SortOrder
    pageTitle?: SortOrder
    confidence?: SortOrder
    userIntent?: SortOrder
    userReasoning?: SortOrder
  }

  export type InteractionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    sessionTime?: SortOrder
    primarySelector?: SortOrder
    xpath?: SortOrder
    cssPath?: SortOrder
    elementTag?: SortOrder
    elementText?: SortOrder
    elementValue?: SortOrder
    clientX?: SortOrder
    clientY?: SortOrder
    pageX?: SortOrder
    pageY?: SortOrder
    isInViewport?: SortOrder
    percentVisible?: SortOrder
    url?: SortOrder
    pageTitle?: SortOrder
    confidence?: SortOrder
    userIntent?: SortOrder
    userReasoning?: SortOrder
  }

  export type InteractionSumOrderByAggregateInput = {
    timestamp?: SortOrder
    sessionTime?: SortOrder
    clientX?: SortOrder
    clientY?: SortOrder
    pageX?: SortOrder
    pageY?: SortOrder
    percentVisible?: SortOrder
    confidence?: SortOrder
  }

  export type EnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type InteractionNullableRelationFilter = {
    is?: InteractionWhereInput | null
    isNot?: InteractionWhereInput | null
  }

  export type ScreenshotCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interactionId?: SortOrder
    timestamp?: SortOrder
    eventType?: SortOrder
    s3Key?: SortOrder
    dataUrl?: SortOrder
    compressed?: SortOrder
    format?: SortOrder
    fileSize?: SortOrder
    viewport?: SortOrder
    quality?: SortOrder
    visionAnalysis?: SortOrder
    userPsychology?: SortOrder
  }

  export type ScreenshotAvgOrderByAggregateInput = {
    timestamp?: SortOrder
    fileSize?: SortOrder
    quality?: SortOrder
  }

  export type ScreenshotMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interactionId?: SortOrder
    timestamp?: SortOrder
    eventType?: SortOrder
    s3Key?: SortOrder
    dataUrl?: SortOrder
    compressed?: SortOrder
    format?: SortOrder
    fileSize?: SortOrder
    quality?: SortOrder
  }

  export type ScreenshotMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    interactionId?: SortOrder
    timestamp?: SortOrder
    eventType?: SortOrder
    s3Key?: SortOrder
    dataUrl?: SortOrder
    compressed?: SortOrder
    format?: SortOrder
    fileSize?: SortOrder
    quality?: SortOrder
  }

  export type ScreenshotSumOrderByAggregateInput = {
    timestamp?: SortOrder
    fileSize?: SortOrder
    quality?: SortOrder
  }

  export type EnumArchiveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ArchiveStatus | EnumArchiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArchiveStatus[] | ListEnumArchiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArchiveStatus[] | ListEnumArchiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArchiveStatusFilter<$PrismaModel> | $Enums.ArchiveStatus
  }

  export type SessionArchiveCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    version?: SortOrder
    format?: SortOrder
    s3Bucket?: SortOrder
    s3Key?: SortOrder
    fileSize?: SortOrder
    checksum?: SortOrder
    manifest?: SortOrder
    compressionRatio?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionArchiveAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    compressionRatio?: SortOrder
  }

  export type SessionArchiveMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    version?: SortOrder
    format?: SortOrder
    s3Bucket?: SortOrder
    s3Key?: SortOrder
    fileSize?: SortOrder
    checksum?: SortOrder
    compressionRatio?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionArchiveMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    version?: SortOrder
    format?: SortOrder
    s3Bucket?: SortOrder
    s3Key?: SortOrder
    fileSize?: SortOrder
    checksum?: SortOrder
    compressionRatio?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionArchiveSumOrderByAggregateInput = {
    fileSize?: SortOrder
    compressionRatio?: SortOrder
  }

  export type EnumArchiveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArchiveStatus | EnumArchiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArchiveStatus[] | ListEnumArchiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArchiveStatus[] | ListEnumArchiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArchiveStatusWithAggregatesFilter<$PrismaModel> | $Enums.ArchiveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArchiveStatusFilter<$PrismaModel>
    _max?: NestedEnumArchiveStatusFilter<$PrismaModel>
  }

  export type EnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type TrainingDataCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    openaiFileId?: SortOrder
    jsonlData?: SortOrder
    fileSize?: SortOrder
    trainingJobId?: SortOrder
    modelId?: SortOrder
    hyperparameters?: SortOrder
    trainingConfig?: SortOrder
    trainingMetrics?: SortOrder
    validationResults?: SortOrder
    trainingQuality?: SortOrder
    expectedPerformance?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingDataAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    trainingQuality?: SortOrder
    expectedPerformance?: SortOrder
  }

  export type TrainingDataMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    openaiFileId?: SortOrder
    jsonlData?: SortOrder
    fileSize?: SortOrder
    trainingJobId?: SortOrder
    modelId?: SortOrder
    trainingQuality?: SortOrder
    expectedPerformance?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingDataMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    openaiFileId?: SortOrder
    jsonlData?: SortOrder
    fileSize?: SortOrder
    trainingJobId?: SortOrder
    modelId?: SortOrder
    trainingQuality?: SortOrder
    expectedPerformance?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type TrainingDataSumOrderByAggregateInput = {
    fileSize?: SortOrder
    trainingQuality?: SortOrder
    expectedPerformance?: SortOrder
  }

  export type EnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QualityReportCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    completenessScore?: SortOrder
    reliabilityScore?: SortOrder
    accuracyScore?: SortOrder
    validationResults?: SortOrder
    issues?: SortOrder
    recommendations?: SortOrder
    generatedAt?: SortOrder
    version?: SortOrder
  }

  export type QualityReportAvgOrderByAggregateInput = {
    overallScore?: SortOrder
    completenessScore?: SortOrder
    reliabilityScore?: SortOrder
    accuracyScore?: SortOrder
  }

  export type QualityReportMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    completenessScore?: SortOrder
    reliabilityScore?: SortOrder
    accuracyScore?: SortOrder
    generatedAt?: SortOrder
    version?: SortOrder
  }

  export type QualityReportMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    completenessScore?: SortOrder
    reliabilityScore?: SortOrder
    accuracyScore?: SortOrder
    generatedAt?: SortOrder
    version?: SortOrder
  }

  export type QualityReportSumOrderByAggregateInput = {
    overallScore?: SortOrder
    completenessScore?: SortOrder
    reliabilityScore?: SortOrder
    accuracyScore?: SortOrder
  }

  export type EnumPersonalityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalityTypeFilter<$PrismaModel> | $Enums.PersonalityType
  }

  export type EnumEmotionalStateFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalState | EnumEmotionalStateFieldRefInput<$PrismaModel>
    in?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel>
    not?: NestedEnumEmotionalStateFilter<$PrismaModel> | $Enums.EmotionalState
  }

  export type EnumDecisionMakingStyleFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionMakingStyle | EnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionMakingStyleFilter<$PrismaModel> | $Enums.DecisionMakingStyle
  }

  export type PsychologyProfileCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    dominantPersonality?: SortOrder
    emotionalState?: SortOrder
    decisionMakingStyle?: SortOrder
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    insights?: SortOrder
    behaviorPredictions?: SortOrder
    recommendations?: SortOrder
    confidence?: SortOrder
    processingTimestamp?: SortOrder
  }

  export type PsychologyProfileAvgOrderByAggregateInput = {
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    confidence?: SortOrder
  }

  export type PsychologyProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    dominantPersonality?: SortOrder
    emotionalState?: SortOrder
    decisionMakingStyle?: SortOrder
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    confidence?: SortOrder
    processingTimestamp?: SortOrder
  }

  export type PsychologyProfileMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    dominantPersonality?: SortOrder
    emotionalState?: SortOrder
    decisionMakingStyle?: SortOrder
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    confidence?: SortOrder
    processingTimestamp?: SortOrder
  }

  export type PsychologyProfileSumOrderByAggregateInput = {
    trustLevel?: SortOrder
    urgencyLevel?: SortOrder
    priceSensitivity?: SortOrder
    socialInfluence?: SortOrder
    confidence?: SortOrder
  }

  export type EnumPersonalityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalityTypeWithAggregatesFilter<$PrismaModel> | $Enums.PersonalityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonalityTypeFilter<$PrismaModel>
    _max?: NestedEnumPersonalityTypeFilter<$PrismaModel>
  }

  export type EnumEmotionalStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalState | EnumEmotionalStateFieldRefInput<$PrismaModel>
    in?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel>
    not?: NestedEnumEmotionalStateWithAggregatesFilter<$PrismaModel> | $Enums.EmotionalState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmotionalStateFilter<$PrismaModel>
    _max?: NestedEnumEmotionalStateFilter<$PrismaModel>
  }

  export type EnumDecisionMakingStyleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionMakingStyle | EnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionMakingStyleWithAggregatesFilter<$PrismaModel> | $Enums.DecisionMakingStyle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDecisionMakingStyleFilter<$PrismaModel>
    _max?: NestedEnumDecisionMakingStyleFilter<$PrismaModel>
  }

  export type ContextEnhancementCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    pageStructure?: SortOrder
    userIntent?: SortOrder
    navigationPattern?: SortOrder
    shoppingBehavior?: SortOrder
    contextualInsights?: SortOrder
    trainingValue?: SortOrder
    processingTimestamp?: SortOrder
  }

  export type ContextEnhancementAvgOrderByAggregateInput = {
    trainingValue?: SortOrder
  }

  export type ContextEnhancementMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    trainingValue?: SortOrder
    processingTimestamp?: SortOrder
  }

  export type ContextEnhancementMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    trainingValue?: SortOrder
    processingTimestamp?: SortOrder
  }

  export type ContextEnhancementSumOrderByAggregateInput = {
    trainingValue?: SortOrder
  }

  export type VisionAnalysisCacheScreenshotIdAnalysisTypeCompoundUniqueInput = {
    screenshotId: string
    analysisType: string
  }

  export type VisionAnalysisCacheCountOrderByAggregateInput = {
    id?: SortOrder
    screenshotId?: SortOrder
    analysisType?: SortOrder
    analysisResult?: SortOrder
    qualityScore?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    hitCount?: SortOrder
  }

  export type VisionAnalysisCacheAvgOrderByAggregateInput = {
    qualityScore?: SortOrder
    hitCount?: SortOrder
  }

  export type VisionAnalysisCacheMaxOrderByAggregateInput = {
    id?: SortOrder
    screenshotId?: SortOrder
    analysisType?: SortOrder
    qualityScore?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    hitCount?: SortOrder
  }

  export type VisionAnalysisCacheMinOrderByAggregateInput = {
    id?: SortOrder
    screenshotId?: SortOrder
    analysisType?: SortOrder
    qualityScore?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    hitCount?: SortOrder
  }

  export type VisionAnalysisCacheSumOrderByAggregateInput = {
    qualityScore?: SortOrder
    hitCount?: SortOrder
  }

  export type InteractionCreateNestedManyWithoutSessionInput = {
    create?: XOR<InteractionCreateWithoutSessionInput, InteractionUncheckedCreateWithoutSessionInput> | InteractionCreateWithoutSessionInput[] | InteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutSessionInput | InteractionCreateOrConnectWithoutSessionInput[]
    createMany?: InteractionCreateManySessionInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type ScreenshotCreateNestedManyWithoutSessionInput = {
    create?: XOR<ScreenshotCreateWithoutSessionInput, ScreenshotUncheckedCreateWithoutSessionInput> | ScreenshotCreateWithoutSessionInput[] | ScreenshotUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutSessionInput | ScreenshotCreateOrConnectWithoutSessionInput[]
    createMany?: ScreenshotCreateManySessionInputEnvelope
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
  }

  export type SessionArchiveCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionArchiveCreateWithoutSessionInput, SessionArchiveUncheckedCreateWithoutSessionInput> | SessionArchiveCreateWithoutSessionInput[] | SessionArchiveUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionArchiveCreateOrConnectWithoutSessionInput | SessionArchiveCreateOrConnectWithoutSessionInput[]
    createMany?: SessionArchiveCreateManySessionInputEnvelope
    connect?: SessionArchiveWhereUniqueInput | SessionArchiveWhereUniqueInput[]
  }

  export type InteractionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<InteractionCreateWithoutSessionInput, InteractionUncheckedCreateWithoutSessionInput> | InteractionCreateWithoutSessionInput[] | InteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutSessionInput | InteractionCreateOrConnectWithoutSessionInput[]
    createMany?: InteractionCreateManySessionInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type ScreenshotUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ScreenshotCreateWithoutSessionInput, ScreenshotUncheckedCreateWithoutSessionInput> | ScreenshotCreateWithoutSessionInput[] | ScreenshotUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutSessionInput | ScreenshotCreateOrConnectWithoutSessionInput[]
    createMany?: ScreenshotCreateManySessionInputEnvelope
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
  }

  export type SessionArchiveUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionArchiveCreateWithoutSessionInput, SessionArchiveUncheckedCreateWithoutSessionInput> | SessionArchiveCreateWithoutSessionInput[] | SessionArchiveUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionArchiveCreateOrConnectWithoutSessionInput | SessionArchiveCreateOrConnectWithoutSessionInput[]
    createMany?: SessionArchiveCreateManySessionInputEnvelope
    connect?: SessionArchiveWhereUniqueInput | SessionArchiveWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumSessionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SessionType
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumProcessingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessingStatus
  }

  export type NullableEnumPersonalityTypeFieldUpdateOperationsInput = {
    set?: $Enums.PersonalityType | null
  }

  export type NullableEnumEmotionalStateFieldUpdateOperationsInput = {
    set?: $Enums.EmotionalState | null
  }

  export type NullableEnumDecisionMakingStyleFieldUpdateOperationsInput = {
    set?: $Enums.DecisionMakingStyle | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InteractionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<InteractionCreateWithoutSessionInput, InteractionUncheckedCreateWithoutSessionInput> | InteractionCreateWithoutSessionInput[] | InteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutSessionInput | InteractionCreateOrConnectWithoutSessionInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutSessionInput | InteractionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: InteractionCreateManySessionInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutSessionInput | InteractionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutSessionInput | InteractionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type ScreenshotUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ScreenshotCreateWithoutSessionInput, ScreenshotUncheckedCreateWithoutSessionInput> | ScreenshotCreateWithoutSessionInput[] | ScreenshotUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutSessionInput | ScreenshotCreateOrConnectWithoutSessionInput[]
    upsert?: ScreenshotUpsertWithWhereUniqueWithoutSessionInput | ScreenshotUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ScreenshotCreateManySessionInputEnvelope
    set?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    disconnect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    delete?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    update?: ScreenshotUpdateWithWhereUniqueWithoutSessionInput | ScreenshotUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ScreenshotUpdateManyWithWhereWithoutSessionInput | ScreenshotUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[]
  }

  export type SessionArchiveUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionArchiveCreateWithoutSessionInput, SessionArchiveUncheckedCreateWithoutSessionInput> | SessionArchiveCreateWithoutSessionInput[] | SessionArchiveUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionArchiveCreateOrConnectWithoutSessionInput | SessionArchiveCreateOrConnectWithoutSessionInput[]
    upsert?: SessionArchiveUpsertWithWhereUniqueWithoutSessionInput | SessionArchiveUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionArchiveCreateManySessionInputEnvelope
    set?: SessionArchiveWhereUniqueInput | SessionArchiveWhereUniqueInput[]
    disconnect?: SessionArchiveWhereUniqueInput | SessionArchiveWhereUniqueInput[]
    delete?: SessionArchiveWhereUniqueInput | SessionArchiveWhereUniqueInput[]
    connect?: SessionArchiveWhereUniqueInput | SessionArchiveWhereUniqueInput[]
    update?: SessionArchiveUpdateWithWhereUniqueWithoutSessionInput | SessionArchiveUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionArchiveUpdateManyWithWhereWithoutSessionInput | SessionArchiveUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionArchiveScalarWhereInput | SessionArchiveScalarWhereInput[]
  }

  export type InteractionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<InteractionCreateWithoutSessionInput, InteractionUncheckedCreateWithoutSessionInput> | InteractionCreateWithoutSessionInput[] | InteractionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutSessionInput | InteractionCreateOrConnectWithoutSessionInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutSessionInput | InteractionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: InteractionCreateManySessionInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutSessionInput | InteractionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutSessionInput | InteractionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type ScreenshotUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ScreenshotCreateWithoutSessionInput, ScreenshotUncheckedCreateWithoutSessionInput> | ScreenshotCreateWithoutSessionInput[] | ScreenshotUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutSessionInput | ScreenshotCreateOrConnectWithoutSessionInput[]
    upsert?: ScreenshotUpsertWithWhereUniqueWithoutSessionInput | ScreenshotUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ScreenshotCreateManySessionInputEnvelope
    set?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    disconnect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    delete?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    update?: ScreenshotUpdateWithWhereUniqueWithoutSessionInput | ScreenshotUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ScreenshotUpdateManyWithWhereWithoutSessionInput | ScreenshotUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[]
  }

  export type SessionArchiveUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionArchiveCreateWithoutSessionInput, SessionArchiveUncheckedCreateWithoutSessionInput> | SessionArchiveCreateWithoutSessionInput[] | SessionArchiveUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionArchiveCreateOrConnectWithoutSessionInput | SessionArchiveCreateOrConnectWithoutSessionInput[]
    upsert?: SessionArchiveUpsertWithWhereUniqueWithoutSessionInput | SessionArchiveUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionArchiveCreateManySessionInputEnvelope
    set?: SessionArchiveWhereUniqueInput | SessionArchiveWhereUniqueInput[]
    disconnect?: SessionArchiveWhereUniqueInput | SessionArchiveWhereUniqueInput[]
    delete?: SessionArchiveWhereUniqueInput | SessionArchiveWhereUniqueInput[]
    connect?: SessionArchiveWhereUniqueInput | SessionArchiveWhereUniqueInput[]
    update?: SessionArchiveUpdateWithWhereUniqueWithoutSessionInput | SessionArchiveUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionArchiveUpdateManyWithWhereWithoutSessionInput | SessionArchiveUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionArchiveScalarWhereInput | SessionArchiveScalarWhereInput[]
  }

  export type UnifiedSessionCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<UnifiedSessionCreateWithoutInteractionsInput, UnifiedSessionUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: UnifiedSessionCreateOrConnectWithoutInteractionsInput
    connect?: UnifiedSessionWhereUniqueInput
  }

  export type ScreenshotCreateNestedManyWithoutInteractionInput = {
    create?: XOR<ScreenshotCreateWithoutInteractionInput, ScreenshotUncheckedCreateWithoutInteractionInput> | ScreenshotCreateWithoutInteractionInput[] | ScreenshotUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutInteractionInput | ScreenshotCreateOrConnectWithoutInteractionInput[]
    createMany?: ScreenshotCreateManyInteractionInputEnvelope
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
  }

  export type ScreenshotUncheckedCreateNestedManyWithoutInteractionInput = {
    create?: XOR<ScreenshotCreateWithoutInteractionInput, ScreenshotUncheckedCreateWithoutInteractionInput> | ScreenshotCreateWithoutInteractionInput[] | ScreenshotUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutInteractionInput | ScreenshotCreateOrConnectWithoutInteractionInput[]
    createMany?: ScreenshotCreateManyInteractionInputEnvelope
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
  }

  export type EnumInteractionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InteractionType
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UnifiedSessionUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<UnifiedSessionCreateWithoutInteractionsInput, UnifiedSessionUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: UnifiedSessionCreateOrConnectWithoutInteractionsInput
    upsert?: UnifiedSessionUpsertWithoutInteractionsInput
    connect?: UnifiedSessionWhereUniqueInput
    update?: XOR<XOR<UnifiedSessionUpdateToOneWithWhereWithoutInteractionsInput, UnifiedSessionUpdateWithoutInteractionsInput>, UnifiedSessionUncheckedUpdateWithoutInteractionsInput>
  }

  export type ScreenshotUpdateManyWithoutInteractionNestedInput = {
    create?: XOR<ScreenshotCreateWithoutInteractionInput, ScreenshotUncheckedCreateWithoutInteractionInput> | ScreenshotCreateWithoutInteractionInput[] | ScreenshotUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutInteractionInput | ScreenshotCreateOrConnectWithoutInteractionInput[]
    upsert?: ScreenshotUpsertWithWhereUniqueWithoutInteractionInput | ScreenshotUpsertWithWhereUniqueWithoutInteractionInput[]
    createMany?: ScreenshotCreateManyInteractionInputEnvelope
    set?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    disconnect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    delete?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    update?: ScreenshotUpdateWithWhereUniqueWithoutInteractionInput | ScreenshotUpdateWithWhereUniqueWithoutInteractionInput[]
    updateMany?: ScreenshotUpdateManyWithWhereWithoutInteractionInput | ScreenshotUpdateManyWithWhereWithoutInteractionInput[]
    deleteMany?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[]
  }

  export type ScreenshotUncheckedUpdateManyWithoutInteractionNestedInput = {
    create?: XOR<ScreenshotCreateWithoutInteractionInput, ScreenshotUncheckedCreateWithoutInteractionInput> | ScreenshotCreateWithoutInteractionInput[] | ScreenshotUncheckedCreateWithoutInteractionInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutInteractionInput | ScreenshotCreateOrConnectWithoutInteractionInput[]
    upsert?: ScreenshotUpsertWithWhereUniqueWithoutInteractionInput | ScreenshotUpsertWithWhereUniqueWithoutInteractionInput[]
    createMany?: ScreenshotCreateManyInteractionInputEnvelope
    set?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    disconnect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    delete?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    update?: ScreenshotUpdateWithWhereUniqueWithoutInteractionInput | ScreenshotUpdateWithWhereUniqueWithoutInteractionInput[]
    updateMany?: ScreenshotUpdateManyWithWhereWithoutInteractionInput | ScreenshotUpdateManyWithWhereWithoutInteractionInput[]
    deleteMany?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[]
  }

  export type UnifiedSessionCreateNestedOneWithoutScreenshotsInput = {
    create?: XOR<UnifiedSessionCreateWithoutScreenshotsInput, UnifiedSessionUncheckedCreateWithoutScreenshotsInput>
    connectOrCreate?: UnifiedSessionCreateOrConnectWithoutScreenshotsInput
    connect?: UnifiedSessionWhereUniqueInput
  }

  export type InteractionCreateNestedOneWithoutRelatedScreenshotsInput = {
    create?: XOR<InteractionCreateWithoutRelatedScreenshotsInput, InteractionUncheckedCreateWithoutRelatedScreenshotsInput>
    connectOrCreate?: InteractionCreateOrConnectWithoutRelatedScreenshotsInput
    connect?: InteractionWhereUniqueInput
  }

  export type UnifiedSessionUpdateOneRequiredWithoutScreenshotsNestedInput = {
    create?: XOR<UnifiedSessionCreateWithoutScreenshotsInput, UnifiedSessionUncheckedCreateWithoutScreenshotsInput>
    connectOrCreate?: UnifiedSessionCreateOrConnectWithoutScreenshotsInput
    upsert?: UnifiedSessionUpsertWithoutScreenshotsInput
    connect?: UnifiedSessionWhereUniqueInput
    update?: XOR<XOR<UnifiedSessionUpdateToOneWithWhereWithoutScreenshotsInput, UnifiedSessionUpdateWithoutScreenshotsInput>, UnifiedSessionUncheckedUpdateWithoutScreenshotsInput>
  }

  export type InteractionUpdateOneWithoutRelatedScreenshotsNestedInput = {
    create?: XOR<InteractionCreateWithoutRelatedScreenshotsInput, InteractionUncheckedCreateWithoutRelatedScreenshotsInput>
    connectOrCreate?: InteractionCreateOrConnectWithoutRelatedScreenshotsInput
    upsert?: InteractionUpsertWithoutRelatedScreenshotsInput
    disconnect?: InteractionWhereInput | boolean
    delete?: InteractionWhereInput | boolean
    connect?: InteractionWhereUniqueInput
    update?: XOR<XOR<InteractionUpdateToOneWithWhereWithoutRelatedScreenshotsInput, InteractionUpdateWithoutRelatedScreenshotsInput>, InteractionUncheckedUpdateWithoutRelatedScreenshotsInput>
  }

  export type UnifiedSessionCreateNestedOneWithoutArchivesInput = {
    create?: XOR<UnifiedSessionCreateWithoutArchivesInput, UnifiedSessionUncheckedCreateWithoutArchivesInput>
    connectOrCreate?: UnifiedSessionCreateOrConnectWithoutArchivesInput
    connect?: UnifiedSessionWhereUniqueInput
  }

  export type EnumArchiveStatusFieldUpdateOperationsInput = {
    set?: $Enums.ArchiveStatus
  }

  export type UnifiedSessionUpdateOneRequiredWithoutArchivesNestedInput = {
    create?: XOR<UnifiedSessionCreateWithoutArchivesInput, UnifiedSessionUncheckedCreateWithoutArchivesInput>
    connectOrCreate?: UnifiedSessionCreateOrConnectWithoutArchivesInput
    upsert?: UnifiedSessionUpsertWithoutArchivesInput
    connect?: UnifiedSessionWhereUniqueInput
    update?: XOR<XOR<UnifiedSessionUpdateToOneWithWhereWithoutArchivesInput, UnifiedSessionUpdateWithoutArchivesInput>, UnifiedSessionUncheckedUpdateWithoutArchivesInput>
  }

  export type EnumTrainingStatusFieldUpdateOperationsInput = {
    set?: $Enums.TrainingStatus
  }

  export type EnumPersonalityTypeFieldUpdateOperationsInput = {
    set?: $Enums.PersonalityType
  }

  export type EnumEmotionalStateFieldUpdateOperationsInput = {
    set?: $Enums.EmotionalState
  }

  export type EnumDecisionMakingStyleFieldUpdateOperationsInput = {
    set?: $Enums.DecisionMakingStyle
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumSessionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeFilter<$PrismaModel> | $Enums.SessionType
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type NestedEnumPersonalityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel> | $Enums.PersonalityType | null
  }

  export type NestedEnumEmotionalStateNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalState | EnumEmotionalStateFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmotionalStateNullableFilter<$PrismaModel> | $Enums.EmotionalState | null
  }

  export type NestedEnumDecisionMakingStyleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionMakingStyle | EnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDecisionMakingStyleNullableFilter<$PrismaModel> | $Enums.DecisionMakingStyle | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionType | EnumSessionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionType[] | ListEnumSessionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SessionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionTypeFilter<$PrismaModel>
    _max?: NestedEnumSessionTypeFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPersonalityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPersonalityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PersonalityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEmotionalStateNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalState | EnumEmotionalStateFieldRefInput<$PrismaModel> | null
    in?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEmotionalStateNullableWithAggregatesFilter<$PrismaModel> | $Enums.EmotionalState | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEmotionalStateNullableFilter<$PrismaModel>
    _max?: NestedEnumEmotionalStateNullableFilter<$PrismaModel>
  }

  export type NestedEnumDecisionMakingStyleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionMakingStyle | EnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDecisionMakingStyleNullableWithAggregatesFilter<$PrismaModel> | $Enums.DecisionMakingStyle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDecisionMakingStyleNullableFilter<$PrismaModel>
    _max?: NestedEnumDecisionMakingStyleNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumArchiveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ArchiveStatus | EnumArchiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArchiveStatus[] | ListEnumArchiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArchiveStatus[] | ListEnumArchiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArchiveStatusFilter<$PrismaModel> | $Enums.ArchiveStatus
  }

  export type NestedEnumArchiveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArchiveStatus | EnumArchiveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArchiveStatus[] | ListEnumArchiveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArchiveStatus[] | ListEnumArchiveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArchiveStatusWithAggregatesFilter<$PrismaModel> | $Enums.ArchiveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArchiveStatusFilter<$PrismaModel>
    _max?: NestedEnumArchiveStatusFilter<$PrismaModel>
  }

  export type NestedEnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPersonalityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalityTypeFilter<$PrismaModel> | $Enums.PersonalityType
  }

  export type NestedEnumEmotionalStateFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalState | EnumEmotionalStateFieldRefInput<$PrismaModel>
    in?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel>
    not?: NestedEnumEmotionalStateFilter<$PrismaModel> | $Enums.EmotionalState
  }

  export type NestedEnumDecisionMakingStyleFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionMakingStyle | EnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionMakingStyleFilter<$PrismaModel> | $Enums.DecisionMakingStyle
  }

  export type NestedEnumPersonalityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonalityType[] | ListEnumPersonalityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonalityTypeWithAggregatesFilter<$PrismaModel> | $Enums.PersonalityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonalityTypeFilter<$PrismaModel>
    _max?: NestedEnumPersonalityTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmotionalStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmotionalState | EnumEmotionalStateFieldRefInput<$PrismaModel>
    in?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmotionalState[] | ListEnumEmotionalStateFieldRefInput<$PrismaModel>
    not?: NestedEnumEmotionalStateWithAggregatesFilter<$PrismaModel> | $Enums.EmotionalState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmotionalStateFilter<$PrismaModel>
    _max?: NestedEnumEmotionalStateFilter<$PrismaModel>
  }

  export type NestedEnumDecisionMakingStyleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DecisionMakingStyle | EnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    in?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    notIn?: $Enums.DecisionMakingStyle[] | ListEnumDecisionMakingStyleFieldRefInput<$PrismaModel>
    not?: NestedEnumDecisionMakingStyleWithAggregatesFilter<$PrismaModel> | $Enums.DecisionMakingStyle
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDecisionMakingStyleFilter<$PrismaModel>
    _max?: NestedEnumDecisionMakingStyleFilter<$PrismaModel>
  }

  export type InteractionCreateWithoutSessionInput = {
    id?: string
    type: $Enums.InteractionType
    timestamp: bigint | number
    sessionTime: number
    primarySelector: string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: string | null
    cssPath?: string | null
    elementTag: string
    elementText?: string | null
    elementValue?: string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: number | null
    clientY?: number | null
    pageX?: number | null
    pageY?: number | null
    boundingBox: JsonNullValueInput | InputJsonValue
    viewport: JsonNullValueInput | InputJsonValue
    isInViewport?: boolean
    percentVisible?: number
    url: string
    pageTitle: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: string | null
    userReasoning?: string | null
    visualCues?: JsonNullValueInput | InputJsonValue
    relatedScreenshots?: ScreenshotCreateNestedManyWithoutInteractionInput
  }

  export type InteractionUncheckedCreateWithoutSessionInput = {
    id?: string
    type: $Enums.InteractionType
    timestamp: bigint | number
    sessionTime: number
    primarySelector: string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: string | null
    cssPath?: string | null
    elementTag: string
    elementText?: string | null
    elementValue?: string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: number | null
    clientY?: number | null
    pageX?: number | null
    pageY?: number | null
    boundingBox: JsonNullValueInput | InputJsonValue
    viewport: JsonNullValueInput | InputJsonValue
    isInViewport?: boolean
    percentVisible?: number
    url: string
    pageTitle: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: string | null
    userReasoning?: string | null
    visualCues?: JsonNullValueInput | InputJsonValue
    relatedScreenshots?: ScreenshotUncheckedCreateNestedManyWithoutInteractionInput
  }

  export type InteractionCreateOrConnectWithoutSessionInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutSessionInput, InteractionUncheckedCreateWithoutSessionInput>
  }

  export type InteractionCreateManySessionInputEnvelope = {
    data: InteractionCreateManySessionInput | InteractionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ScreenshotCreateWithoutSessionInput = {
    id?: string
    timestamp: bigint | number
    eventType: string
    s3Key?: string | null
    dataUrl?: string | null
    compressed?: boolean
    format?: string
    fileSize?: number | null
    viewport: JsonNullValueInput | InputJsonValue
    quality?: number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
    interaction?: InteractionCreateNestedOneWithoutRelatedScreenshotsInput
  }

  export type ScreenshotUncheckedCreateWithoutSessionInput = {
    id?: string
    interactionId?: string | null
    timestamp: bigint | number
    eventType: string
    s3Key?: string | null
    dataUrl?: string | null
    compressed?: boolean
    format?: string
    fileSize?: number | null
    viewport: JsonNullValueInput | InputJsonValue
    quality?: number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScreenshotCreateOrConnectWithoutSessionInput = {
    where: ScreenshotWhereUniqueInput
    create: XOR<ScreenshotCreateWithoutSessionInput, ScreenshotUncheckedCreateWithoutSessionInput>
  }

  export type ScreenshotCreateManySessionInputEnvelope = {
    data: ScreenshotCreateManySessionInput | ScreenshotCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SessionArchiveCreateWithoutSessionInput = {
    id?: string
    version?: string
    format?: string
    s3Bucket: string
    s3Key: string
    fileSize: bigint | number
    checksum: string
    manifest: JsonNullValueInput | InputJsonValue
    compressionRatio?: number | null
    status?: $Enums.ArchiveStatus
    createdAt?: Date | string
  }

  export type SessionArchiveUncheckedCreateWithoutSessionInput = {
    id?: string
    version?: string
    format?: string
    s3Bucket: string
    s3Key: string
    fileSize: bigint | number
    checksum: string
    manifest: JsonNullValueInput | InputJsonValue
    compressionRatio?: number | null
    status?: $Enums.ArchiveStatus
    createdAt?: Date | string
  }

  export type SessionArchiveCreateOrConnectWithoutSessionInput = {
    where: SessionArchiveWhereUniqueInput
    create: XOR<SessionArchiveCreateWithoutSessionInput, SessionArchiveUncheckedCreateWithoutSessionInput>
  }

  export type SessionArchiveCreateManySessionInputEnvelope = {
    data: SessionArchiveCreateManySessionInput | SessionArchiveCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type InteractionUpsertWithWhereUniqueWithoutSessionInput = {
    where: InteractionWhereUniqueInput
    update: XOR<InteractionUpdateWithoutSessionInput, InteractionUncheckedUpdateWithoutSessionInput>
    create: XOR<InteractionCreateWithoutSessionInput, InteractionUncheckedCreateWithoutSessionInput>
  }

  export type InteractionUpdateWithWhereUniqueWithoutSessionInput = {
    where: InteractionWhereUniqueInput
    data: XOR<InteractionUpdateWithoutSessionInput, InteractionUncheckedUpdateWithoutSessionInput>
  }

  export type InteractionUpdateManyWithWhereWithoutSessionInput = {
    where: InteractionScalarWhereInput
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyWithoutSessionInput>
  }

  export type InteractionScalarWhereInput = {
    AND?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    OR?: InteractionScalarWhereInput[]
    NOT?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    id?: StringFilter<"Interaction"> | string
    sessionId?: StringFilter<"Interaction"> | string
    type?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    timestamp?: BigIntFilter<"Interaction"> | bigint | number
    sessionTime?: IntFilter<"Interaction"> | number
    primarySelector?: StringFilter<"Interaction"> | string
    selectorAlternatives?: JsonFilter<"Interaction">
    xpath?: StringNullableFilter<"Interaction"> | string | null
    cssPath?: StringNullableFilter<"Interaction"> | string | null
    elementTag?: StringFilter<"Interaction"> | string
    elementText?: StringNullableFilter<"Interaction"> | string | null
    elementValue?: StringNullableFilter<"Interaction"> | string | null
    elementAttributes?: JsonFilter<"Interaction">
    clientX?: IntNullableFilter<"Interaction"> | number | null
    clientY?: IntNullableFilter<"Interaction"> | number | null
    pageX?: IntNullableFilter<"Interaction"> | number | null
    pageY?: IntNullableFilter<"Interaction"> | number | null
    boundingBox?: JsonFilter<"Interaction">
    viewport?: JsonFilter<"Interaction">
    isInViewport?: BoolFilter<"Interaction"> | boolean
    percentVisible?: FloatFilter<"Interaction"> | number
    url?: StringFilter<"Interaction"> | string
    pageTitle?: StringFilter<"Interaction"> | string
    pageStructure?: JsonFilter<"Interaction">
    parentElements?: JsonFilter<"Interaction">
    siblingElements?: JsonFilter<"Interaction">
    nearbyElements?: JsonFilter<"Interaction">
    stateBefore?: JsonFilter<"Interaction">
    stateAfter?: JsonNullableFilter<"Interaction">
    stateChanges?: JsonFilter<"Interaction">
    confidence?: FloatFilter<"Interaction"> | number
    selectorReliability?: JsonFilter<"Interaction">
    userIntent?: StringNullableFilter<"Interaction"> | string | null
    userReasoning?: StringNullableFilter<"Interaction"> | string | null
    visualCues?: JsonFilter<"Interaction">
  }

  export type ScreenshotUpsertWithWhereUniqueWithoutSessionInput = {
    where: ScreenshotWhereUniqueInput
    update: XOR<ScreenshotUpdateWithoutSessionInput, ScreenshotUncheckedUpdateWithoutSessionInput>
    create: XOR<ScreenshotCreateWithoutSessionInput, ScreenshotUncheckedCreateWithoutSessionInput>
  }

  export type ScreenshotUpdateWithWhereUniqueWithoutSessionInput = {
    where: ScreenshotWhereUniqueInput
    data: XOR<ScreenshotUpdateWithoutSessionInput, ScreenshotUncheckedUpdateWithoutSessionInput>
  }

  export type ScreenshotUpdateManyWithWhereWithoutSessionInput = {
    where: ScreenshotScalarWhereInput
    data: XOR<ScreenshotUpdateManyMutationInput, ScreenshotUncheckedUpdateManyWithoutSessionInput>
  }

  export type ScreenshotScalarWhereInput = {
    AND?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[]
    OR?: ScreenshotScalarWhereInput[]
    NOT?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[]
    id?: StringFilter<"Screenshot"> | string
    sessionId?: StringFilter<"Screenshot"> | string
    interactionId?: StringNullableFilter<"Screenshot"> | string | null
    timestamp?: BigIntFilter<"Screenshot"> | bigint | number
    eventType?: StringFilter<"Screenshot"> | string
    s3Key?: StringNullableFilter<"Screenshot"> | string | null
    dataUrl?: StringNullableFilter<"Screenshot"> | string | null
    compressed?: BoolFilter<"Screenshot"> | boolean
    format?: StringFilter<"Screenshot"> | string
    fileSize?: IntNullableFilter<"Screenshot"> | number | null
    viewport?: JsonFilter<"Screenshot">
    quality?: FloatFilter<"Screenshot"> | number
    visionAnalysis?: JsonNullableFilter<"Screenshot">
    userPsychology?: JsonNullableFilter<"Screenshot">
  }

  export type SessionArchiveUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionArchiveWhereUniqueInput
    update: XOR<SessionArchiveUpdateWithoutSessionInput, SessionArchiveUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionArchiveCreateWithoutSessionInput, SessionArchiveUncheckedCreateWithoutSessionInput>
  }

  export type SessionArchiveUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionArchiveWhereUniqueInput
    data: XOR<SessionArchiveUpdateWithoutSessionInput, SessionArchiveUncheckedUpdateWithoutSessionInput>
  }

  export type SessionArchiveUpdateManyWithWhereWithoutSessionInput = {
    where: SessionArchiveScalarWhereInput
    data: XOR<SessionArchiveUpdateManyMutationInput, SessionArchiveUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionArchiveScalarWhereInput = {
    AND?: SessionArchiveScalarWhereInput | SessionArchiveScalarWhereInput[]
    OR?: SessionArchiveScalarWhereInput[]
    NOT?: SessionArchiveScalarWhereInput | SessionArchiveScalarWhereInput[]
    id?: StringFilter<"SessionArchive"> | string
    sessionId?: StringFilter<"SessionArchive"> | string
    version?: StringFilter<"SessionArchive"> | string
    format?: StringFilter<"SessionArchive"> | string
    s3Bucket?: StringFilter<"SessionArchive"> | string
    s3Key?: StringFilter<"SessionArchive"> | string
    fileSize?: BigIntFilter<"SessionArchive"> | bigint | number
    checksum?: StringFilter<"SessionArchive"> | string
    manifest?: JsonFilter<"SessionArchive">
    compressionRatio?: FloatNullableFilter<"SessionArchive"> | number | null
    status?: EnumArchiveStatusFilter<"SessionArchive"> | $Enums.ArchiveStatus
    createdAt?: DateTimeFilter<"SessionArchive"> | Date | string
  }

  export type UnifiedSessionCreateWithoutInteractionsInput = {
    id?: string
    type?: $Enums.SessionType
    status?: $Enums.SessionStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    archiveUrl?: string | null
    trainingFileId?: string | null
    modelId?: string | null
    qualityScore?: number
    completeness?: number
    reliability?: number
    trainingValue?: number
    processingStatus?: $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: $Enums.PersonalityType | null
    emotionalState?: $Enums.EmotionalState | null
    decisionMakingStyle?: $Enums.DecisionMakingStyle | null
    trustLevel?: number | null
    urgencyLevel?: number | null
    priceSensitivity?: number | null
    socialInfluence?: number | null
    psychologyConfidence?: number | null
    pageType?: string | null
    userIntent?: string | null
    shoppingStage?: string | null
    behaviorType?: string | null
    purchaseReadiness?: number | null
    navigationEfficiency?: number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    screenshots?: ScreenshotCreateNestedManyWithoutSessionInput
    archives?: SessionArchiveCreateNestedManyWithoutSessionInput
  }

  export type UnifiedSessionUncheckedCreateWithoutInteractionsInput = {
    id?: string
    type?: $Enums.SessionType
    status?: $Enums.SessionStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    archiveUrl?: string | null
    trainingFileId?: string | null
    modelId?: string | null
    qualityScore?: number
    completeness?: number
    reliability?: number
    trainingValue?: number
    processingStatus?: $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: $Enums.PersonalityType | null
    emotionalState?: $Enums.EmotionalState | null
    decisionMakingStyle?: $Enums.DecisionMakingStyle | null
    trustLevel?: number | null
    urgencyLevel?: number | null
    priceSensitivity?: number | null
    socialInfluence?: number | null
    psychologyConfidence?: number | null
    pageType?: string | null
    userIntent?: string | null
    shoppingStage?: string | null
    behaviorType?: string | null
    purchaseReadiness?: number | null
    navigationEfficiency?: number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutSessionInput
    archives?: SessionArchiveUncheckedCreateNestedManyWithoutSessionInput
  }

  export type UnifiedSessionCreateOrConnectWithoutInteractionsInput = {
    where: UnifiedSessionWhereUniqueInput
    create: XOR<UnifiedSessionCreateWithoutInteractionsInput, UnifiedSessionUncheckedCreateWithoutInteractionsInput>
  }

  export type ScreenshotCreateWithoutInteractionInput = {
    id?: string
    timestamp: bigint | number
    eventType: string
    s3Key?: string | null
    dataUrl?: string | null
    compressed?: boolean
    format?: string
    fileSize?: number | null
    viewport: JsonNullValueInput | InputJsonValue
    quality?: number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
    session: UnifiedSessionCreateNestedOneWithoutScreenshotsInput
  }

  export type ScreenshotUncheckedCreateWithoutInteractionInput = {
    id?: string
    sessionId: string
    timestamp: bigint | number
    eventType: string
    s3Key?: string | null
    dataUrl?: string | null
    compressed?: boolean
    format?: string
    fileSize?: number | null
    viewport: JsonNullValueInput | InputJsonValue
    quality?: number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScreenshotCreateOrConnectWithoutInteractionInput = {
    where: ScreenshotWhereUniqueInput
    create: XOR<ScreenshotCreateWithoutInteractionInput, ScreenshotUncheckedCreateWithoutInteractionInput>
  }

  export type ScreenshotCreateManyInteractionInputEnvelope = {
    data: ScreenshotCreateManyInteractionInput | ScreenshotCreateManyInteractionInput[]
    skipDuplicates?: boolean
  }

  export type UnifiedSessionUpsertWithoutInteractionsInput = {
    update: XOR<UnifiedSessionUpdateWithoutInteractionsInput, UnifiedSessionUncheckedUpdateWithoutInteractionsInput>
    create: XOR<UnifiedSessionCreateWithoutInteractionsInput, UnifiedSessionUncheckedCreateWithoutInteractionsInput>
    where?: UnifiedSessionWhereInput
  }

  export type UnifiedSessionUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: UnifiedSessionWhereInput
    data: XOR<UnifiedSessionUpdateWithoutInteractionsInput, UnifiedSessionUncheckedUpdateWithoutInteractionsInput>
  }

  export type UnifiedSessionUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    archiveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trainingFileId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    reliability?: FloatFieldUpdateOperationsInput | number
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    emotionalState?: NullableEnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState | null
    decisionMakingStyle?: NullableEnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle | null
    trustLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    urgencyLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    priceSensitivity?: NullableFloatFieldUpdateOperationsInput | number | null
    socialInfluence?: NullableFloatFieldUpdateOperationsInput | number | null
    psychologyConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pageType?: NullableStringFieldUpdateOperationsInput | string | null
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingStage?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseReadiness?: NullableFloatFieldUpdateOperationsInput | number | null
    navigationEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    screenshots?: ScreenshotUpdateManyWithoutSessionNestedInput
    archives?: SessionArchiveUpdateManyWithoutSessionNestedInput
  }

  export type UnifiedSessionUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    archiveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trainingFileId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    reliability?: FloatFieldUpdateOperationsInput | number
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    emotionalState?: NullableEnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState | null
    decisionMakingStyle?: NullableEnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle | null
    trustLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    urgencyLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    priceSensitivity?: NullableFloatFieldUpdateOperationsInput | number | null
    socialInfluence?: NullableFloatFieldUpdateOperationsInput | number | null
    psychologyConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pageType?: NullableStringFieldUpdateOperationsInput | string | null
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingStage?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseReadiness?: NullableFloatFieldUpdateOperationsInput | number | null
    navigationEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    screenshots?: ScreenshotUncheckedUpdateManyWithoutSessionNestedInput
    archives?: SessionArchiveUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ScreenshotUpsertWithWhereUniqueWithoutInteractionInput = {
    where: ScreenshotWhereUniqueInput
    update: XOR<ScreenshotUpdateWithoutInteractionInput, ScreenshotUncheckedUpdateWithoutInteractionInput>
    create: XOR<ScreenshotCreateWithoutInteractionInput, ScreenshotUncheckedCreateWithoutInteractionInput>
  }

  export type ScreenshotUpdateWithWhereUniqueWithoutInteractionInput = {
    where: ScreenshotWhereUniqueInput
    data: XOR<ScreenshotUpdateWithoutInteractionInput, ScreenshotUncheckedUpdateWithoutInteractionInput>
  }

  export type ScreenshotUpdateManyWithWhereWithoutInteractionInput = {
    where: ScreenshotScalarWhereInput
    data: XOR<ScreenshotUpdateManyMutationInput, ScreenshotUncheckedUpdateManyWithoutInteractionInput>
  }

  export type UnifiedSessionCreateWithoutScreenshotsInput = {
    id?: string
    type?: $Enums.SessionType
    status?: $Enums.SessionStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    archiveUrl?: string | null
    trainingFileId?: string | null
    modelId?: string | null
    qualityScore?: number
    completeness?: number
    reliability?: number
    trainingValue?: number
    processingStatus?: $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: $Enums.PersonalityType | null
    emotionalState?: $Enums.EmotionalState | null
    decisionMakingStyle?: $Enums.DecisionMakingStyle | null
    trustLevel?: number | null
    urgencyLevel?: number | null
    priceSensitivity?: number | null
    socialInfluence?: number | null
    psychologyConfidence?: number | null
    pageType?: string | null
    userIntent?: string | null
    shoppingStage?: string | null
    behaviorType?: string | null
    purchaseReadiness?: number | null
    navigationEfficiency?: number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionCreateNestedManyWithoutSessionInput
    archives?: SessionArchiveCreateNestedManyWithoutSessionInput
  }

  export type UnifiedSessionUncheckedCreateWithoutScreenshotsInput = {
    id?: string
    type?: $Enums.SessionType
    status?: $Enums.SessionStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    archiveUrl?: string | null
    trainingFileId?: string | null
    modelId?: string | null
    qualityScore?: number
    completeness?: number
    reliability?: number
    trainingValue?: number
    processingStatus?: $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: $Enums.PersonalityType | null
    emotionalState?: $Enums.EmotionalState | null
    decisionMakingStyle?: $Enums.DecisionMakingStyle | null
    trustLevel?: number | null
    urgencyLevel?: number | null
    priceSensitivity?: number | null
    socialInfluence?: number | null
    psychologyConfidence?: number | null
    pageType?: string | null
    userIntent?: string | null
    shoppingStage?: string | null
    behaviorType?: string | null
    purchaseReadiness?: number | null
    navigationEfficiency?: number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutSessionInput
    archives?: SessionArchiveUncheckedCreateNestedManyWithoutSessionInput
  }

  export type UnifiedSessionCreateOrConnectWithoutScreenshotsInput = {
    where: UnifiedSessionWhereUniqueInput
    create: XOR<UnifiedSessionCreateWithoutScreenshotsInput, UnifiedSessionUncheckedCreateWithoutScreenshotsInput>
  }

  export type InteractionCreateWithoutRelatedScreenshotsInput = {
    id?: string
    type: $Enums.InteractionType
    timestamp: bigint | number
    sessionTime: number
    primarySelector: string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: string | null
    cssPath?: string | null
    elementTag: string
    elementText?: string | null
    elementValue?: string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: number | null
    clientY?: number | null
    pageX?: number | null
    pageY?: number | null
    boundingBox: JsonNullValueInput | InputJsonValue
    viewport: JsonNullValueInput | InputJsonValue
    isInViewport?: boolean
    percentVisible?: number
    url: string
    pageTitle: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: string | null
    userReasoning?: string | null
    visualCues?: JsonNullValueInput | InputJsonValue
    session: UnifiedSessionCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionUncheckedCreateWithoutRelatedScreenshotsInput = {
    id?: string
    sessionId: string
    type: $Enums.InteractionType
    timestamp: bigint | number
    sessionTime: number
    primarySelector: string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: string | null
    cssPath?: string | null
    elementTag: string
    elementText?: string | null
    elementValue?: string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: number | null
    clientY?: number | null
    pageX?: number | null
    pageY?: number | null
    boundingBox: JsonNullValueInput | InputJsonValue
    viewport: JsonNullValueInput | InputJsonValue
    isInViewport?: boolean
    percentVisible?: number
    url: string
    pageTitle: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: string | null
    userReasoning?: string | null
    visualCues?: JsonNullValueInput | InputJsonValue
  }

  export type InteractionCreateOrConnectWithoutRelatedScreenshotsInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutRelatedScreenshotsInput, InteractionUncheckedCreateWithoutRelatedScreenshotsInput>
  }

  export type UnifiedSessionUpsertWithoutScreenshotsInput = {
    update: XOR<UnifiedSessionUpdateWithoutScreenshotsInput, UnifiedSessionUncheckedUpdateWithoutScreenshotsInput>
    create: XOR<UnifiedSessionCreateWithoutScreenshotsInput, UnifiedSessionUncheckedCreateWithoutScreenshotsInput>
    where?: UnifiedSessionWhereInput
  }

  export type UnifiedSessionUpdateToOneWithWhereWithoutScreenshotsInput = {
    where?: UnifiedSessionWhereInput
    data: XOR<UnifiedSessionUpdateWithoutScreenshotsInput, UnifiedSessionUncheckedUpdateWithoutScreenshotsInput>
  }

  export type UnifiedSessionUpdateWithoutScreenshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    archiveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trainingFileId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    reliability?: FloatFieldUpdateOperationsInput | number
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    emotionalState?: NullableEnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState | null
    decisionMakingStyle?: NullableEnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle | null
    trustLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    urgencyLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    priceSensitivity?: NullableFloatFieldUpdateOperationsInput | number | null
    socialInfluence?: NullableFloatFieldUpdateOperationsInput | number | null
    psychologyConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pageType?: NullableStringFieldUpdateOperationsInput | string | null
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingStage?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseReadiness?: NullableFloatFieldUpdateOperationsInput | number | null
    navigationEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUpdateManyWithoutSessionNestedInput
    archives?: SessionArchiveUpdateManyWithoutSessionNestedInput
  }

  export type UnifiedSessionUncheckedUpdateWithoutScreenshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    archiveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trainingFileId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    reliability?: FloatFieldUpdateOperationsInput | number
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    emotionalState?: NullableEnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState | null
    decisionMakingStyle?: NullableEnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle | null
    trustLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    urgencyLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    priceSensitivity?: NullableFloatFieldUpdateOperationsInput | number | null
    socialInfluence?: NullableFloatFieldUpdateOperationsInput | number | null
    psychologyConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pageType?: NullableStringFieldUpdateOperationsInput | string | null
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingStage?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseReadiness?: NullableFloatFieldUpdateOperationsInput | number | null
    navigationEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutSessionNestedInput
    archives?: SessionArchiveUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InteractionUpsertWithoutRelatedScreenshotsInput = {
    update: XOR<InteractionUpdateWithoutRelatedScreenshotsInput, InteractionUncheckedUpdateWithoutRelatedScreenshotsInput>
    create: XOR<InteractionCreateWithoutRelatedScreenshotsInput, InteractionUncheckedCreateWithoutRelatedScreenshotsInput>
    where?: InteractionWhereInput
  }

  export type InteractionUpdateToOneWithWhereWithoutRelatedScreenshotsInput = {
    where?: InteractionWhereInput
    data: XOR<InteractionUpdateWithoutRelatedScreenshotsInput, InteractionUncheckedUpdateWithoutRelatedScreenshotsInput>
  }

  export type InteractionUpdateWithoutRelatedScreenshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionTime?: IntFieldUpdateOperationsInput | number
    primarySelector?: StringFieldUpdateOperationsInput | string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: NullableStringFieldUpdateOperationsInput | string | null
    cssPath?: NullableStringFieldUpdateOperationsInput | string | null
    elementTag?: StringFieldUpdateOperationsInput | string
    elementText?: NullableStringFieldUpdateOperationsInput | string | null
    elementValue?: NullableStringFieldUpdateOperationsInput | string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: NullableIntFieldUpdateOperationsInput | number | null
    clientY?: NullableIntFieldUpdateOperationsInput | number | null
    pageX?: NullableIntFieldUpdateOperationsInput | number | null
    pageY?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: JsonNullValueInput | InputJsonValue
    viewport?: JsonNullValueInput | InputJsonValue
    isInViewport?: BoolFieldUpdateOperationsInput | boolean
    percentVisible?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    pageTitle?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    userReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    visualCues?: JsonNullValueInput | InputJsonValue
    session?: UnifiedSessionUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type InteractionUncheckedUpdateWithoutRelatedScreenshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionTime?: IntFieldUpdateOperationsInput | number
    primarySelector?: StringFieldUpdateOperationsInput | string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: NullableStringFieldUpdateOperationsInput | string | null
    cssPath?: NullableStringFieldUpdateOperationsInput | string | null
    elementTag?: StringFieldUpdateOperationsInput | string
    elementText?: NullableStringFieldUpdateOperationsInput | string | null
    elementValue?: NullableStringFieldUpdateOperationsInput | string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: NullableIntFieldUpdateOperationsInput | number | null
    clientY?: NullableIntFieldUpdateOperationsInput | number | null
    pageX?: NullableIntFieldUpdateOperationsInput | number | null
    pageY?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: JsonNullValueInput | InputJsonValue
    viewport?: JsonNullValueInput | InputJsonValue
    isInViewport?: BoolFieldUpdateOperationsInput | boolean
    percentVisible?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    pageTitle?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    userReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    visualCues?: JsonNullValueInput | InputJsonValue
  }

  export type UnifiedSessionCreateWithoutArchivesInput = {
    id?: string
    type?: $Enums.SessionType
    status?: $Enums.SessionStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    archiveUrl?: string | null
    trainingFileId?: string | null
    modelId?: string | null
    qualityScore?: number
    completeness?: number
    reliability?: number
    trainingValue?: number
    processingStatus?: $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: $Enums.PersonalityType | null
    emotionalState?: $Enums.EmotionalState | null
    decisionMakingStyle?: $Enums.DecisionMakingStyle | null
    trustLevel?: number | null
    urgencyLevel?: number | null
    priceSensitivity?: number | null
    socialInfluence?: number | null
    psychologyConfidence?: number | null
    pageType?: string | null
    userIntent?: string | null
    shoppingStage?: string | null
    behaviorType?: string | null
    purchaseReadiness?: number | null
    navigationEfficiency?: number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionCreateNestedManyWithoutSessionInput
    screenshots?: ScreenshotCreateNestedManyWithoutSessionInput
  }

  export type UnifiedSessionUncheckedCreateWithoutArchivesInput = {
    id?: string
    type?: $Enums.SessionType
    status?: $Enums.SessionStatus
    startTime?: Date | string
    endTime?: Date | string | null
    duration?: number | null
    archiveUrl?: string | null
    trainingFileId?: string | null
    modelId?: string | null
    qualityScore?: number
    completeness?: number
    reliability?: number
    trainingValue?: number
    processingStatus?: $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: string | null
    userAgent?: string | null
    ipAddress?: string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: $Enums.PersonalityType | null
    emotionalState?: $Enums.EmotionalState | null
    decisionMakingStyle?: $Enums.DecisionMakingStyle | null
    trustLevel?: number | null
    urgencyLevel?: number | null
    priceSensitivity?: number | null
    socialInfluence?: number | null
    psychologyConfidence?: number | null
    pageType?: string | null
    userIntent?: string | null
    shoppingStage?: string | null
    behaviorType?: string | null
    purchaseReadiness?: number | null
    navigationEfficiency?: number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutSessionInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutSessionInput
  }

  export type UnifiedSessionCreateOrConnectWithoutArchivesInput = {
    where: UnifiedSessionWhereUniqueInput
    create: XOR<UnifiedSessionCreateWithoutArchivesInput, UnifiedSessionUncheckedCreateWithoutArchivesInput>
  }

  export type UnifiedSessionUpsertWithoutArchivesInput = {
    update: XOR<UnifiedSessionUpdateWithoutArchivesInput, UnifiedSessionUncheckedUpdateWithoutArchivesInput>
    create: XOR<UnifiedSessionCreateWithoutArchivesInput, UnifiedSessionUncheckedCreateWithoutArchivesInput>
    where?: UnifiedSessionWhereInput
  }

  export type UnifiedSessionUpdateToOneWithWhereWithoutArchivesInput = {
    where?: UnifiedSessionWhereInput
    data: XOR<UnifiedSessionUpdateWithoutArchivesInput, UnifiedSessionUncheckedUpdateWithoutArchivesInput>
  }

  export type UnifiedSessionUpdateWithoutArchivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    archiveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trainingFileId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    reliability?: FloatFieldUpdateOperationsInput | number
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    emotionalState?: NullableEnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState | null
    decisionMakingStyle?: NullableEnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle | null
    trustLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    urgencyLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    priceSensitivity?: NullableFloatFieldUpdateOperationsInput | number | null
    socialInfluence?: NullableFloatFieldUpdateOperationsInput | number | null
    psychologyConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pageType?: NullableStringFieldUpdateOperationsInput | string | null
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingStage?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseReadiness?: NullableFloatFieldUpdateOperationsInput | number | null
    navigationEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUpdateManyWithoutSessionNestedInput
    screenshots?: ScreenshotUpdateManyWithoutSessionNestedInput
  }

  export type UnifiedSessionUncheckedUpdateWithoutArchivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSessionTypeFieldUpdateOperationsInput | $Enums.SessionType
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    archiveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    trainingFileId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: NullableStringFieldUpdateOperationsInput | string | null
    qualityScore?: FloatFieldUpdateOperationsInput | number
    completeness?: FloatFieldUpdateOperationsInput | number
    reliability?: FloatFieldUpdateOperationsInput | number
    trainingValue?: FloatFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    processingSteps?: JsonNullValueInput | InputJsonValue
    processingErrors?: JsonNullValueInput | InputJsonValue
    config?: JsonNullValueInput | InputJsonValue
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    trainingMetrics?: NullableJsonNullValueInput | InputJsonValue
    modelPerformance?: NullableJsonNullValueInput | InputJsonValue
    dominantPersonality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    emotionalState?: NullableEnumEmotionalStateFieldUpdateOperationsInput | $Enums.EmotionalState | null
    decisionMakingStyle?: NullableEnumDecisionMakingStyleFieldUpdateOperationsInput | $Enums.DecisionMakingStyle | null
    trustLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    urgencyLevel?: NullableFloatFieldUpdateOperationsInput | number | null
    priceSensitivity?: NullableFloatFieldUpdateOperationsInput | number | null
    socialInfluence?: NullableFloatFieldUpdateOperationsInput | number | null
    psychologyConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    pageType?: NullableStringFieldUpdateOperationsInput | string | null
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingStage?: NullableStringFieldUpdateOperationsInput | string | null
    behaviorType?: NullableStringFieldUpdateOperationsInput | string | null
    purchaseReadiness?: NullableFloatFieldUpdateOperationsInput | number | null
    navigationEfficiency?: NullableFloatFieldUpdateOperationsInput | number | null
    contextualInsights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutSessionNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InteractionCreateManySessionInput = {
    id?: string
    type: $Enums.InteractionType
    timestamp: bigint | number
    sessionTime: number
    primarySelector: string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: string | null
    cssPath?: string | null
    elementTag: string
    elementText?: string | null
    elementValue?: string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: number | null
    clientY?: number | null
    pageX?: number | null
    pageY?: number | null
    boundingBox: JsonNullValueInput | InputJsonValue
    viewport: JsonNullValueInput | InputJsonValue
    isInViewport?: boolean
    percentVisible?: number
    url: string
    pageTitle: string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: string | null
    userReasoning?: string | null
    visualCues?: JsonNullValueInput | InputJsonValue
  }

  export type ScreenshotCreateManySessionInput = {
    id?: string
    interactionId?: string | null
    timestamp: bigint | number
    eventType: string
    s3Key?: string | null
    dataUrl?: string | null
    compressed?: boolean
    format?: string
    fileSize?: number | null
    viewport: JsonNullValueInput | InputJsonValue
    quality?: number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionArchiveCreateManySessionInput = {
    id?: string
    version?: string
    format?: string
    s3Bucket: string
    s3Key: string
    fileSize: bigint | number
    checksum: string
    manifest: JsonNullValueInput | InputJsonValue
    compressionRatio?: number | null
    status?: $Enums.ArchiveStatus
    createdAt?: Date | string
  }

  export type InteractionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionTime?: IntFieldUpdateOperationsInput | number
    primarySelector?: StringFieldUpdateOperationsInput | string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: NullableStringFieldUpdateOperationsInput | string | null
    cssPath?: NullableStringFieldUpdateOperationsInput | string | null
    elementTag?: StringFieldUpdateOperationsInput | string
    elementText?: NullableStringFieldUpdateOperationsInput | string | null
    elementValue?: NullableStringFieldUpdateOperationsInput | string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: NullableIntFieldUpdateOperationsInput | number | null
    clientY?: NullableIntFieldUpdateOperationsInput | number | null
    pageX?: NullableIntFieldUpdateOperationsInput | number | null
    pageY?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: JsonNullValueInput | InputJsonValue
    viewport?: JsonNullValueInput | InputJsonValue
    isInViewport?: BoolFieldUpdateOperationsInput | boolean
    percentVisible?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    pageTitle?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    userReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    visualCues?: JsonNullValueInput | InputJsonValue
    relatedScreenshots?: ScreenshotUpdateManyWithoutInteractionNestedInput
  }

  export type InteractionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionTime?: IntFieldUpdateOperationsInput | number
    primarySelector?: StringFieldUpdateOperationsInput | string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: NullableStringFieldUpdateOperationsInput | string | null
    cssPath?: NullableStringFieldUpdateOperationsInput | string | null
    elementTag?: StringFieldUpdateOperationsInput | string
    elementText?: NullableStringFieldUpdateOperationsInput | string | null
    elementValue?: NullableStringFieldUpdateOperationsInput | string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: NullableIntFieldUpdateOperationsInput | number | null
    clientY?: NullableIntFieldUpdateOperationsInput | number | null
    pageX?: NullableIntFieldUpdateOperationsInput | number | null
    pageY?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: JsonNullValueInput | InputJsonValue
    viewport?: JsonNullValueInput | InputJsonValue
    isInViewport?: BoolFieldUpdateOperationsInput | boolean
    percentVisible?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    pageTitle?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    userReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    visualCues?: JsonNullValueInput | InputJsonValue
    relatedScreenshots?: ScreenshotUncheckedUpdateManyWithoutInteractionNestedInput
  }

  export type InteractionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    sessionTime?: IntFieldUpdateOperationsInput | number
    primarySelector?: StringFieldUpdateOperationsInput | string
    selectorAlternatives?: JsonNullValueInput | InputJsonValue
    xpath?: NullableStringFieldUpdateOperationsInput | string | null
    cssPath?: NullableStringFieldUpdateOperationsInput | string | null
    elementTag?: StringFieldUpdateOperationsInput | string
    elementText?: NullableStringFieldUpdateOperationsInput | string | null
    elementValue?: NullableStringFieldUpdateOperationsInput | string | null
    elementAttributes?: JsonNullValueInput | InputJsonValue
    clientX?: NullableIntFieldUpdateOperationsInput | number | null
    clientY?: NullableIntFieldUpdateOperationsInput | number | null
    pageX?: NullableIntFieldUpdateOperationsInput | number | null
    pageY?: NullableIntFieldUpdateOperationsInput | number | null
    boundingBox?: JsonNullValueInput | InputJsonValue
    viewport?: JsonNullValueInput | InputJsonValue
    isInViewport?: BoolFieldUpdateOperationsInput | boolean
    percentVisible?: FloatFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    pageTitle?: StringFieldUpdateOperationsInput | string
    pageStructure?: JsonNullValueInput | InputJsonValue
    parentElements?: JsonNullValueInput | InputJsonValue
    siblingElements?: JsonNullValueInput | InputJsonValue
    nearbyElements?: JsonNullValueInput | InputJsonValue
    stateBefore?: JsonNullValueInput | InputJsonValue
    stateAfter?: NullableJsonNullValueInput | InputJsonValue
    stateChanges?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    selectorReliability?: JsonNullValueInput | InputJsonValue
    userIntent?: NullableStringFieldUpdateOperationsInput | string | null
    userReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    visualCues?: JsonNullValueInput | InputJsonValue
  }

  export type ScreenshotUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    dataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    compressed?: BoolFieldUpdateOperationsInput | boolean
    format?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    viewport?: JsonNullValueInput | InputJsonValue
    quality?: FloatFieldUpdateOperationsInput | number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
    interaction?: InteractionUpdateOneWithoutRelatedScreenshotsNestedInput
  }

  export type ScreenshotUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    dataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    compressed?: BoolFieldUpdateOperationsInput | boolean
    format?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    viewport?: JsonNullValueInput | InputJsonValue
    quality?: FloatFieldUpdateOperationsInput | number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScreenshotUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    interactionId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    dataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    compressed?: BoolFieldUpdateOperationsInput | boolean
    format?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    viewport?: JsonNullValueInput | InputJsonValue
    quality?: FloatFieldUpdateOperationsInput | number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SessionArchiveUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: StringFieldUpdateOperationsInput | string
    manifest?: JsonNullValueInput | InputJsonValue
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumArchiveStatusFieldUpdateOperationsInput | $Enums.ArchiveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionArchiveUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: StringFieldUpdateOperationsInput | string
    manifest?: JsonNullValueInput | InputJsonValue
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumArchiveStatusFieldUpdateOperationsInput | $Enums.ArchiveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionArchiveUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    s3Bucket?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    fileSize?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: StringFieldUpdateOperationsInput | string
    manifest?: JsonNullValueInput | InputJsonValue
    compressionRatio?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumArchiveStatusFieldUpdateOperationsInput | $Enums.ArchiveStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScreenshotCreateManyInteractionInput = {
    id?: string
    sessionId: string
    timestamp: bigint | number
    eventType: string
    s3Key?: string | null
    dataUrl?: string | null
    compressed?: boolean
    format?: string
    fileSize?: number | null
    viewport: JsonNullValueInput | InputJsonValue
    quality?: number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScreenshotUpdateWithoutInteractionInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    dataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    compressed?: BoolFieldUpdateOperationsInput | boolean
    format?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    viewport?: JsonNullValueInput | InputJsonValue
    quality?: FloatFieldUpdateOperationsInput | number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
    session?: UnifiedSessionUpdateOneRequiredWithoutScreenshotsNestedInput
  }

  export type ScreenshotUncheckedUpdateWithoutInteractionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    dataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    compressed?: BoolFieldUpdateOperationsInput | boolean
    format?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    viewport?: JsonNullValueInput | InputJsonValue
    quality?: FloatFieldUpdateOperationsInput | number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScreenshotUncheckedUpdateManyWithoutInteractionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    eventType?: StringFieldUpdateOperationsInput | string
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    dataUrl?: NullableStringFieldUpdateOperationsInput | string | null
    compressed?: BoolFieldUpdateOperationsInput | boolean
    format?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    viewport?: JsonNullValueInput | InputJsonValue
    quality?: FloatFieldUpdateOperationsInput | number
    visionAnalysis?: NullableJsonNullValueInput | InputJsonValue
    userPsychology?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UnifiedSessionCountOutputTypeDefaultArgs instead
     */
    export type UnifiedSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnifiedSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InteractionCountOutputTypeDefaultArgs instead
     */
    export type InteractionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InteractionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnifiedSessionDefaultArgs instead
     */
    export type UnifiedSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnifiedSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InteractionDefaultArgs instead
     */
    export type InteractionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InteractionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScreenshotDefaultArgs instead
     */
    export type ScreenshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScreenshotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionArchiveDefaultArgs instead
     */
    export type SessionArchiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionArchiveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingDataDefaultArgs instead
     */
    export type TrainingDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemConfigDefaultArgs instead
     */
    export type SystemConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QualityReportDefaultArgs instead
     */
    export type QualityReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QualityReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PsychologyProfileDefaultArgs instead
     */
    export type PsychologyProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PsychologyProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContextEnhancementDefaultArgs instead
     */
    export type ContextEnhancementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContextEnhancementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisionAnalysisCacheDefaultArgs instead
     */
    export type VisionAnalysisCacheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisionAnalysisCacheDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}